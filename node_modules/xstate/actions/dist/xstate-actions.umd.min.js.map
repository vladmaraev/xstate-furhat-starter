{"version":3,"file":"xstate-actions.umd.min.js","sources":["../../src/constants.ts","../../src/memo.ts","../../src/eventUtils.ts","../../src/actions/cancel.ts","../../src/Mailbox.ts","../../src/dev/index.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/system.ts","../../src/utils.ts","../../src/interpreter.ts","../../src/actions/stop.ts","../../src/guards.ts","../../src/stateUtils.ts","../../src/State.ts","../../src/spawn.ts","../../src/actions/assign.ts","../../src/actions/choose.ts","../../src/actions/log.ts","../../src/actions/pure.ts","../../src/actions/raise.ts","../../src/types.ts","../../src/actions/send.ts"],"sourcesContent":["export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n\nexport function evict(object: any, key?: string): void {\n  if (!key) {\n    return void cache.delete(object);\n  }\n\n  const memoizedData = cache.get(object);\n\n  if (memoizedData) {\n    delete memoizedData[key];\n  }\n}\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id?: string) {\n  const idSuffix = id ? `#${id}` : '';\n  return { type: `xstate.after(${delayRef})${idSuffix}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  data?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, data };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorContext,\n  AnyActor,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n) {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs) : sendId;\n  return [state, resolvedSendId];\n}\n\nfunction executeCancel(actorContext: AnyActorContext, resolvedSendId: string) {\n  (actorContext.self as AnyActor).cancel(resolvedSendId);\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\n * be executed, nor will its event be sent, unless it has already been sent\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\n *\n * @param sendId The `id` of the `send(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  >\n): CancelAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function cancel(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  // TODO: rethink this design\n  public prepend(event: T): void {\n    if (!this._current) {\n      this.enqueue(event);\n      return;\n    }\n\n    // we know that something is already queued up\n    // so the mailbox is already flushing or it's inactive\n    // therefore the only thing that we need to do is to reassign `this._current`\n    this._current = {\n      value: event,\n      next: this._current\n    };\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      // something could have been prepended in the meantime\n      // so we need to be defensive here to avoid skipping over a prepended item\n      if (consumed === this._current) {\n        this._current = this._current.next;\n      }\n    }\n    this._last = null;\n  }\n}\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if (!!(w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate macrotask.\n * It allows those errors to be detected by global error handlers and reported to bug tracking services\n * without interrupting our own stack of execution.\n *\n * @param err error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import {\n  AnyEventObject,\n  ActorSystem,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  Snapshot\n} from './types.ts';\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const observers = new Set<Observer<InspectionEvent>>();\n\n  const system: ActorSystem<T> = {\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observer) => {\n      observers.add(observer);\n    },\n    _sendInspectionEvent: (event) => {\n      const resolvedInspectionEvent: InspectionEvent = {\n        ...event,\n        rootId: rootActor.sessionId\n      };\n      observers.forEach((observer) => observer.next?.(resolvedInspectionEvent));\n    },\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        targetRef: target,\n        event\n      });\n\n      target._send(event);\n    }\n  };\n\n  return system;\n}\nexport interface BaseInspectionEventProperties {\n  rootId: string; // the session ID of the root\n}\n\nexport interface InspectedSnapshotEvent extends BaseInspectionEventProperties {\n  type: '@xstate.snapshot';\n  actorRef: AnyActorRef; // Only available locally\n  event: AnyEventObject; // { type: string, ... }\n  snapshot: Snapshot<unknown>;\n}\n\nexport interface InspectedEventEvent extends BaseInspectionEventProperties {\n  type: '@xstate.event';\n  // The source might not exist, e.g. when:\n  // - root init events\n  // - events sent from external (non-actor) sources\n  sourceRef: AnyActorRef | undefined;\n  targetRef: AnyActorRef; // Session ID, required\n  event: AnyEventObject; // { type: string, ... }\n}\n\nexport interface InspectedActorEvent extends BaseInspectionEventProperties {\n  type: '@xstate.actor';\n  actorRef: AnyActorRef;\n}\n\nexport type InspectionEvent =\n  | InspectedSnapshotEvent\n  | InspectedEventEvent\n  | InspectedActorEvent;\n","import isDevelopment from '#is-development';\nimport { AnyActorLogic, AnyState } from './index.ts';\nimport { STATE_DELIMITER, TARGETLESS_KEY } from './constants.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type {\n  ActorLogic,\n  AnyEventObject,\n  EventObject,\n  MachineContext,\n  Mapper,\n  Observer,\n  ErrorActorEvent,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  Subscribable,\n  TransitionConfigTarget,\n  AnyActorRef,\n  AnyTransitionConfig,\n  NonReducibleUnknown\n} from './types.ts';\n\nexport function keys<T extends object>(value: T): Array<keyof T & string> {\n  return Object.keys(value) as Array<keyof T & string>;\n}\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  try {\n    if (isArray(stateId)) {\n      return stateId;\n    }\n\n    return stateId.toString().split(STATE_DELIMITER);\n  } catch (e) {\n    throw new Error(`'${stateId}' is not a valid state path.`);\n  }\n}\n\nexport function isStateLike(state: any): state is AnyState {\n  return (\n    typeof state === 'object' &&\n    'value' in state &&\n    'context' in state &&\n    'event' in state\n  );\n}\n\nexport function toStateValue(\n  stateValue: StateLike<any> | StateValue | string[]\n): StateValue {\n  if (isStateLike(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (isArray(stateValue)) {\n    return pathToStateValue(stateValue);\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue as string);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nexport function mapFilterValues<T, P>(\n  collection: { [key: string]: T },\n  iteratee: (item: T, key: string, collection: { [key: string]: T }) => P,\n  predicate: (item: T) => boolean\n): { [key: string]: P } {\n  const result: { [key: string]: P } = {};\n\n  for (const key of Object.keys(collection)) {\n    const item = collection[key];\n\n    if (!predicate(item)) {\n      continue;\n    }\n\n    result[key] = iteratee(item, key, collection);\n  }\n\n  return result;\n}\n\n/**\n * Retrieves a value at the given path.\n * @param props The deep path to the prop of the desired value\n */\nexport function path<T extends Record<string, any>>(props: string[]): any {\n  return (object: T): any => {\n    let result: T = object;\n\n    for (const prop of props) {\n      result = result[prop as keyof typeof result];\n    }\n\n    return result;\n  };\n}\n\nexport function toStatePaths(stateValue: StateValue | undefined): string[][] {\n  if (!stateValue) {\n    return [[]];\n  }\n\n  if (typeof stateValue === 'string') {\n    return [[stateValue]];\n  }\n\n  const result = flatten(\n    Object.keys(stateValue).map((key) => {\n      const subStateValue = stateValue[key];\n\n      if (\n        typeof subStateValue !== 'string' &&\n        (!subStateValue || !Object.keys(subStateValue).length)\n      ) {\n        return [[key]];\n      }\n\n      return toStatePaths(stateValue[key]).map((subPath) => {\n        return [key].concat(subPath);\n      });\n    })\n  );\n\n  return result;\n}\n\nexport function flatten<T>(array: Array<T | T[]>): T[] {\n  return ([] as T[]).concat(...array);\n}\n\nexport function toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([key, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nexport function isBuiltInEvent(eventType: string): boolean {\n  return /^(done|error)\\./.test(eventType);\n}\n\nexport function isPromiseLike(value: any): value is PromiseLike<any> {\n  if (value instanceof Promise) {\n    return true;\n  }\n  // Check if shape matches the Promise/A+ specification for a \"thenable\".\n  if (\n    value !== null &&\n    (typeof value === 'function' || typeof value === 'object') &&\n    typeof value.then === 'function'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isActorLogic(value: any): value is ActorLogic<any, any> {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'transition' in value &&\n    typeof value.transition === 'function'\n  );\n}\n\nexport function partition<T, A extends T, B extends T>(\n  items: T[],\n  predicate: (item: T) => item is A\n): [A[], B[]] {\n  const [truthy, falsy] = [[], []] as [A[], B[]];\n\n  for (const item of items) {\n    if (predicate(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item as B);\n    }\n  }\n\n  return [truthy, falsy];\n}\n\nexport function isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isObservable<T>(value: any): value is Subscribable<T> {\n  return (\n    !!value && 'subscribe' in value && typeof value.subscribe === 'function'\n  );\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function reportUnhandledExceptionOnInvocation(\n  originalError: any,\n  currentError: any,\n  id: string\n) {\n  if (isDevelopment) {\n    const originalStackTrace = originalError.stack\n      ? ` Stacktrace was '${originalError.stack}'`\n      : '';\n    if (originalError === currentError) {\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler for invocation '${id}', error was '${originalError}'.${originalStackTrace}`\n      );\n    } else {\n      const stackTrace = currentError.stack\n        ? ` Stacktrace was '${currentError.stack}'`\n        : '';\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler and/or unhandled exception/promise rejection for invocation '${id}'. ` +\n          `Original error: '${originalError}'. ${originalStackTrace} Current error is '${currentError}'.${stackTrace}`\n      );\n    }\n  }\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${stateNodeId}:invocation[${index}]`;\n}\n\nexport function resolveReferencedActor(\n  referenced:\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input:\n          | Mapper<MachineContext, EventObject, unknown, EventObject>\n          | NonReducibleUnknown;\n      }\n    | undefined\n) {\n  return referenced\n    ? 'transition' in referenced\n      ? { src: referenced, input: undefined }\n      : referenced\n    : undefined;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { createSystem } from './system.ts';\nimport {\n  AreAllImplementationsAssumedToBeProvided,\n  MissingImplementationsError\n} from './typegenTypes.ts';\nimport type {\n  ActorLogic,\n  ActorContext,\n  ActorSystem,\n  AnyActorLogic,\n  AnyStateMachine,\n  EventFromLogic,\n  PersistedStateFrom,\n  SnapshotFrom,\n  AnyActorRef,\n  OutputFrom,\n  DoneActorEvent\n} from './types.ts';\nimport {\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  ActorOptions,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport type SnapshotListener<TLogic extends AnyActorLogic> = (\n  state: SnapshotFrom<TLogic>\n) => void;\n\nexport type EventListener<TEvent extends EventObject = EventObject> = (\n  event: TEvent\n) => void;\n\nexport type Listener = () => void;\nexport type ErrorListener = (error: any) => void;\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\nexport enum ActorStatus {\n  NotStarted,\n  Running,\n  Stopped\n}\n\n/**\n * @deprecated Use `ActorStatus` instead.\n */\nexport const InterpreterStatus = ActorStatus;\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\nexport class Actor<TLogic extends AnyActorLogic>\n  implements ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>\n{\n  /**\n   * The current internal state of the actor.\n   */\n  private _state!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private delayedEventsMap: Record<string, unknown> = {};\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private logger: (...args: any[]) => void;\n  /**\n   * Whether the service is started.\n   */\n  public status: ActorStatus = ActorStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: ActorRef<any, any>;\n  public ref: ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>;\n  // TODO: add typings for system\n  private _actorContext: ActorContext<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    any\n  >;\n\n  private _systemId: string | undefined;\n\n  /**\n   * The globally unique process ID for this invocation.\n   */\n  public sessionId: string;\n\n  public system: ActorSystem<any>;\n  private _doneEvent?: DoneActorEvent;\n\n  public src?: string;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options, if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(public logic: TLogic, options?: ActorOptions<TLogic>) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    } as ActorOptions<TLogic> & typeof defaultOptions;\n\n    const { clock, logger, parent, id, systemId, inspect } = resolvedOptions;\n\n    this.system = parent?.system ?? createSystem(this);\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = logger;\n    this.clock = clock;\n    this._parent = parent;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src;\n    this.ref = this;\n    this._actorContext = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    this._initState();\n  }\n\n  private _initState() {\n    this._state = this.options.state\n      ? this.logic.restoreState\n        ? this.logic.restoreState(this.options.state, this._actorContext)\n        : this.options.state\n      : this.logic.getInitialState(this._actorContext, this.options?.input);\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._state = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      deferredFn();\n    }\n\n    for (const observer of this.observers) {\n      // TODO: should observers be notified in case of the error?\n      try {\n        observer.next?.(snapshot);\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    switch ((this._state as any).status) {\n      case 'done':\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._state as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._stopProcedure();\n        this._error((this._state as any).error);\n        if (this._parent) {\n          this.system._relay(\n            this,\n            this._parent,\n            createErrorActorEvent(this.id, (this._state as any).error)\n          );\n        }\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (state: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((state: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this.status !== ActorStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  /**\n   * Starts the Actor from the initial state\n   */\n  public start(): this {\n    if (this.status === ActorStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this.status = ActorStatus.Running;\n\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      targetRef: this,\n      event: initEvent\n    });\n\n    const status = (this._state as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon intialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._state,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n      // fallthrough\n      case 'error':\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._state, this._actorContext);\n      } catch (err) {\n        this._stopProcedure();\n        this._error(err);\n        this._parent?.send(createErrorActorEvent(this.id, err));\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._state, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    // TODO: reexamine what happens when an action (or a guard or smth) throws\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._state, event, this._actorContext);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._stopProcedure();\n      this._error(err);\n      this._parent?.send(createErrorActorEvent(this.id, err));\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this.status === ActorStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this.status === ActorStatus.NotStarted) {\n      this.status = ActorStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /**\n   * Stops the Actor and unsubscribe all listeners.\n   */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _error(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _stopProcedure(): this {\n    if (this.status !== ActorStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    for (const key of Object.keys(this.delayedEventsMap)) {\n      this.clock.clearTimeout(this.delayedEventsMap[key]);\n    }\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this.status = ActorStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this.status === ActorStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public delaySend({\n    event,\n    id,\n    delay,\n    to\n  }: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number;\n    to?: AnyActorRef;\n  }): void {\n    const timerId = this.clock.setTimeout(() => {\n      this.system._relay(this, to ?? this, event as EventFromLogic<TLogic>);\n    }, delay);\n\n    // TODO: consider the rehydration story here\n    if (id) {\n      this.delayedEventsMap[id] = timerId;\n    }\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public cancel(sendId: string | number): void {\n    this.clock.clearTimeout(this.delayedEventsMap[sendId]);\n    delete this.delayedEventsMap[sendId];\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      id: this.id\n    };\n  }\n\n  public getPersistedState(): PersistedStateFrom<TLogic> | undefined {\n    return this.logic.getPersistedState?.(this._state);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    return this._state;\n  }\n}\n\n/**\n * Creates a new `ActorRef` instance for the given machine with the provided options, if any.\n *\n * @param machine The machine to create an actor from\n * @param options `ActorRef` options\n */\nexport function createActor<TMachine extends AnyStateMachine>(\n  machine: AreAllImplementationsAssumedToBeProvided<\n    TMachine['__TResolvedTypesMeta']\n  > extends true\n    ? TMachine\n    : MissingImplementationsError<TMachine['__TResolvedTypesMeta']>,\n  options?: ActorOptions<TMachine>\n): Actor<TMachine>;\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: ActorOptions<TLogic>\n): Actor<TLogic>;\nexport function createActor(logic: any, options?: ActorOptions<any>): any {\n  const interpreter = new Actor(logic, options);\n\n  return interpreter;\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @deprecated Use `createActor` instead\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport { ActorStatus } from '../interpreter.ts';\nimport {\n  ActionArgs,\n  ActorRef,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ActorRef<any, any>\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => ActorRef<any, any> | string);\n\nfunction resolveStop(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n) {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args) : actorRef;\n  const resolvedActorRef: ActorRef<any, any> | undefined =\n    typeof actorRefOrString === 'string'\n      ? state.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = state.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneState(state, {\n      children\n    }),\n    resolvedActorRef\n  ];\n}\nfunction executeStop(\n  actorContext: AnyActorContext,\n  actorRef: ActorRef<any, any> | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n  if (actorRef.status !== ActorStatus.Running) {\n    actorContext.stopChild(actorRef);\n    return;\n  }\n  // TODO: recheck why this one has to be deferred\n  actorContext.defer(() => {\n    actorContext.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n * Stops an actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stop<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  >\n): StopAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function stop(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stop';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyState,\n  NoRequiredParams,\n  NoInfer,\n  WithDynamicParams\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  guard: TExpressionGuard;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TExpressionGuard, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject,\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    state: AnyState,\n    guardArgs: GuardArgs<any, any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  state: AnyState,\n  _: GuardArgs<any, any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    return state.configuration.some((sn) => sn.id === stateValue.slice(1));\n  }\n\n  return state.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n>(stateValue: StateValue) {\n  function stateIn(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    any // TODO: recheck if we could replace this with something better here\n  >;\n}\n\nfunction checkNot(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, state);\n}\n\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(guard: Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>) {\n  function not(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkAnd(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function and(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkOr(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function or(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  state: AnyState\n): boolean {\n  const { machine } = state;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, state);\n  }\n\n  const guardArgs = {\n    context,\n    event,\n    guard: isInline\n      ? undefined\n      : typeof guard === 'string'\n      ? { type: guard }\n      : typeof guard.params === 'function'\n      ? {\n          type: guard.type,\n          params: guard.params({ context, event })\n        }\n      : guard\n  };\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    state,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { State, cloneState } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { invoke } from './actions/invoke.ts';\nimport { stop } from './actions/stop.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { ActorStatus } from './interpreter.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyState,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayExpr,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  SingleOrArray,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  AnyActorRef,\n  UnknownAction,\n  ParameterizedObject,\n  ActionFunction,\n  AnyTransitionConfig,\n  ProvidedActor\n} from './types.ts';\nimport {\n  isArray,\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toStateValue,\n  toTransitionConfigArray\n} from './utils.ts';\n\ntype Configuration<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyConfiguration = Configuration<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nfunction getOutput<TContext extends MachineContext, TEvent extends EventObject>(\n  configuration: StateNode<TContext, TEvent>[],\n  context: TContext,\n  event: TEvent,\n  self: AnyActorRef\n) {\n  const { machine } = configuration[0];\n  const { root } = machine;\n\n  if (!root.output) {\n    return undefined;\n  }\n\n  const finalChildStateNode = configuration.find(\n    (stateNode) =>\n      stateNode.type === 'final' && stateNode.parent === machine.root\n  )!;\n\n  const doneStateEvent = createDoneStateEvent(\n    finalChildStateNode.id,\n    finalChildStateNode.output\n      ? resolveOutput(finalChildStateNode.output, context, event, self)\n      : undefined\n  );\n\n  return resolveOutput(root.output, context, doneStateEvent, self);\n}\n\nexport const isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getConfiguration(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const configuration = new Set(stateNodes);\n  const configurationSet = new Set(stateNodes);\n\n  const adjList = getAdjList(configurationSet);\n\n  // add descendants\n  for (const s of configuration) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodes(s).forEach((sn) => configurationSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!configurationSet.has(child)) {\n            for (const initialStateNode of getInitialStateNodes(child)) {\n              configurationSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of configurationSet) {\n    let m = s.parent;\n\n    while (m) {\n      configurationSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return configurationSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nexport function getAdjList<\n  TContext extends MachineContext,\n  TE extends EventObject\n>(configuration: Configuration<TContext, TE>): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of configuration) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  configuration: AnyConfiguration\n): StateValue {\n  const config = getConfiguration(configuration);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  configuration: Array<AnyStateNode>,\n  stateNode: AnyStateNode = configuration[0].machine.root\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && configuration.includes(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(configuration, sn)\n    );\n  }\n\n  return false;\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((descriptor) => {\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (descriptor === WILDCARD) {\n          return true;\n        }\n\n        if (!descriptor.endsWith('.*')) {\n          return false;\n        }\n\n        if (isDevelopment && /.*\\*.+/.test(descriptor)) {\n          console.warn(\n            `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`\n          );\n        }\n\n        const partialEventTokens = descriptor.split('.');\n        const eventTokens = receivedEventType.split('.');\n\n        for (\n          let tokenIndex = 0;\n          tokenIndex < partialEventTokens.length;\n          tokenIndex++\n        ) {\n          const partialEventToken = partialEventTokens[tokenIndex];\n          const eventToken = eventTokens[tokenIndex];\n\n          if (partialEventToken === '*') {\n            const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n            if (isDevelopment && !isLastToken) {\n              console.warn(\n                `Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`\n              );\n            }\n\n            return isLastToken;\n          }\n\n          if (partialEventToken !== eventToken) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/**\n * All delayed transitions from the config.\n */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >,\n    i: number\n  ) => {\n    const delayRef =\n      typeof delay === 'function' ? `${stateNode.id}:delay[${i}]` : delay;\n    const afterEvent = createAfterEvent(delayRef, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, { id: eventType, delay }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = isArray(afterConfig)\n    ? afterConfig.map((transition, i) => {\n        const eventType = mutateEntryExit(transition.delay, i);\n        return { ...transition, event: eventType };\n      })\n    : Object.keys(afterConfig).flatMap((delay, i) => {\n        const configTransition = afterConfig[delay];\n        const resolvedTransition =\n          typeof configTransition === 'string'\n            ? { target: configTransition }\n            : configTransition;\n        const resolvedDelay = !isNaN(+delay) ? +delay : delay;\n        const eventType = mutateEntryExit(resolvedDelay, i);\n        return toArray(resolvedTransition).map((transition) => ({\n          ...transition,\n          event: eventType,\n          delay: resolvedDelay\n        }));\n      });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | SingleOrArray<string>\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  if (typeof _target === 'string' || isArray(_target)) {\n    const targets = toArray(_target).map((t) => {\n      // Resolve state string keys (which represent children)\n      // to their state node\n      const descStateNode =\n        typeof t === 'string'\n          ? isStateId(t)\n            ? stateNode.machine.getStateNodeById(t)\n            : stateNode.states[t]\n          : t;\n\n      if (!descStateNode) {\n        throw new Error(\n          `Initial state node \"${t}\" not found on parent state node #${stateNode.id}`\n        );\n      }\n\n      if (!isDescendant(descStateNode, stateNode)) {\n        throw new Error(\n          `Invalid initial target: state node #${descStateNode.id} is not a descendant of #${stateNode.id}`\n        );\n      }\n\n      return descStateNode;\n    });\n    const resolvedTarget = resolveTarget(stateNode, targets);\n\n    const transition = {\n      source: stateNode,\n      actions: [],\n      eventType: null as any,\n      reenter: false,\n      target: resolvedTarget!,\n      toJSON: () => ({\n        ...transition,\n        source: `#${stateNode.id}`,\n        target: resolvedTarget\n          ? resolvedTarget.map((t) => `#${t.id}`)\n          : undefined\n      })\n    };\n\n    return transition;\n  }\n\n  return formatTransition(stateNode, '__INITIAL__', {\n    target: toArray(_target.target).map((t) => {\n      if (typeof t === 'string') {\n        return isStateId(t) ? t : `${STATE_DELIMITER}${t}`;\n      }\n\n      return t;\n    }),\n    actions: _target.actions\n  }) as InitialTransitionDefinition<TContext, TEvent>;\n}\n\nexport function resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }): ReadonlyArray<AnyStateNode> {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial.target;\n  }\n  return normalizedTarget.map((t) =>\n    typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n  );\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nexport function getInitialStateNodes(\n  stateNode: AnyStateNode\n): Array<AnyStateNode> {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      for (const targetStateNode of descStateNode.initial.target) {\n        for (const a of getProperAncestors(targetStateNode, stateNode)) {\n          set.add(a);\n        }\n\n        iter(targetStateNode);\n      }\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return [...set];\n}\n/**\n * Returns the child state node from its relative `stateKey`, or throws.\n */\nexport function getStateNode(\n  stateNode: AnyStateNode,\n  stateKey: string\n): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch (e) {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param state The state value or State instance\n */\nexport function getStateNodes<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  state: StateValue | State<TContext, TEvent, TODO, TODO, TODO>\n): Array<AnyStateNode> {\n  const stateValue = state instanceof State ? state.value : toStateValue(state);\n\n  if (typeof stateValue === 'string') {\n    return [stateNode, stateNode.states[stateValue]];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nexport function transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(state, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]],\n    state,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      state,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(state, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  state: State<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO // tags\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, state, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, state, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, state, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction getPathFromRootToNode(stateNode: AnyStateNode): Array<AnyStateNode> {\n  const path: Array<AnyStateNode> = [];\n  let marker = stateNode.parent;\n\n  while (marker) {\n    path.unshift(marker);\n    marker = marker.parent;\n  }\n\n  return path;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], configuration, historyValue),\n          computeExitSet([t2], configuration, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLCCA(stateNodes: Array<AnyStateNode>): AnyStateNode {\n  const [head] = stateNodes;\n\n  let current = getPathFromRootToNode(head);\n  let candidates: Array<AnyStateNode> = [];\n\n  for (const stateNode of stateNodes) {\n    const path = getPathFromRootToNode(stateNode);\n\n    candidates = current.filter((sn) => path.includes(sn));\n    current = candidates;\n    candidates = [];\n  }\n\n  return current[current.length - 1];\n}\n\nfunction getEffectiveTargetStates(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          {\n            target: resolveHistoryTarget(targetNode)\n          } as AnyTransitionDefinition,\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | null {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return null;\n  }\n\n  if (\n    !transition.reenter &&\n    transition.source.type !== 'parallel' &&\n    targetStates.every((targetStateNode) =>\n      isDescendant(targetStateNode, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lcca = findLCCA(targetStates.concat(transition.source));\n\n  return lcca;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      for (const stateNode of configuration) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\n/**\n * https://www.w3.org/TR/scxml/#microstepProcedure\n *\n * @private\n * @param transitions\n * @param currentState\n * @param mutConfiguration\n */\n\nexport function microstep<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  transitions: Array<TransitionDefinition<TContext, TEvent>>,\n  currentState: AnyState,\n  actorCtx: AnyActorContext,\n  event: TEvent,\n  isInitial: boolean\n): AnyState {\n  const mutConfiguration = new Set(currentState.configuration);\n\n  if (!transitions.length) {\n    return currentState;\n  }\n\n  const microstate = microstepProcedure(\n    transitions,\n    currentState,\n    mutConfiguration,\n    event,\n    actorCtx,\n    isInitial\n  );\n\n  return cloneState(microstate, {\n    value: {} // TODO: make optional\n  });\n}\n\nfunction microstepProcedure(\n  transitions: Array<AnyTransitionDefinition>,\n  currentState: AnyState,\n  mutConfiguration: Set<AnyStateNode>,\n  event: AnyEventObject,\n  actorCtx: AnyActorContext,\n  isInitial: boolean\n): typeof currentState {\n  const actions: UnknownAction[] = [];\n  const historyValue = {\n    ...currentState.historyValue\n  };\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  const internalQueue = [...currentState._internalQueue];\n\n  // Exit states\n  if (!isInitial) {\n    exitStates(filteredTransitions, mutConfiguration, historyValue, actions);\n  }\n\n  // Execute transition content\n  actions.push(...filteredTransitions.flatMap((t) => t.actions));\n\n  // Enter states\n  enterStates(\n    event,\n    filteredTransitions,\n    mutConfiguration,\n    actions,\n    internalQueue,\n    currentState,\n    historyValue,\n    isInitial,\n    actorCtx\n  );\n\n  const nextConfiguration = [...mutConfiguration];\n\n  const done = isInFinalState(nextConfiguration);\n\n  if (done) {\n    const finalActions = nextConfiguration\n      .sort((a, b) => b.order - a.order)\n      .flatMap((state) => state.exit);\n    actions.push(...finalActions);\n  }\n\n  try {\n    const nextState = resolveActionsAndContext(\n      actions,\n      event,\n      currentState,\n      actorCtx\n    );\n\n    const output = done\n      ? getOutput(nextConfiguration, nextState.context, event, actorCtx.self)\n      : undefined;\n\n    internalQueue.push(...nextState._internalQueue);\n\n    return cloneState(currentState, {\n      configuration: nextConfiguration,\n      historyValue,\n      _internalQueue: internalQueue,\n      context: nextState.context,\n      status: done ? 'done' : currentState.status,\n      output,\n      children: nextState.children\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction enterStates(\n  event: AnyEventObject,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  currentState: AnyState,\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean,\n  actorContext: AnyActorContext\n): void {\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentState.machine.root);\n  }\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutConfiguration.add(stateNodeToEnter);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(invoke(invokeDef));\n    }\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      for (const stateNode of statesForDefaultEntry) {\n        const initialActions = stateNode.initial!.actions;\n        actions.push(...initialActions);\n      }\n    }\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent!;\n\n      if (!parent.parent) {\n        continue;\n      }\n\n      internalQueue.push(\n        createDoneStateEvent(\n          parent!.id,\n          stateNodeToEnter.output\n            ? resolveOutput(\n                stateNodeToEnter.output,\n                currentState.context,\n                event,\n                actorContext.self\n              )\n            : undefined\n        )\n      );\n\n      if (parent.parent) {\n        const grandparent = parent.parent;\n\n        if (grandparent.type === 'parallel') {\n          if (\n            getChildren(grandparent).every((parentNode) =>\n              isInFinalState([...mutConfiguration], parentNode)\n            )\n          ) {\n            internalQueue.push(createDoneStateEvent(grandparent.id));\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    for (const s of t.target || []) {\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const ancestor = getTransitionDomain(t, historyValue);\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      addAncestorStatesToEnter(\n        s,\n        ancestor,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode.parent!,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    } else {\n      const targets = resolveHistoryTarget<TContext, TEvent>(stateNode);\n      for (const s of targets) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of targets) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    }\n  } else {\n    statesToEnter.add(stateNode);\n    if (stateNode.type === 'compound') {\n      statesForDefaultEntry.add(stateNode);\n      const initialStates = stateNode.initial.target;\n\n      for (const initialState of initialStates) {\n        addDescendantStatesToEnter(\n          initialState,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const initialState of initialStates) {\n        addAncestorStatesToEnter(\n          initialState,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  const properAncestors = getProperAncestors(stateNode, toStateNode);\n  for (const anc of properAncestors) {\n    statesToEnter.add(anc);\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction exitStates(\n  transitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  actions: UnknownAction[]\n) {\n  const statesToExit = computeExitSet(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      historyValue[historyNode.id] =\n        Array.from(mutConfiguration).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    actions.push(...s.exit, ...s.invoke.map((def) => stop(def.id)));\n    mutConfiguration.delete(s);\n  }\n}\n\ninterface BuiltinAction {\n  (): void;\n  resolve: (\n    actorContext: AnyActorContext,\n    state: AnyState,\n    actionArgs: ActionArgs<any, any, any, any>,\n    action: unknown\n  ) => [newState: AnyState, params: unknown, actions?: UnknownAction[]];\n  execute: (actorContext: AnyActorContext, params: unknown) => void;\n}\n\nexport function resolveActionsAndContext<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  actions: UnknownAction[],\n  event: TExpressionEvent,\n  currentState: AnyState,\n  actorCtx: AnyActorContext\n): AnyState {\n  const { machine } = currentState;\n  // TODO: this `cloneState` is really just a hack to prevent infinite loops\n  // we need to take another look at how internal queue is managed\n  let intermediateState = cloneState(currentState, {\n    _internalQueue: []\n  });\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        (\n          machine.implementations.actions as Record<\n            string,\n            ActionFunction<\n              MachineContext,\n              EventObject,\n              EventObject,\n              ParameterizedObject | undefined,\n              ProvidedActor,\n              ParameterizedObject,\n              ParameterizedObject,\n              string\n            >\n          >\n        )[typeof action === 'string' ? action : action.type];\n\n    if (!resolvedAction) {\n      continue;\n    }\n\n    const actionArgs = {\n      context: intermediateState.context,\n      event,\n      self: actorCtx?.self,\n      system: actorCtx?.system,\n      action: isInline\n        ? undefined\n        : typeof action === 'string'\n        ? { type: action }\n        : typeof action.params === 'function'\n        ? {\n            type: action.type,\n            params: action.params({ context: intermediateState.context, event })\n          }\n        : // TS isn't able to narrow it down here\n          (action as { type: string })\n    };\n\n    if (!('resolve' in resolvedAction)) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        resolvedAction(actionArgs);\n      } else {\n        actorCtx?.defer(() => {\n          resolvedAction(actionArgs);\n        });\n      }\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorCtx,\n      intermediateState,\n      actionArgs,\n      resolvedAction // this holds all params\n    );\n    intermediateState = nextState;\n\n    if ('execute' in resolvedAction) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        builtinAction.execute(actorCtx!, params);\n      } else {\n        actorCtx?.defer(builtinAction.execute.bind(null, actorCtx!, params));\n      }\n    }\n\n    if (actions) {\n      intermediateState = resolveActionsAndContext(\n        actions,\n        event,\n        intermediateState,\n        actorCtx\n      );\n    }\n  }\n\n  return intermediateState;\n}\n\nexport function macrostep(\n  state: AnyState,\n  event: EventObject,\n  actorCtx: AnyActorContext\n): {\n  state: typeof state;\n  microstates: Array<typeof state>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextState = state;\n  const states: AnyState[] = [];\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextState = stopStep(event, nextState, actorCtx);\n    states.push(nextState);\n\n    return {\n      state: nextState,\n      microstates: states\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const transitions = selectTransitions(nextEvent, nextState);\n    nextState = microstep(transitions, state, actorCtx, nextEvent, false);\n    states.push(nextState);\n  }\n\n  while (nextState.status === 'active') {\n    let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);\n\n    if (!enabledTransitions.length) {\n      if (!nextState._internalQueue.length) {\n        break;\n      } else {\n        nextEvent = nextState._internalQueue[0];\n        const transitions = selectTransitions(nextEvent, nextState);\n        nextState = microstep(\n          transitions,\n          nextState,\n          actorCtx,\n          nextEvent,\n          false\n        );\n        nextState._internalQueue.shift();\n\n        states.push(nextState);\n      }\n    } else {\n      nextState = microstep(\n        enabledTransitions,\n        nextState,\n        actorCtx,\n        nextEvent,\n        false\n      );\n\n      states.push(nextState);\n    }\n  }\n\n  if (nextState.status !== 'active') {\n    // Perform the stop step to ensure that child actors are stopped\n    stopStep(nextEvent, nextState, actorCtx);\n  }\n\n  return {\n    state: nextState,\n    microstates: states\n  };\n}\n\nfunction stopStep(\n  event: AnyEventObject,\n  nextState: AnyState,\n  actorCtx: AnyActorContext\n) {\n  const actions: UnknownAction[] = [];\n\n  for (const stateNode of nextState.configuration.sort(\n    (a, b) => b.order - a.order\n  )) {\n    actions.push(...stateNode.exit);\n  }\n\n  for (const child of Object.values(nextState.children)) {\n    actions.push(stop(child));\n  }\n\n  return resolveActionsAndContext(actions, event, nextState, actorCtx);\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyState\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyState,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState.configuration.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, null)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState.configuration),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const configuration = getConfiguration(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...configuration]);\n}\n\nexport function stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a as StateValueMap);\n  const bKeys = Object.keys(b as StateValueMap);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nexport function getInitialConfiguration(\n  rootNode: AnyStateNode\n): AnyStateNode[] {\n  const configuration: AnyStateNode[] = [];\n  const initialTransition = rootNode.initial;\n\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>([rootNode]);\n\n  computeEntrySet(\n    [initialTransition],\n    {},\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    configuration.push(stateNodeToEnter);\n  }\n\n  return configuration;\n}\n","import isDevelopment from '#is-development';\nimport { STATE_DELIMITER } from './constants.ts';\nimport { memo } from './memo.ts';\nimport { MachineSnapshot } from './StateMachine.ts';\nimport type { StateNode } from './StateNode.ts';\nimport {\n  getConfiguration,\n  getStateNodes,\n  getStateValue\n} from './stateUtils.ts';\nimport { TypegenDisabled, TypegenEnabled } from './typegenTypes.ts';\nimport type {\n  ProvidedActor,\n  ActorRefFrom,\n  AnyState,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  PersistedMachineState,\n  Prop,\n  StateConfig,\n  StateValue,\n  TODO,\n  AnyActorRef,\n  Compute,\n  EventDescriptor\n} from './types.ts';\nimport { flatten, matchesState } from './utils.ts';\n\ntype ComputeConcreteChildren<TActor extends ProvidedActor> = {\n  [A in TActor as 'id' extends keyof A\n    ? A['id'] & string\n    : never]?: ActorRefFrom<A['logic']>;\n};\n\ntype ComputeChildren<TActor extends ProvidedActor> =\n  // only proceed further if all configured `src`s are literal strings\n  string extends TActor['src']\n    ? // TODO: replace with UnknownActorRef~\n      // TODO: consider adding `| undefined` here\n      Record<string, AnyActorRef>\n    : Compute<\n        ComputeConcreteChildren<TActor> &\n          // check if all actors have IDs\n          (undefined extends TActor['id']\n            ? // if they don't we need to create an index signature containing all possible actor types\n              {\n                [id: string]: TActor extends any\n                  ? ActorRefFrom<TActor['logic']> | undefined\n                  : never;\n              }\n            : {})\n      >;\n\nexport function isStateConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(state: any): state is StateConfig<TContext, TEvent> {\n  if (typeof state !== 'object' || state === null) {\n    return false;\n  }\n\n  return 'value' in state;\n}\n\n/**\n * @deprecated Use `isStateConfig(object)` or `state instanceof State` instead.\n */\nexport const isState = isStateConfig;\nexport class State<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TResolvedTypesMeta = TypegenDisabled\n> {\n  public tags: Set<string>;\n\n  public value: StateValue;\n  /**\n   * Indicates whether the state is a final state.\n   */\n  public status: 'active' | 'done' | 'error' | 'stopped';\n  /**\n   * The output data of the top-level finite state.\n   */\n  public error: unknown;\n  public context: TContext;\n  public historyValue: Readonly<HistoryValue<TContext, TEvent>> = {};\n  public _internalQueue: Array<TEvent>;\n  /**\n   * The enabled state nodes representative of the state value.\n   */\n  public configuration: Array<StateNode<TContext, TEvent>>;\n  /**\n   * An object mapping actor names to spawned/invoked actors.\n   */\n  public children: ComputeChildren<TActor>;\n\n  /**\n   * Creates a new State instance for the given `stateValue` and `context`.\n   * @param stateValue\n   * @param context\n   */\n  public static from<\n    TContext extends MachineContext,\n    TEvent extends EventObject = EventObject\n  >(\n    stateValue:\n      | State<\n          TContext,\n          TEvent,\n          TODO,\n          any, // tags\n          any // typegen\n        >\n      | StateValue,\n    context: TContext = {} as TContext,\n    machine: AnyStateMachine\n  ): State<\n    TContext,\n    TEvent,\n    TODO,\n    any, // tags\n    any // typegen\n  > {\n    if (stateValue instanceof State) {\n      if (stateValue.context !== context) {\n        return new State<TContext, TEvent, TODO, any, any>(\n          {\n            value: stateValue.value,\n            context,\n            meta: {},\n            configuration: [], // TODO: fix,\n            children: {},\n            status: 'active'\n          },\n          machine\n        );\n      }\n\n      return stateValue;\n    }\n\n    const configuration = getConfiguration(\n      getStateNodes(machine.root, stateValue)\n    );\n\n    return new State<TContext, TEvent, TODO, any, any>(\n      {\n        value: stateValue,\n        context,\n        meta: undefined,\n        configuration: Array.from(configuration),\n        children: {},\n        status: 'active'\n      },\n      machine\n    );\n  }\n\n  /**\n   * Creates a new `State` instance that represents the current state of a running machine.\n   *\n   * @param config\n   */\n  constructor(\n    config: StateConfig<TContext, TEvent>,\n    public machine: AnyStateMachine\n  ) {\n    this.context = config.context;\n    this._internalQueue = config._internalQueue ?? [];\n    this.historyValue = config.historyValue || {};\n    this.matches = this.matches.bind(this);\n    this.toStrings = this.toStrings.bind(this);\n    this.configuration =\n      config.configuration ??\n      Array.from(getConfiguration(getStateNodes(machine.root, config.value)));\n    this.children = config.children as any;\n\n    this.value = getStateValue(machine.root, this.configuration);\n    this.tags = new Set(flatten(this.configuration.map((sn) => sn.tags)));\n    this.status = config.status;\n    (this as any).output = config.output;\n    (this as any).error = config.error;\n  }\n\n  /**\n   * Returns an array of all the string leaf state node paths.\n   * @param stateValue\n   * @param delimiter The character(s) that separate each subpath in the string state node path.\n   */\n  public toStrings(stateValue: StateValue = this.value): string[] {\n    if (typeof stateValue === 'string') {\n      return [stateValue];\n    }\n    const valueKeys = Object.keys(stateValue);\n\n    return valueKeys.concat(\n      ...valueKeys.map((key) =>\n        this.toStrings(stateValue[key]).map((s) => key + STATE_DELIMITER + s)\n      )\n    );\n  }\n\n  public toJSON() {\n    const { configuration, tags, machine, ...jsonValues } = this;\n\n    return { ...jsonValues, tags: Array.from(tags), meta: this.meta };\n  }\n\n  /**\n   * Whether the current state value is a subset of the given parent state value.\n   * @param parentStateValue\n   */\n  public matches<\n    TSV extends TResolvedTypesMeta extends TypegenEnabled\n      ? Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'matchesStates'>\n      : StateValue\n  >(parentStateValue: TSV): boolean {\n    return matchesState(parentStateValue as any, this.value);\n  }\n\n  /**\n   * Whether the current state configuration has a state node with the specified `tag`.\n   * @param tag\n   */\n  public hasTag(tag: TTag): boolean {\n    return this.tags.has(tag as string);\n  }\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden transition\n   * to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  public can(event: TEvent): boolean {\n    if (isDevelopment && !this.machine) {\n      console.warn(\n        `state.can(...) used outside of a machine-created State object; this will always return false.`\n      );\n    }\n\n    const transitionData = this.machine.getTransitionData(this as any, event);\n\n    return (\n      !!transitionData?.length &&\n      // Check that at least one transition is not forbidden\n      transitionData.some((t) => t.target !== undefined || t.actions.length)\n    );\n  }\n\n  /**\n   * The next events that will cause a transition from the current state.\n   */\n  public get nextEvents(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'nextEvents', () => {\n      return [\n        ...new Set(flatten([...this.configuration.map((sn) => sn.ownEvents)]))\n      ];\n    });\n  }\n\n  public get meta(): Record<string, any> {\n    return this.configuration.reduce((acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    }, {} as Record<string, any>);\n  }\n}\n\nexport function cloneState<TState extends AnyState>(\n  state: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return new State(\n    { ...state, ...config } as StateConfig<any, any>,\n    state.machine\n  ) as TState;\n}\n\nexport function getPersistedState<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TOutput,\n  TResolvedTypesMeta = TypegenDisabled\n>(\n  state: MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  >\n): PersistedMachineState<\n  TContext,\n  TEvent,\n  TActor,\n  TTag,\n  TOutput,\n  TResolvedTypesMeta\n> {\n  const { configuration, tags, machine, children, ...jsonValues } = state;\n\n  const childrenJson: Partial<\n    PersistedMachineState<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >['children']\n  > = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    childrenJson[id as keyof typeof childrenJson] = {\n      state: child.getPersistedState?.(),\n      src: child.src\n    };\n  }\n\n  return {\n    ...jsonValues,\n    children: childrenJson\n  } as PersistedMachineState<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  >;\n}\n","import { createErrorActorEvent } from './eventUtils.ts';\nimport { ActorStatus, createActor } from './interpreter.ts';\nimport {\n  ActorRefFrom,\n  AnyActorContext,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyEventObject,\n  AnyState,\n  InputFrom,\n  IsLiteralString,\n  ProvidedActor,\n  Snapshot,\n  TODO\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? 'id' extends keyof TActor\n    ? [\n        options: {\n          id: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        }\n      ]\n    : [\n        options?: {\n          id?: string;\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        }\n      ]\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> = IsLiteralString<\n  TActor['src']\n> extends true\n  ? <TSrc extends TActor['src']>(\n      logic: TSrc,\n      ...[options = {} as any]: SpawnOptions<TActor, TSrc>\n    ) => ActorRefFrom<(TActor & { src: TSrc })['logic']>\n  : // TODO: do not accept machines without all implementations\n    <TLogic extends AnyActorLogic | string>(\n      src: TLogic,\n      options?: {\n        id?: string;\n        systemId?: string;\n        input?: unknown;\n        syncSnapshot?: boolean;\n      }\n    ) => TLogic extends string ? AnyActorRef : ActorRefFrom<TLogic>;\n\nexport function createSpawner(\n  actorContext: AnyActorContext,\n  { machine, context }: AnyState,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = (src, options = {}) => {\n    const { systemId } = options;\n    if (typeof src === 'string') {\n      const referenced = resolveReferencedActor(\n        machine.implementations.actors[src]\n      );\n\n      if (!referenced) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const input = 'input' in options ? options.input : referenced.input;\n\n      // TODO: this should also receive `src`\n      const actorRef = createActor(referenced.src, {\n        id: options.id,\n        parent: actorContext.self,\n        input:\n          typeof input === 'function'\n            ? input({\n                context,\n                event,\n                self: actorContext.self\n              })\n            : input,\n        systemId\n      }) as any;\n      spawnedChildren[actorRef.id] = actorRef;\n\n      if (options.syncSnapshot) {\n        actorRef.subscribe({\n          next: (snapshot: Snapshot<unknown>) => {\n            if (snapshot.status === 'active') {\n              actorContext.self.send({\n                type: `xstate.snapshot.${actorRef.id}`,\n                snapshot\n              });\n            }\n          },\n          error: () => {\n            /* TODO */\n          }\n        });\n      }\n      return actorRef;\n    } else {\n      // TODO: this should also receive `src`\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorContext.self,\n        input: options.input,\n        systemId\n      });\n\n      if (options.syncSnapshot) {\n        actorRef.subscribe({\n          next: (snapshot: Snapshot<unknown>) => {\n            if (snapshot.status === 'active') {\n              actorContext.self.send({\n                type: `xstate.snapshot.${actorRef.id}`,\n                snapshot,\n                id: actorRef.id\n              });\n            }\n          },\n          error: () => {\n            /* TODO */\n          }\n        });\n      }\n\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorContext.defer(() => {\n      if (actorRef.status === ActorStatus.Stopped) {\n        return;\n      }\n      try {\n        actorRef.start?.();\n      } catch (err) {\n        actorContext.self.send(createErrorActorEvent(actorRef.id, err));\n        return;\n      }\n    });\n    return actorRef;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorContext,\n  AnyActorRef,\n  AnyEventObject,\n  AnyState,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorContext: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n) {\n  if (!state.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any, any> = {\n    context: state.context,\n    event: actionArgs.event,\n    action: actionArgs.action,\n    spawn: createSpawner(\n      actorContext,\n      state,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorContext?.self,\n    system: actorContext?.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, state.context, partialUpdate);\n\n  return [\n    cloneState(state, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...state.children,\n            ...spawnedChildren\n          }\n        : state.children\n    })\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject = AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TEvent extends EventObject = EventObject,\n  TActor extends ProvidedActor = ProvidedActor\n>(\n  assignment:\n    | Assigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor\n      >\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor\n      >\n): AssignAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TActor> {\n  function assign(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import isDevelopment from '#is-development';\nimport {\n  EventObject,\n  ChooseBranch,\n  MachineContext,\n  AnyActorContext,\n  AnyState,\n  ActionArgs,\n  ParameterizedObject,\n  NoInfer,\n  ProvidedActor\n} from '../types.ts';\nimport { evaluateGuard } from '../guards.ts';\nimport { toArray } from '../utils.ts';\n\nfunction resolveChoose(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    branches\n  }: {\n    branches: Array<\n      ChooseBranch<\n        MachineContext,\n        EventObject,\n        EventObject,\n        ProvidedActor,\n        ParameterizedObject,\n        ParameterizedObject,\n        string\n      >\n    >;\n  }\n) {\n  const matchedActions = branches.find((condition) => {\n    return (\n      !condition.guard ||\n      evaluateGuard(condition.guard, state.context, actionArgs.event, state)\n    );\n  })?.actions;\n\n  return [state, undefined, toArray(matchedActions)];\n}\n\nexport interface ChooseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n}\n\nexport function choose<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n>(\n  branches: ReadonlyArray<\n    ChooseBranch<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TActor,\n      NoInfer<TAction>,\n      NoInfer<TGuard>,\n      TDelay\n    >\n  >\n): ChooseAction<\n  TContext,\n  TExpressionEvent,\n  TExpressionAction,\n  TEvent,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay\n> {\n  function choose(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  choose.type = 'xstate.choose';\n  choose.branches = branches;\n\n  choose.resolve = resolveChoose;\n\n  return choose;\n}\n","import isDevelopment from '#is-development';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  LogExpr,\n  MachineContext,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableLogValue<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = string | LogExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n\nfunction resolveLog(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    value,\n    label\n  }: {\n    value: ResolvableLogValue<any, any, any, any>;\n    label: string | undefined;\n  }\n) {\n  return [\n    state,\n    {\n      value: typeof value === 'function' ? value(actionArgs) : value,\n      label\n    }\n  ];\n}\n\nfunction executeLog(\n  { logger }: AnyActorContext,\n  { value, label }: { value: unknown; label: string | undefined }\n) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n\nexport interface LogAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nexport function log<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  value: ResolvableLogValue<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  > = ({ context, event }) => ({ context, event }),\n  label?: string\n): LogAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function log(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n\n  return log;\n}\n","import isDevelopment from '#is-development';\nimport {\n  Actions,\n  ActionArgs,\n  UnknownAction,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  SingleOrArray,\n  NoInfer,\n  ProvidedActor\n} from '../types.ts';\nimport { toArray } from '../utils.ts';\n\nfunction resolvePure(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    get\n  }: {\n    get: ({\n      context,\n      event\n    }: {\n      context: MachineContext;\n      event: EventObject;\n    }) => SingleOrArray<UnknownAction> | undefined;\n  }\n) {\n  return [\n    state,\n    undefined,\n    toArray(get({ context: args.context, event: args.event }))\n  ];\n}\n\nexport interface PureAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TEvent?: TEvent;\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n}\n\nexport function pure<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TEvent extends EventObject = TExpressionEvent,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n>(\n  getActions: ({\n    context,\n    event\n  }: {\n    context: TContext;\n    event: TExpressionEvent;\n  }) =>\n    | Actions<\n        TContext,\n        TExpressionEvent,\n        NoInfer<TEvent>,\n        undefined,\n        TActor,\n        NoInfer<TAction>,\n        NoInfer<TGuard>,\n        TDelay\n      >\n    | undefined\n): PureAction<\n  TContext,\n  TExpressionEvent,\n  TExpressionAction,\n  TEvent,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay\n> {\n  function pure(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  pure.type = 'xstate.pure';\n  pure.get = getActions;\n\n  pure.resolve = resolvePure;\n\n  return pure;\n}\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyActor,\n  AnyState,\n  DelayExpr,\n  EventObject,\n  MachineContext,\n  NoInfer,\n  RaiseActionOptions,\n  SendExpr,\n  ParameterizedObject\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >\n      | undefined;\n  }\n) {\n  const delaysMap = state.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function' ? eventOrExpr(args) : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function' ? configDelay(args) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args) : delay;\n  }\n  return [\n    typeof resolvedDelay !== 'number'\n      ? cloneState(state, {\n          _internalQueue: state._internalQueue.concat(resolvedEvent)\n        })\n      : state,\n    { event: resolvedEvent, id, delay: resolvedDelay }\n  ];\n}\n\nfunction executeRaise(\n  actorContext: AnyActorContext,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  if (typeof params.delay === 'number') {\n    (actorContext.self as AnyActor).delaySend(\n      params as typeof params & { delay: number }\n    );\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject = TExpressionEvent,\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TDelay extends string = string\n>(\n  eventOrExpr:\n    | NoInfer<TEvent>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        NoInfer<TEvent>,\n        TEvent\n      >,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    NoInfer<TEvent>,\n    NoInfer<TDelay>\n  >\n): RaiseAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TDelay> {\n  function raise(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n","import type { StateNode } from './StateNode.ts';\nimport type { State } from './State.ts';\nimport type { ActorStatus, Clock, Actor } from './interpreter.ts';\nimport type { MachineSnapshot, StateMachine } from './StateMachine.ts';\nimport {\n  TypegenDisabled,\n  ResolveTypegenMeta,\n  TypegenConstraint,\n  MarkAllImplementationsAsProvided,\n  AreAllImplementationsAssumedToBeProvided\n} from './typegenTypes.ts';\nimport { PromiseActorLogic } from './actors/promise.ts';\nimport { Guard, GuardPredicate, UnknownGuard } from './guards.ts';\nimport { Spawner } from './spawn.ts';\nimport { AssignArgs } from './actions/assign.ts';\nimport { InspectionEvent } from './system.js';\n\nexport type HomomorphicPick<T, K extends keyof any> = {\n  [P in keyof T as P & K]: T[P];\n};\nexport type HomomorphicOmit<T, K extends keyof any> = {\n  [P in keyof T as Exclude<P, K>]: T[P];\n};\n\n/**\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.\n * It especially is a problem when the union has a function member, like here:\n *\n * ```ts\n * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;\n * test((arg) => {}) // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same value space as `unknown`.\n */\nexport type NonReducibleUnknown = {} | null | undefined;\nexport type AnyFunction = (...args: any[]) => any;\n\ntype ReturnTypeOrValue<T> = T extends AnyFunction ? ReturnType<T> : T;\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type Compute<A extends any> = { [K in keyof A]: A[K] } & unknown;\nexport type Prop<T, K> = K extends keyof T ? T[K] : never;\nexport type Values<T> = T[keyof T];\nexport type Merge<M, N> = Omit<M, keyof N> & N;\nexport type IndexByProp<T extends Record<P, string>, P extends keyof T> = {\n  [E in T as E[P]]: E;\n};\n\nexport type IndexByType<T extends { type: string }> = IndexByProp<T, 'type'>;\n\nexport type Equals<A1 extends any, A2 extends any> = (<A>() => A extends A2\n  ? true\n  : false) extends <A>() => A extends A1 ? true : false\n  ? true\n  : false;\nexport type IsAny<T> = Equals<T, any>;\nexport type Cast<A, B> = A extends B ? A : B;\nexport type NoInfer<T> = [T][T extends any ? 0 : any];\nexport type LowInfer<T> = T & {};\n\nexport type MetaObject = Record<string, any>;\n\nexport type Lazy<T> = () => T;\nexport type MaybeLazy<T> = T | Lazy<T>;\n\n/**\n * The full definition of an event, with a string `type`.\n */\nexport interface EventObject {\n  /**\n   * The type of event that is sent.\n   */\n  type: string;\n}\n\nexport interface AnyEventObject extends EventObject {\n  [key: string]: any;\n}\n\nexport interface ParameterizedObject {\n  type: string;\n  params?: Record<string, unknown>;\n}\n\nexport interface UnifiedArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    TEvent,\n    MachineSnapshot<TContext, TEvent, ProvidedActor, string, unknown>\n  >;\n  system: ActorSystem<any>;\n}\n\nexport type MachineContext = Record<string, any>;\n\nexport interface ActionArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> extends UnifiedArg<TContext, TExpressionEvent, TEvent> {\n  action: TExpressionAction;\n}\n\nexport type InputFrom<T extends AnyActorLogic> = T extends StateMachine<\n  infer _TContext,\n  infer _TEvent,\n  infer _TActor,\n  infer _TAction,\n  infer _TGuard,\n  infer _TDelay,\n  infer _TTag,\n  infer TInput,\n  infer _TOutput,\n  infer _TResolvedTypesMeta\n>\n  ? TInput\n  : T extends ActorLogic<\n      infer _TSnapshot,\n      infer _TEvent,\n      infer TInput,\n      infer _TPersisted,\n      infer _TSystem\n    >\n  ? TInput\n  : never;\n\nexport type OutputFrom<T extends AnyActorLogic> = T extends ActorLogic<\n  infer TSnapshot,\n  infer _TEvent,\n  infer _TInput,\n  infer _TPersisted,\n  infer _TSystem\n>\n  ? (TSnapshot & { status: 'done' })['output']\n  : never;\n\nexport type ActionFunction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = {\n  (\n    args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ): void;\n  _out_TEvent?: TEvent; // TODO: it feels like we should be able to remove this since now `TEvent` is \"observable\" by `self`\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n};\n\nexport interface ChooseBranch<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject = TExpressionEvent,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n> {\n  guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;\n  actions: Actions<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n}\n\nexport type NoRequiredParams<T extends ParameterizedObject> = T extends any\n  ? { type: T['type'] } extends T\n    ? T['type']\n    : never\n  : never;\n\ntype ConditionalRequired<T, Condition extends boolean> = Condition extends true\n  ? Required<T>\n  : T;\n\nexport type WithDynamicParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  T extends ParameterizedObject\n> = T extends any\n  ? ConditionalRequired<\n      {\n        type: T['type'];\n        params?:\n          | T['params']\n          | (({\n              context,\n              event\n            }: {\n              context: TContext;\n              event: TExpressionEvent;\n            }) => T['params']);\n      },\n      undefined extends T['params'] ? false : true\n    >\n  : never;\n\nexport type Action<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  // TODO: consider merging `NoRequiredParams` and `WithDynamicParams` into one\n  // this way we could iterate over `TAction` (and `TGuard` in the `Guard` type) once and not twice\n  | NoRequiredParams<TAction>\n  | WithDynamicParams<TContext, TExpressionEvent, TAction>\n  | ActionFunction<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TExpressionAction,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay\n    >;\n\nexport type UnknownAction = Action<\n  MachineContext,\n  EventObject,\n  EventObject,\n  ParameterizedObject | undefined,\n  ProvidedActor,\n  ParameterizedObject,\n  ParameterizedObject,\n  string\n>;\n\nexport type Actions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = SingleOrArray<\n  Action<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    TExpressionAction,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >\n>;\n\nexport type StateKey = string | AnyState;\n\nexport interface StateValueMap {\n  [key: string]: StateValue;\n}\n\n/**\n * The string or object representing the state value relative to the parent state node.\n *\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success: \"someChildState\" }`.\n */\nexport type StateValue = string | StateValueMap;\n\nexport type TransitionTarget = SingleOrArray<string>;\n\nexport interface TransitionConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;\n  actions?: Actions<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  reenter?: boolean;\n  target?: TransitionTarget | undefined;\n  meta?: Record<string, any>;\n  description?: string;\n}\n\nexport interface InitialTransitionConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> extends TransitionConfig<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  > {\n  target: TransitionTarget;\n}\n\nexport type AnyTransitionConfig = TransitionConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\nexport interface InvokeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  id: string;\n\n  systemId: string | undefined;\n  /**\n   * The source of the actor logic to be invoked\n   */\n  src: string;\n\n  input?:\n    | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n    | NonReducibleUnknown;\n  /**\n   * The transition to take upon the invoked child machine reaching its final top-level state.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneActorEvent<unknown>,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n  /**\n   * The transition to take upon the invoked child machine sending an error event.\n   */\n  onError?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          ErrorActorEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n\n  onSnapshot?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          SnapshotEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n\n  toJSON: () => Omit<\n    InvokeDefinition<TContext, TEvent, TActor, TAction, TGuard, TDelay>,\n    'onDone' | 'onError' | 'toJSON'\n  >;\n}\n\ntype Delay<TDelay extends string> = TDelay | number;\n\nexport type DelayedTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  | {\n      [K in Delay<TDelay>]?:\n        | string\n        | SingleOrArray<\n            TransitionConfig<\n              TContext,\n              TEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n    }\n  | Array<\n      TransitionConfig<\n        TContext,\n        TEvent,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay\n      > & {\n        delay:\n          | Delay<TDelay>\n          | ((args: UnifiedArg<TContext, TEvent, TEvent>) => Delay<TDelay>);\n      }\n    >;\n\nexport type StateTypes =\n  | 'atomic'\n  | 'compound'\n  | 'parallel'\n  | 'final'\n  | 'history'\n  | string; // TODO: remove once TS fixes this type-widening issue\n\nexport type SingleOrArray<T> = readonly T[] | T;\n\nexport type StateNodesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNode<TContext, TEvent>;\n};\n\nexport type StatesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TOutput\n> = {\n  [K in string]: StateNodeConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TOutput\n  >;\n};\n\nexport type StatesDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNodeDefinition<TContext, TEvent>;\n};\n\nexport type TransitionConfigTarget = string | undefined;\n\nexport type TransitionConfigOrTarget<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = SingleOrArray<\n  | TransitionConfigTarget\n  | TransitionConfig<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay\n    >\n>;\n\nexport type TransitionsConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  | {\n      [K in EventDescriptor<TEvent>]?: TransitionConfigOrTarget<\n        TContext,\n        ExtractEvent<TEvent, K>,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay\n      >;\n    };\n\ntype PartialEventDescriptor<TEventType extends string> =\n  TEventType extends `${infer TLeading}.${infer TTail}`\n    ? `${TLeading}.*` | `${TLeading}.${PartialEventDescriptor<TTail>}`\n    : never;\n\nexport type EventDescriptor<TEvent extends EventObject> =\n  | TEvent['type']\n  | PartialEventDescriptor<TEvent['type']>\n  | '*';\n\ntype NormalizeDescriptor<TDescriptor extends string> = TDescriptor extends '*'\n  ? string\n  : TDescriptor extends `${infer TLeading}.*`\n  ? `${TLeading}.${string}`\n  : TDescriptor;\n\nexport type IsLiteralString<T extends string> = string extends T ? false : true;\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TSpecificActor extends ProvidedActor\n> = TSpecificActor extends { src: infer TSrc }\n  ? Compute<\n      {\n        systemId?: string;\n        /**\n         * The source of the machine to be invoked, or the machine itself.\n         */\n        src: TSrc;\n\n        // TODO: currently we do not enforce required inputs here\n        // in a sense, we shouldn't - they could be provided within the `implementations` object\n        // how do we verify if the required input has been provided?\n        input?:\n          | Mapper<TContext, TEvent, InputFrom<TSpecificActor['logic']>, TEvent>\n          | InputFrom<TSpecificActor['logic']>;\n        /**\n         * The transition to take upon the invoked child machine reaching its final top-level state.\n         */\n        onDone?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                DoneActorEvent<OutputFrom<TSpecificActor['logic']>>,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n        /**\n         * The transition to take upon the invoked child machine sending an error event.\n         */\n        onError?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                ErrorActorEvent,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n\n        onSnapshot?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                SnapshotEvent<SnapshotFrom<TSpecificActor['logic']>>,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n      } & (TSpecificActor['id'] extends string\n        ? {\n            /**\n             * The unique identifier for the invoked machine. If not specified, this\n             * will be the machine's own `id`, or the URL (from `src`).\n             */\n            id: TSpecificActor['id'];\n          }\n        : {\n            /**\n             * The unique identifier for the invoked machine. If not specified, this\n             * will be the machine's own `id`, or the URL (from `src`).\n             */\n            id?: string;\n          })\n    >\n  : never;\n\nexport type InvokeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = IsLiteralString<TActor['src']> extends true\n  ? DistributeActors<TContext, TEvent, TActor, TAction, TGuard, TDelay, TActor>\n  : {\n      /**\n       * The unique identifier for the invoked machine. If not specified, this\n       * will be the machine's own `id`, or the URL (from `src`).\n       */\n      id?: string;\n\n      systemId?: string;\n      /**\n       * The source of the machine to be invoked, or the machine itself.\n       */\n      src: AnyActorLogic | string; // TODO: fix types\n\n      input?:\n        | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n        | NonReducibleUnknown;\n      /**\n       * The transition to take upon the invoked child machine reaching its final top-level state.\n       */\n      onDone?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              DoneActorEvent<any>, // TODO: consider replacing with `unknown`\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n      /**\n       * The transition to take upon the invoked child machine sending an error event.\n       */\n      onError?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              ErrorActorEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n\n      onSnapshot?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              SnapshotEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n    };\n\nexport type AnyInvokeConfig = InvokeConfig<any, any, any, any, any, any>;\n\nexport interface StateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TOutput\n> {\n  /**\n   * The initial state transition.\n   */\n  initial?:\n    | InitialTransitionConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>\n    | SingleOrArray<string>\n    | undefined;\n  /**\n   * The type of this state node:\n   *\n   *  - `'atomic'` - no child state nodes\n   *  - `'compound'` - nested child state nodes (XOR)\n   *  - `'parallel'` - orthogonal nested child state nodes (AND)\n   *  - `'history'` - history state node\n   *  - `'final'` - final state node\n   */\n  type?: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /**\n   * Indicates whether the state node is a history state node, and what\n   * type of history:\n   * shallow, deep, true (shallow), false (none), undefined (none)\n   */\n  history?: 'shallow' | 'deep' | boolean | undefined;\n  /**\n   * The mapping of state node keys to their state node configurations (recursive).\n   */\n  states?:\n    | StatesConfig<\n        TContext,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        NonReducibleUnknown\n      >\n    | undefined;\n  /**\n   * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.\n   */\n  invoke?: SingleOrArray<\n    InvokeConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>\n  >;\n  /**\n   * The mapping of event types to their potential transition(s).\n   */\n  on?: TransitionsConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>;\n  /**\n   * The action(s) to be executed upon entering the state node.\n   */\n  entry?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * The action(s) to be executed upon exiting the state node.\n   */\n  exit?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * The potential transition(s) to be taken upon reaching a final child state node.\n   *\n   * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneStateEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >\n    | undefined;\n  /**\n   * The mapping (or array) of delays (in milliseconds) to their potential transition(s).\n   * The delayed transitions are taken after the specified delay in an interpreter.\n   */\n  after?: DelayedTransitions<TContext, TEvent, TActor, TAction, TGuard, TDelay>;\n\n  /**\n   * An eventless transition that is always taken when this state node is active.\n   */\n  always?: TransitionConfigOrTarget<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * @private\n   */\n  parent?: StateNode<TContext, TEvent>;\n  /**\n   * The meta data associated with this state node, which will be returned in State instances.\n   */\n  meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n   *\n   * The output data will be evaluated with the current `context` and placed on the `.data` property\n   * of the event.\n   */\n  output?: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n  /**\n   * The unique ID of the state node, which can be referenced as a transition target via the\n   * `#id` syntax.\n   */\n  id?: string | undefined;\n  /**\n   * The order this state node appears. Corresponds to the implicit document order.\n   */\n  order?: number;\n\n  /**\n   * The tags for this state node, which are accumulated into the `state.tags` property.\n   */\n  tags?: SingleOrArray<TTag>;\n  /**\n   * A text description of the state node\n   */\n  description?: string;\n\n  /**\n   * A default target for a history state\n   */\n  target?: string;\n}\n\nexport type AnyStateNodeConfig = StateNodeConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\nexport interface StateNodeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  id: string;\n  version?: string | undefined;\n  key: string;\n  type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  initial: InitialTransitionDefinition<TContext, TEvent> | undefined;\n  history: boolean | 'shallow' | 'deep' | undefined;\n  states: StatesDefinition<TContext, TEvent>;\n  on: TransitionDefinitionMap<TContext, TEvent>;\n  transitions: Array<TransitionDefinition<TContext, TEvent>>;\n  // TODO: establish what a definition really is\n  entry: UnknownAction[];\n  exit: UnknownAction[];\n  meta: any;\n  order: number;\n  output?: StateNodeConfig<\n    TContext,\n    TEvent,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    string,\n    unknown\n  >['output'];\n  invoke: Array<InvokeDefinition<TContext, TEvent, TODO, TODO, TODO, TODO>>;\n  description?: string;\n  tags: string[];\n}\n\nexport interface StateMachineDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeDefinition<TContext, TEvent> {}\n\nexport type AnyStateNode = StateNode<any, any>;\n\nexport type AnyStateNodeDefinition = StateNodeDefinition<any, any>;\n\nexport type AnyState = State<\n  any, // context\n  any, // event\n  any, // actor\n  any, // tags\n  any // typegen\n>;\n\nexport type AnyStateMachine = StateMachine<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any, // delays\n  any // tags\n>;\n\nexport type AnyStateConfig = StateConfig<any, AnyEventObject>;\n\nexport interface AtomicStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeConfig<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO\n  > {\n  initial?: undefined;\n  parallel?: false | undefined;\n  states?: undefined;\n  onDone?: undefined;\n}\n\nexport interface HistoryStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends AtomicStateNodeConfig<TContext, TEvent> {\n  history: 'shallow' | 'deep' | true;\n  target: string | undefined;\n}\n\nexport type SimpleOrStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> =\n  | AtomicStateNodeConfig<TContext, TEvent>\n  | StateNodeConfig<TContext, TEvent, TODO, TODO, TODO, TODO, TODO, TODO>;\n\nexport type ActionFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n> = {\n  [K in TAction['type']]?: ActionFunction<\n    TContext,\n    TEvent,\n    TEvent,\n    TAction extends { type: K } ? TAction : never,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n};\n\ntype GuardMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TGuard extends ParameterizedObject\n> = {\n  [K in TGuard['type']]?: GuardPredicate<\n    TContext,\n    TEvent,\n    TGuard extends { type: K } ? TGuard : never,\n    TGuard\n  >;\n};\n\nexport type DelayFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TAction extends ParameterizedObject\n> = Record<string, DelayConfig<TContext, TEvent, TAction, TEvent>>;\n\nexport type DelayConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = number | DelayExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\nexport interface MachineImplementationsSimplified<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject\n> {\n  guards: GuardMap<TContext, TEvent, TGuard>;\n  actions: ActionFunctionMap<TContext, TEvent, TActor, TAction>;\n  actors: Record<\n    string,\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n      }\n  >;\n  delays: DelayFunctionMap<TContext, TEvent, TAction>;\n}\n\ntype MaybeNarrowedEvent<TIndexedEvents, TCausingLookup, K> = Cast<\n  Prop<\n    TIndexedEvents,\n    K extends keyof TCausingLookup\n      ? TCausingLookup[K]\n      : TIndexedEvents[keyof TIndexedEvents]\n  >,\n  EventObject\n>;\n\ntype MachineImplementationsActions<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingActions'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedActors = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedActors'>,\n  TIndexedActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'indexedActions'\n  >,\n  TIndexedGuards = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedGuards'>,\n  TIndexedDelays = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedDelays'>\n> = {\n  [K in keyof TIndexedActions]?: ActionFunction<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingActions, K>,\n    Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>,\n    Cast<TIndexedActions[K], ParameterizedObject>,\n    Cast<Prop<TIndexedActors, keyof TIndexedActors>, ProvidedActor>,\n    Cast<Prop<TIndexedActions, keyof TIndexedActions>, ParameterizedObject>,\n    Cast<Prop<TIndexedGuards, keyof TIndexedGuards>, ParameterizedObject>,\n    Cast<\n      Prop<TIndexedDelays, keyof TIndexedDelays>,\n      ParameterizedObject\n    >['type']\n  >;\n};\n\ntype MachineImplementationsActors<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingActors = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingActors'\n  >,\n  TIndexedActors = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedActors'>,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  _TInvokeSrcNameMap = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'invokeSrcNameMap'\n  >\n> = {\n  // TODO: this should require `{ src, input }` for required inputs\n  [K in keyof TIndexedActors]?:\n    | Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>\n    | {\n        src: Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>;\n        input:\n          | Mapper<\n              TContext,\n              MaybeNarrowedEvent<TIndexedEvents, TEventsCausingActors, K>,\n              InputFrom<Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>>,\n              Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>\n            >\n          | InputFrom<Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>>;\n      };\n};\n\ntype MachineImplementationsDelays<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingDelays = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingDelays'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'indexedActions'\n  >,\n  TIndexedDelays = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedDelays'>\n> = {\n  [K in keyof TIndexedDelays]?: DelayConfig<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingDelays, K>,\n    // delays in referenced send actions might use specific `TAction`\n    // delays executed by auto-generated send actions related to after transitions won't have that\n    // since they are effectively implicit inline actions\n    | Cast<Prop<TIndexedActions, keyof TIndexedActions>, ParameterizedObject>\n    | undefined,\n    Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>\n  >;\n};\n\ntype MachineImplementationsGuards<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingGuards = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingGuards'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedGuards = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedGuards'>\n> = {\n  [K in keyof TIndexedGuards]?: Guard<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingGuards, K>,\n    Cast<TIndexedGuards[K], ParameterizedObject>,\n    Cast<Prop<TIndexedGuards, keyof TIndexedGuards>, ParameterizedObject>\n  >;\n};\n\ntype MakeKeysRequired<T extends string> = { [K in T]: unknown };\n\ntype MaybeMakeMissingImplementationsRequired<\n  TImplementationType,\n  TMissingImplementationsForType,\n  TRequireMissingImplementations\n> = TRequireMissingImplementations extends true\n  ? IsNever<TMissingImplementationsForType> extends true\n    ? {}\n    : {\n        [K in Cast<TImplementationType, string>]: MakeKeysRequired<\n          Cast<TMissingImplementationsForType, string>\n        >;\n      }\n  : {};\n\ntype GenerateActionsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'actions',\n    Prop<TMissingImplementations, 'actions'>,\n    TRequireMissingImplementations\n  > & {\n    actions?: MachineImplementationsActions<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateActorsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'actors',\n    Prop<TMissingImplementations, 'actors'>,\n    TRequireMissingImplementations\n  > & {\n    actors?: MachineImplementationsActors<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateDelaysImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'delays',\n    Prop<TMissingImplementations, 'delays'>,\n    TRequireMissingImplementations\n  > & {\n    delays?: MachineImplementationsDelays<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateGuardsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'guards',\n    Prop<TMissingImplementations, 'guards'>,\n    TRequireMissingImplementations\n  > & {\n    guards?: MachineImplementationsGuards<TContext, TResolvedTypesMeta>;\n  }\n>;\n\nexport type InternalMachineImplementations<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TDelay extends string,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations extends boolean = false,\n  TMissingImplementations = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'missingImplementations'\n  >\n> =\n  // TODO: remove per-Generate* Computes\n  Compute<\n    GenerateActionsImplementationsPart<\n      TContext,\n      TResolvedTypesMeta,\n      TRequireMissingImplementations,\n      TMissingImplementations\n    > &\n      GenerateActorsImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      > &\n      GenerateDelaysImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      > &\n      GenerateGuardsImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      >\n  >;\n\nexport type MachineImplementations<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TTag extends string = string,\n  TTypesMeta extends TypegenConstraint = TypegenDisabled\n> = InternalMachineImplementations<\n  TContext,\n  TEvent,\n  TActor,\n  TAction,\n  TDelay,\n  ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag>\n>;\n\ntype InitialContext<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput\n> = TContext | ContextFactory<TContext, TActor, TInput>;\n\nexport type ContextFactory<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput\n> = ({ spawn, input }: { spawn: Spawner<TActor>; input: TInput }) => TContext;\n\nexport type MachineConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TTag extends string = string,\n  TInput = any,\n  TOutput = unknown,\n  TTypesMeta = TypegenDisabled\n> = (Omit<\n  StateNodeConfig<\n    NoInfer<TContext>,\n    NoInfer<TEvent>,\n    NoInfer<TActor>,\n    NoInfer<TAction>,\n    NoInfer<TGuard>,\n    NoInfer<TDelay>,\n    NoInfer<TTag>,\n    NoInfer<TOutput>\n  >,\n  'output'\n> & {\n  /**\n   * The initial context (extended state)\n   */\n  /**\n   * The machine's own version.\n   */\n  version?: string;\n  types?: MachineTypes<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    TTypesMeta\n  >;\n  // TODO: make it conditionally required\n  output?: Mapper<TContext, DoneStateEvent, TOutput, TEvent> | TOutput;\n}) &\n  (MachineContext extends TContext\n    ? { context?: InitialContext<LowInfer<TContext>, TActor, TInput> }\n    : { context: InitialContext<LowInfer<TContext>, TActor, TInput> });\n\nexport interface ProvidedActor {\n  src: string;\n  logic: AnyActorLogic;\n  id?: string;\n}\n\nexport interface MachineTypes<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TTypesMeta = TypegenDisabled\n> {\n  context?: TContext;\n  events?: TEvent;\n  actors?: TActor;\n  actions?: TAction;\n  guards?: TGuard;\n  delays?: TDelay;\n  tags?: TTag;\n  input?: TInput;\n  output?: TOutput;\n  typegen?: TTypesMeta;\n}\n\nexport interface HistoryStateNode<TContext extends MachineContext>\n  extends StateNode<TContext> {\n  history: 'shallow' | 'deep';\n  target: string | undefined;\n}\n\nexport type HistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Record<string, Array<StateNode<TContext, TEvent>>>;\n\nexport type AnyHistoryValue = HistoryValue<any, any>;\n\nexport type StateFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> = T extends AnyStateMachine\n  ? ReturnType<T['transition']>\n  : T extends (...args: any[]) => AnyStateMachine\n  ? ReturnType<ReturnType<T>['transition']>\n  : never;\n\nexport type Transitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Array<TransitionDefinition<TContext, TEvent>>;\n\nexport interface DoneActorEvent<TOutput = unknown> {\n  type: `xstate.done.actor.${string}`;\n  output: TOutput;\n}\n\nexport interface ErrorActorEvent<TErrorData = unknown> extends EventObject {\n  type: `xstate.error.actor.${string}`;\n  data: TErrorData;\n}\n\nexport interface SnapshotEvent<\n  TSnapshot extends Snapshot<unknown> = Snapshot<unknown>\n> extends EventObject {\n  type: `xstate.snapshot.${string}`;\n  snapshot: TSnapshot;\n}\n\nexport interface DoneStateEvent<TOutput = unknown> extends EventObject {\n  type: `xstate.done.state.${string}`;\n  output: TOutput;\n}\n\nexport type DelayExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => number;\n\nexport type LogExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => unknown;\n\nexport type SendExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => TSentEvent;\n\nexport enum SpecialTargets {\n  Parent = '#_parent',\n  Internal = '#_internal'\n}\n\nexport interface SendToActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {}\n\nexport interface RaiseActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  id?: string;\n  delay?:\n    | Delay<TDelay>\n    | DelayExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n}\n\nexport interface RaiseActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {\n  event:\n    | TEvent\n    | SendExpr<TContext, TExpressionEvent, TExpressionAction, TEvent, TEvent>;\n}\n\nexport interface SendToActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {\n  event:\n    | TSentEvent\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TSentEvent,\n        TEvent\n      >;\n}\n\nexport type Assigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = (\n  args: AssignArgs<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TActor\n  >\n) => Partial<TContext>;\n\nexport type PartialAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TKey extends keyof TContext\n> = (\n  args: AssignArgs<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TActor\n  >\n) => TContext[TKey];\n\nexport type PropertyAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = {\n  [K in keyof TContext]?:\n    | PartialAssigner<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor,\n        K\n      >\n    | TContext[K];\n};\n\nexport type Mapper<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TResult,\n  TEvent extends EventObject\n> = (args: {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    TEvent,\n    MachineSnapshot<TContext, TEvent, ProvidedActor, string, unknown>\n  >;\n}) => TResult;\n\nexport interface TransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends Omit<\n    TransitionConfig<TContext, TEvent, TEvent, TODO, TODO, TODO, TODO>,\n    | 'target'\n    // `guard` is correctly rejected by `extends` here and `actions` should be too\n    // however, `any` passed to `TransitionConfig` as `TAction` collapses its `.actions` to `any` and it's accidentally allowed here\n    // it doesn't exactly have to be incorrect, we are overriding this here anyway but it looks like a lucky accident rather than smth done on purpose\n    | 'guard'\n  > {\n  target: ReadonlyArray<StateNode<TContext, TEvent>> | undefined;\n  source: StateNode<TContext, TEvent>;\n  actions: readonly UnknownAction[];\n  reenter: boolean;\n  guard?: UnknownGuard;\n  eventType: EventDescriptor<TEvent>;\n  toJSON: () => {\n    target: string[] | undefined;\n    source: string;\n    actions: readonly UnknownAction[];\n    guard?: UnknownGuard;\n    eventType: EventDescriptor<TEvent>;\n    meta?: Record<string, any>;\n  };\n}\n\nexport type AnyTransitionDefinition = TransitionDefinition<any, any>;\n\nexport interface InitialTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  target: ReadonlyArray<StateNode<TContext, TEvent>>;\n  guard?: never;\n}\n\nexport type TransitionDefinitionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in EventDescriptor<TEvent>]: Array<\n    TransitionDefinition<TContext, ExtractEvent<TEvent, K>>\n  >;\n};\n\nexport interface DelayedTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  delay: number | string | DelayExpr<TContext, TEvent, undefined, TEvent>;\n}\n\nexport interface StateLike<TContext extends MachineContext> {\n  value: StateValue;\n  context: TContext;\n  event: EventObject;\n}\n\nexport interface StateConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  value: StateValue;\n  context: TContext;\n  historyValue?: HistoryValue<TContext, TEvent>;\n  meta?: any;\n  configuration?: Array<StateNode<TContext, TEvent>>;\n  children: Record<string, ActorRef<any, any>>;\n  status: 'active' | 'done' | 'error' | 'stopped';\n  output?: any;\n  error?: unknown;\n  tags?: Set<string>;\n  machine?: StateMachine<TContext, TEvent, any, any, any, any, any, any, any>;\n  _internalQueue?: Array<TEvent>;\n}\n\nexport interface ActorOptions<TLogic extends AnyActorLogic> {\n  /**\n   * Whether state actions should be executed immediately upon transition. Defaults to `true`.\n   */\n  execute?: boolean;\n  clock?: Clock;\n  logger?: (...args: any[]) => void;\n  parent?: ActorRef<any, any>;\n  /**\n   * The custom `id` for referencing this service.\n   */\n  id?: string;\n  /**\n   * If `true`, states and events will be logged to Redux DevTools.\n   *\n   * Default: `false`\n   */\n  devTools?: boolean | DevToolsAdapter; // TODO: add enhancer options\n\n  sync?: boolean;\n\n  /**\n   * The system ID to register this actor under\n   */\n  systemId?: string;\n  /**\n   * The input data to pass to the actor.\n   */\n  input?: InputFrom<TLogic>;\n\n  // state?:\n  //   | PersistedStateFrom<TActorLogic>\n  //   | InternalStateFrom<TActorLogic>;\n  state?: any;\n\n  /**\n   * The source definition.\n   */\n  src?: string;\n\n  inspect?:\n    | Observer<InspectionEvent>\n    | ((inspectionEvent: InspectionEvent) => void);\n}\n\nexport type AnyActor = Actor<any>;\n\n/**\n * @deprecated Use `AnyActor` instead.\n */\nexport type AnyInterpreter = AnyActor;\n\n// Based on RxJS types\nexport type Observer<T> = {\n  next?: (value: T) => void;\n  error?: (err: unknown) => void;\n  complete?: () => void;\n};\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface InteropObservable<T> {\n  [Symbol.observable]: () => InteropSubscribable<T>;\n}\n\nexport interface InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n}\n\nexport interface Subscribable<T> extends InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n  subscribe(\n    next: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription;\n}\n\nexport type ExtractEvent<\n  TEvent extends EventObject,\n  TDescriptor extends EventDescriptor<TEvent>\n> = string extends TEvent['type']\n  ? TEvent\n  : NormalizeDescriptor<TDescriptor> extends infer TNormalizedDescriptor\n  ? TEvent extends any\n    ? TEvent['type'] extends TNormalizedDescriptor\n      ? TEvent\n      : never\n    : never\n  : never;\n\nexport interface BaseActorRef<TEvent extends EventObject> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorLike<TCurrent, TEvent extends EventObject>\n  extends Subscribable<TCurrent> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorRef<\n  TEvent extends EventObject,\n  TSnapshot extends Snapshot<unknown>\n> extends Subscribable<TSnapshot>,\n    InteropObservable<TSnapshot> {\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  id: string;\n  sessionId: string;\n  /** @internal */\n  _send: (event: TEvent) => void;\n  send: (event: TEvent) => void;\n  // TODO: should this be optional?\n  start?: () => void;\n  getSnapshot: () => TSnapshot;\n  // TODO: this should return some sort of TPersistedState, not any\n  getPersistedState?: () => any;\n  stop: () => void;\n  toJSON?: () => any;\n  // TODO: figure out how to hide this externally as `sendTo(ctx => ctx.actorRef._parent._parent._parent._parent)` shouldn't be allowed\n  _parent?: ActorRef<any, any>;\n  system?: ActorSystem<any>;\n  status: ActorStatus;\n  src?: string;\n}\n\nexport type AnyActorRef = ActorRef<any, any>;\n\nexport type ActorLogicFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<any, any, any, any, any, any, any, any, any>\n    ? R\n    : R extends Promise<infer U>\n    ? PromiseActorLogic<U>\n    : never\n  : never;\n\nexport type ActorRefFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer TContext,\n      infer TEvent,\n      infer TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer TTag,\n      infer _TInput,\n      infer TOutput,\n      infer TResolvedTypesMeta\n    >\n    ? ActorRef<\n        TEvent,\n        MachineSnapshot<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          AreAllImplementationsAssumedToBeProvided<TResolvedTypesMeta> extends false\n            ? MarkAllImplementationsAsProvided<TResolvedTypesMeta>\n            : TResolvedTypesMeta\n        >\n      >\n    : R extends Promise<infer U>\n    ? ActorRefFrom<PromiseActorLogic<U>>\n    : R extends ActorLogic<\n        infer TSnapshot,\n        infer TEvent,\n        infer _TInput,\n        infer _TPersisted,\n        infer _TSystem\n      >\n    ? ActorRef<TEvent, TSnapshot>\n    : never\n  : never;\n\nexport type DevToolsAdapter = (service: AnyActor) => void;\n\n/**\n * @deprecated Use `Actor<T>` instead.\n */\nexport type InterpreterFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> = ReturnTypeOrValue<T> extends StateMachine<\n  infer TContext,\n  infer TEvent,\n  infer TActor,\n  infer _TAction,\n  infer _TGuard,\n  infer _TDelay,\n  infer TTag,\n  infer TInput,\n  infer TOutput,\n  infer TResolvedTypesMeta\n>\n  ? Actor<\n      ActorLogic<\n        MachineSnapshot<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          TResolvedTypesMeta\n        >,\n        TEvent,\n        TInput,\n        PersistedMachineState<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          TResolvedTypesMeta\n        >,\n        ActorSystem<any>\n      >\n    >\n  : never;\n\nexport type MachineImplementationsFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine),\n  TRequireMissingImplementations extends boolean = false\n> = ReturnTypeOrValue<T> extends StateMachine<\n  infer TContext,\n  infer TEvent,\n  infer TActor,\n  infer TAction,\n  infer _TGuard,\n  infer TDelay,\n  infer _TTag,\n  infer _TInput,\n  infer _TOutput,\n  infer TResolvedTypesMeta\n>\n  ? InternalMachineImplementations<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TDelay,\n      TResolvedTypesMeta,\n      TRequireMissingImplementations\n    >\n  : never;\n\n// only meant to be used internally for debugging purposes\nexport type __ResolvedTypesMetaFrom<T> = T extends StateMachine<\n  any, // context\n  any, // event\n  any, // actor\n  any, // action\n  any, // guard\n  any, // delay\n  any, // tag\n  any, // input\n  any, // output\n  infer TResolvedTypesMeta\n>\n  ? TResolvedTypesMeta\n  : never;\n\nexport interface ActorContext<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n> {\n  self: ActorRef<TEvent, TSnapshot>;\n  id: string;\n  sessionId: string;\n  logger: (...args: any[]) => void;\n  defer: (fn: () => void) => void;\n  system: TSystem;\n  stopChild: (child: AnyActorRef) => void;\n}\n\nexport type AnyActorContext = ActorContext<any, any, AnyActorSystem>;\n\nexport type Snapshot<TOutput> =\n  | {\n      status: 'active';\n      output: undefined;\n      error: undefined;\n    }\n  | {\n      status: 'done';\n      output: TOutput;\n      error: undefined;\n    }\n  | {\n      status: 'error';\n      output: undefined;\n      error: unknown;\n    }\n  | {\n      status: 'stopped';\n      output: undefined;\n      error: undefined;\n    };\n\nexport interface ActorLogic<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput = unknown,\n  /**\n   * Serialized internal state used for persistence & restoration\n   */\n  TPersisted = TSnapshot,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n> {\n  config?: unknown;\n  transition: (\n    state: TSnapshot,\n    message: TEvent,\n    ctx: ActorContext<TSnapshot, TEvent, TSystem>\n  ) => TSnapshot;\n  getInitialState: (\n    actorCtx: ActorContext<TSnapshot, TEvent, TSystem>,\n    input: TInput\n  ) => TSnapshot;\n  restoreState?: (\n    persistedState: TPersisted,\n    actorCtx: ActorContext<TSnapshot, TEvent>\n  ) => TSnapshot;\n  start?: (state: TSnapshot, actorCtx: ActorContext<TSnapshot, TEvent>) => void;\n  /**\n   * @returns Persisted state\n   */\n  getPersistedState?: (state: TSnapshot) => TPersisted;\n}\n\nexport type AnyActorLogic = ActorLogic<\n  any, // snapshot\n  any, // event\n  any, // input\n  any, // persisted state\n  any // system\n>;\n\nexport type SnapshotFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends ActorRef<infer _, infer TSnapshot>\n    ? TSnapshot\n    : R extends Actor<infer TLogic>\n    ? SnapshotFrom<TLogic>\n    : R extends StateMachine<\n        infer _TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? StateFrom<R>\n    : R extends ActorLogic<any, any, any, any, any>\n    ? ReturnType<R['transition']>\n    : R extends ActorContext<infer TSnapshot, infer _, infer __>\n    ? TSnapshot\n    : never\n  : never;\n\nexport type EventFromLogic<TLogic extends ActorLogic<any, any, any, any, any>> =\n  TLogic extends ActorLogic<\n    infer _,\n    infer TEvent,\n    infer __,\n    infer _____,\n    infer ______\n  >\n    ? TEvent\n    : never;\n\nexport type PersistedStateFrom<\n  TLogic extends ActorLogic<any, any, any, any, any>\n> = TLogic extends ActorLogic<\n  infer _TSnapshot,\n  infer _TEvent,\n  infer _TInput,\n  infer TPersisted,\n  infer _TSystem\n>\n  ? TPersisted\n  : never;\n\ntype ResolveEventType<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer _TContext,\n      infer TEvent,\n      infer _TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer _TTag,\n      infer _TInput,\n      infer _TOutput,\n      infer _TResolvedTypesMeta\n    >\n    ? TEvent\n    : R extends State<\n        infer _TContext,\n        infer TEvent,\n        infer _TActor,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? TEvent\n    : R extends ActorRef<infer TEvent, infer _>\n    ? TEvent\n    : never\n  : never;\n\nexport type EventFrom<\n  T,\n  K extends Prop<TEvent, 'type'> = never,\n  TEvent extends EventObject = ResolveEventType<T>\n> = IsNever<K> extends true ? TEvent : ExtractEvent<TEvent, K>;\n\nexport type ContextFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer TContext,\n      infer _TEvent,\n      infer _TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer _TTag,\n      infer _TInput,\n      infer _TOutput,\n      infer _TTypesMeta\n    >\n    ? TContext\n    : R extends State<\n        infer TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? TContext\n    : R extends Actor<infer TActorLogic>\n    ? TActorLogic extends StateMachine<\n        infer TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TTypesMeta\n      >\n      ? TContext\n      : never\n    : never\n  : never;\n\nexport type InferEvent<E extends EventObject> = {\n  [T in E['type']]: { type: T } & Extract<E, { type: T }>;\n}[E['type']];\n\nexport type TODO = any;\n\nexport type StateValueFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['matches']\n>[0];\n\nexport type TagsFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['hasTag']\n>[0];\n\nexport interface ActorSystemInfo {\n  actors: Record<string, AnyActorRef>;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /**\n   * @internal\n   */\n  _bookId: () => string;\n  /**\n   * @internal\n   */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /**\n   * @internal\n   */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /**\n   * @internal\n   */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  inspect: (observer: Observer<InspectionEvent>) => void;\n  /**\n   * @internal\n   */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /**\n   * @internal\n   */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nexport type PersistedMachineState<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TOutput,\n  TResolvedTypesMeta = TypegenDisabled\n> = HomomorphicPick<\n  MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>,\n  'value' | 'output' | 'error' | 'context' | 'status' | 'historyValue'\n> & {\n  children: {\n    [K in keyof MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >['children']]: {\n      state: any; // TODO: fix (should be state from actorref)\n      src?: string;\n    };\n  };\n};\n","import isDevelopment from '#is-development';\nimport { createErrorActorEvent } from '../eventUtils.ts';\nimport {\n  ActionArgs,\n  ActorRef,\n  AnyActorContext,\n  AnyActorRef,\n  AnyEventObject,\n  AnyActor,\n  AnyState,\n  Cast,\n  DelayExpr,\n  EventFrom,\n  EventObject,\n  InferEvent,\n  MachineContext,\n  SendExpr,\n  SendToActionOptions,\n  SendToActionParams,\n  SpecialTargets,\n  UnifiedArg,\n  ParameterizedObject,\n  NoInfer\n} from '../types.ts';\nimport { XSTATE_ERROR } from '../constants.ts';\n\nfunction resolveSendTo(\n  actorContext: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    to,\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    to:\n      | AnyActorRef\n      | string\n      | ((\n          args: UnifiedArg<MachineContext, EventObject, EventObject>\n        ) => AnyActorRef | string);\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >\n      | undefined;\n  }\n) {\n  const delaysMap = state.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function' ? eventOrExpr(args) : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function' ? configDelay(args) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args) : delay;\n  }\n\n  const resolvedTarget = typeof to === 'function' ? to(args) : to;\n  let targetActorRef: AnyActorRef | undefined;\n\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorContext?.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorContext?.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = state.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = state.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(\n        `Unable to send event to actor '${resolvedTarget}' from machine '${state.machine.id}'.`\n      );\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorContext?.self;\n  }\n\n  return [\n    state,\n    { to: targetActorRef, event: resolvedEvent, id, delay: resolvedDelay }\n  ];\n}\nfunction executeSendTo(\n  actorContext: AnyActorContext,\n  params: {\n    to: AnyActorRef;\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  if (typeof params.delay === 'number') {\n    (actorContext.self as AnyActor).delaySend(\n      params as typeof params & { delay: number }\n    );\n    return;\n  }\n\n  const { to, event } = params;\n\n  actorContext.defer(() => {\n    actorContext?.system._relay(\n      actorContext.self,\n      to,\n      event.type === XSTATE_ERROR\n        ? createErrorActorEvent(actorContext.self.id, (event as any).data)\n        : event\n    );\n  });\n}\n\nexport interface SendToAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event to send\n * @param options Send action options\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n */\nexport function sendTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TTargetActor extends AnyActorRef,\n  TEvent extends EventObject,\n  TDelay extends string\n>(\n  to:\n    | TTargetActor\n    | string\n    | ((\n        args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n      ) => TTargetActor | string),\n  eventOrExpr:\n    | EventFrom<TTargetActor>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        InferEvent<Cast<EventFrom<TTargetActor>, EventObject>>,\n        TEvent\n      >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    NoInfer<TEvent>,\n    NoInfer<TDelay>\n  >\n): SendToAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TDelay> {\n  function sendTo(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  sendTo.type = 'xstate.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n\n  sendTo.resolve = resolveSendTo;\n  sendTo.execute = executeSendTo;\n\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nexport function sendParent<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject = AnyEventObject,\n  TEvent extends EventObject = AnyEventObject,\n  TDelay extends string = string\n>(\n  event:\n    | TSentEvent\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TSentEvent,\n        TEvent\n      >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  >\n) {\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    AnyActorRef,\n    TEvent,\n    TDelay\n  >(SpecialTargets.Parent, event, options as any);\n}\n\ntype Target<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ActorRef<any, any>\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => string | ActorRef<any, any>);\n\n/**\n * Forwards (sends) an event to a specified service.\n *\n * @param target The target service to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nexport function forwardTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n>(\n  target: Target<TContext, TExpressionEvent, TExpressionAction, TEvent>,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  >\n) {\n  if (isDevelopment && (!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget =\n        typeof originalTarget === 'function'\n          ? originalTarget(...args)\n          : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(\n          `Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`\n        );\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    AnyActorRef,\n    TEvent,\n    TDelay\n  >(target, ({ event }: any) => event, options);\n}\n\n/**\n * Escalates an error by sending it as an event to this machine's parent.\n *\n * @param errorData The error data to send, or the expression function that\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\n * @param options Options to pass into the send action creator.\n */\nexport function escalate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TErrorData = any,\n  TEvent extends EventObject = AnyEventObject\n>(\n  errorData:\n    | TErrorData\n    | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TErrorData),\n  options?: SendToActionParams<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    EventObject,\n    TEvent,\n    string\n  >\n) {\n  return sendParent<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    EventObject,\n    TEvent\n  >((arg) => {\n    return {\n      type: XSTATE_ERROR,\n      data:\n        typeof errorData === 'function' ? (errorData as any)(arg) : errorData\n    };\n  }, options);\n}\n"],"names":["STATE_DELIMITER","XSTATE_ERROR","XSTATE_STOP","cache","WeakMap","createErrorActorEvent","id","data","type","resolveCancel","_","state","actionArgs","sendId","executeCancel","actorContext","resolvedSendId","self","cancel","Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","prepend","event","value","enqueue","enqueued","consumed","getDevTools","w","globalThis","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","idCounter","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","key","stateValue","isArray","pathToStateValue","stateId","toString","split","e","Error","toStatePath","statePath","length","marker","i","previous","flatten","array","concat","toArray","undefined","toArrayStrict","Array","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","error","complete","ActorStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_state","mailbox","delayedEventsMap","observers","Set","status","NotStarted","_parent","ref","_actorContext","_systemId","sessionId","system","_doneEvent","src","_deferred","resolvedOptions","parent","systemId","inspect","rootActor","children","Map","keyedActors","reverseKeyedActors","_bookId","_register","actorRef","set","_unregister","delete","get","_set","existing","observer","add","_sendInspectionEvent","resolvedInspectionEvent","rootId","forEach","_relay","source","target","sourceRef","targetRef","_send","createSystem","defer","push","stopChild","child","_stop","send","_initState","restoreState","getInitialState","input","update","snapshot","deferredFn","shift","_stopProcedure","_complete","invokeId","output","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","unsubscribe","Running","initEvent","attachDevTools","nextState","caughtError","transition","stop","size","reportError","err2","delaySend","delay","to","timerId","toJSON","getPersistedState","getSnapshot","createActor","resolveStop","args","actorRefOrString","resolvedActorRef","cloneState","executeStop","evaluateGuard","guard","context","machine","isInline","resolved","implementations","guards","guardArgs","params","check","isAtomicStateNode","stateNode","getChildren","values","states","filter","sn","getProperAncestors","toStateNode","ancestors","m","getConfiguration","stateNodes","configuration","configurationSet","adjList","getAdjList","s","has","initialStateNode","getInitialStateNodes","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isStateId","str","iter","descStateNode","targetStateNode","initial","a","getStateNode","stateKey","getStateNodeById","result","getStateNodes","State","childStateKeys","map","subStateKey","Boolean","root","reduce","allSubStateNodes","subStateNode","subStateNodes","static","meta","from","config","tags","historyValue","_internalQueue","matches","toStrings","valueKeys","jsonValues","hasTag","tag","can","transitionData","getTransitionData","some","t","actions","nextEvents","object","memoizedData","memo","ownEvents","acc","createSpawner","spawnedChildren","referenced","resolveReferencedActor","actors","syncSnapshot","spawn","resolveAssign","assignment","assignArgs","action","partialUpdate","propAssignment","assign","resolveChoose","branches","matchedActions","find","condition","resolveLog","label","executeLog","resolvePure","resolveRaise","eventOrExpr","delaysMap","delays","resolvedEvent","resolvedDelay","configDelay","executeRaise","SpecialTargets","resolveSendTo","resolvedTarget","targetActorRef","Parent","Internal","startsWith","slice","executeSendTo","sendTo","resolve","execute","sendParent","choose","errorData","arg","getActions","pure","raise"],"mappings":"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"}