!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).XStateActions={})}(this,(function(t){"use strict";const e=".",s="xstate.error",n="xstate.stop",i=new WeakMap;function o(t,e){return{type:`xstate.error.actor.${t}`,data:e}}function r(t,e,s,{sendId:n}){return[e,"function"==typeof n?n(s):n]}function c(t,e){t.self.cancel(e)}class a{constructor(t){this._process=t,this._active=!1,this._current=null,this._last=null}start(){this._active=!0,this.flush()}clear(){this._current&&(this._current.next=null,this._last=this._current)}prepend(t){this._current?this._current={value:t,next:this._current}:this.enqueue(t)}enqueue(t){const e={value:t,next:null};if(this._current)return this._last.next=e,void(this._last=e);this._current=e,this._last=e,this._active&&this.flush()}flush(){for(;this._current;){const t=this._current;this._process(t.value),t===this._current&&(this._current=this._current.next)}this._last=null}}function h(){const t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:window;if(t.__xstate__)return t.__xstate__}const u=t=>{const e=h();e&&e.register(t)};function d(t){setTimeout((()=>{throw t}))}const f="function"==typeof Symbol&&Symbol.observable||"@@observable";let l=0;function p(t,e){const s=y(t),n=y(e);return"string"==typeof n?"string"==typeof s&&n===s:"string"==typeof s?s in n:Object.keys(s).every((t=>t in n&&p(s[t],n[t])))}function y(t){if("object"==typeof(s=t)&&"value"in s&&"context"in s&&"event"in s)return t.value;var s;if(m(t))return v(t);if("string"!=typeof t)return t;return v(function(t){try{return m(t)?t:t.toString().split(e)}catch(e){throw new Error(`'${t}' is not a valid state path.`)}}(t))}function v(t){if(1===t.length)return t[0];const e={};let s=e;for(let e=0;e<t.length-1;e++)if(e===t.length-2)s[t[e]]=t[e+1];else{const n=s;s={},n[t[e]]=s}return e}function _(t){return[].concat(...t)}function g(t){return void 0===t?[]:function(t){return m(t)?t:[t]}(t)}function m(t){return Array.isArray(t)}function x(t,e,s){const n="object"==typeof t,i=n?t:void 0;return{next:(n?t.next:t)?.bind(i),error:(n?t.error:e)?.bind(i),complete:(n?t.complete:s)?.bind(i)}}let b=function(t){return t[t.NotStarted=0]="NotStarted",t[t.Running=1]="Running",t[t.Stopped=2]="Stopped",t}({});const w={clock:{setTimeout:(t,e)=>setTimeout(t,e),clearTimeout:t=>clearTimeout(t)},logger:console.log.bind(console),devTools:!1};class S{constructor(t,e){this.logic=t,this._state=void 0,this.clock=void 0,this.options=void 0,this.id=void 0,this.mailbox=new a(this._process.bind(this)),this.delayedEventsMap={},this.observers=new Set,this.logger=void 0,this.status=b.NotStarted,this._parent=void 0,this.ref=void 0,this._actorContext=void 0,this._systemId=void 0,this.sessionId=void 0,this.system=void 0,this._doneEvent=void 0,this.src=void 0,this._deferred=[];const s={...w,...e},{clock:n,logger:i,parent:o,id:r,systemId:c,inspect:h}=s;this.system=o?.system??function(t){const e=new Map,s=new Map,n=new WeakMap,i=new Set,o={_bookId:()=>"x:"+l++,_register:(t,s)=>(e.set(t,s),t),_unregister:t=>{e.delete(t.sessionId);const i=n.get(t);void 0!==i&&(s.delete(i),n.delete(t))},get:t=>s.get(t),_set:(t,e)=>{const i=s.get(t);if(i&&i!==e)throw new Error(`Actor with system ID '${t}' already exists.`);s.set(t,e),n.set(e,t)},inspect:t=>{i.add(t)},_sendInspectionEvent:e=>{const s={...e,rootId:t.sessionId};i.forEach((t=>t.next?.(s)))},_relay:(t,e,s)=>{o._sendInspectionEvent({type:"@xstate.event",sourceRef:t,targetRef:e,event:s}),e._send(s)}};return o}(this),h&&!o&&this.system.inspect(x(h)),c&&(this._systemId=c,this.system._set(c,this)),this.sessionId=this.system._bookId(),this.id=r??this.sessionId,this.logger=i,this.clock=n,this._parent=o,this.options=s,this.src=s.src,this.ref=this,this._actorContext={self:this,id:this.id,sessionId:this.sessionId,logger:this.logger,defer:t=>{this._deferred.push(t)},system:this.system,stopChild:t=>{if(t._parent!==this)throw new Error(`Cannot stop child actor ${t.id} of ${this.id} because it is not a child`);t._stop()}},this.send=this.send.bind(this),this.system._sendInspectionEvent({type:"@xstate.actor",actorRef:this}),this._initState()}_initState(){this._state=this.options.state?this.logic.restoreState?this.logic.restoreState(this.options.state,this._actorContext):this.options.state:this.logic.getInitialState(this._actorContext,this.options?.input)}update(t,e){let s;for(this._state=t;s=this._deferred.shift();)s();for(const e of this.observers)try{e.next?.(t)}catch(t){d(t)}switch(this._state.status){case"done":this._stopProcedure(),this._complete(),this._doneEvent=(n=this.id,i=this._state.output,{type:`xstate.done.actor.${n}`,output:i}),this._parent&&this.system._relay(this,this._parent,this._doneEvent);break;case"error":this._stopProcedure(),this._error(this._state.error),this._parent&&this.system._relay(this,this._parent,o(this.id,this._state.error))}var n,i;this.system._sendInspectionEvent({type:"@xstate.snapshot",actorRef:this,event:e,snapshot:t})}subscribe(t,e,s){const n=x(t,e,s);if(this.status!==b.Stopped)this.observers.add(n);else try{n.complete?.()}catch(t){d(t)}return{unsubscribe:()=>{this.observers.delete(n)}}}start(){if(this.status===b.Running)return this;this.system._register(this.sessionId,this),this._systemId&&this.system._set(this._systemId,this),this.status=b.Running;const t={type:"xstate.init",input:this.options.input};this.system._sendInspectionEvent({type:"@xstate.event",sourceRef:this._parent,targetRef:this,event:t});switch(this._state.status){case"done":this.update(this._state,t);case"error":return this}if(this.logic.start)try{this.logic.start(this._state,this._actorContext)}catch(t){return this._stopProcedure(),this._error(t),this._parent?.send(o(this.id,t)),this}return this.update(this._state,t),this.options.devTools&&this.attachDevTools(),this.mailbox.start(),this}_process(t){let e,s;try{e=this.logic.transition(this._state,t,this._actorContext)}catch(t){s={err:t}}if(s){const{err:t}=s;return this._stopProcedure(),this._error(t),void this._parent?.send(o(this.id,t))}this.update(e,t),t.type===n&&(this._stopProcedure(),this._complete())}_stop(){return this.status===b.Stopped?this:(this.mailbox.clear(),this.status===b.NotStarted?(this.status=b.Stopped,this):(this.mailbox.enqueue({type:n}),this))}stop(){if(this._parent)throw new Error("A non-root actor cannot be stopped directly.");return this._stop()}_complete(){for(const t of this.observers)try{t.complete?.()}catch(t){d(t)}this.observers.clear()}_error(t){if(!this.observers.size)return void(this._parent||d(t));let e=!1;for(const s of this.observers){const n=s.error;e||=!n;try{n?.(t)}catch(t){d(t)}}this.observers.clear(),e&&d(t)}_stopProcedure(){if(this.status!==b.Running)return this;for(const t of Object.keys(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[t]);return this.mailbox.clear(),this.mailbox=new a(this._process.bind(this)),this.status=b.Stopped,this.system._unregister(this),this}_send(t){this.status!==b.Stopped&&this.mailbox.enqueue(t)}send(t){this.system._relay(void 0,this,t)}delaySend({event:t,id:e,delay:s,to:n}){const i=this.clock.setTimeout((()=>{this.system._relay(this,n??this,t)}),s);e&&(this.delayedEventsMap[e]=i)}cancel(t){this.clock.clearTimeout(this.delayedEventsMap[t]),delete this.delayedEventsMap[t]}attachDevTools(){const{devTools:t}=this.options;if(t){("function"==typeof t?t:u)(this)}}toJSON(){return{id:this.id}}getPersistedState(){return this.logic.getPersistedState?.(this._state)}[f](){return this}getSnapshot(){return this._state}}function E(t,e){return new S(t,e)}function I(t,e,s,{actorRef:n}){const i="function"==typeof n?n(s):n,o="string"==typeof i?e.children[i]:i;let r=e.children;return o&&(r={...r},delete r[o.id]),[V(e,{children:r}),o]}function T(t,e){e&&(e.status===b.Running?t.defer((()=>{t.stopChild(e)})):t.stopChild(e))}function k(t,e,s,n){const{machine:i}=n,o="function"==typeof t,r=o?t:i.implementations.guards["string"==typeof t?t:t.type];if(!o&&!r)throw new Error(`Guard '${"string"==typeof t?t:t.type}' is not implemented.'.`);if("function"!=typeof r)return k(r,e,s,n);const c={context:e,event:s,guard:o?void 0:"string"==typeof t?{type:t}:"function"==typeof t.params?{type:t.type,params:t.params({context:e,event:s})}:t};if(!("check"in r))return r(c);return r.check(n,c,r)}const $=t=>"atomic"===t.type||"final"===t.type;function j(t){return Object.values(t.states).filter((t=>"history"!==t.type))}function R(t,e){const s=[];let n=t.parent;for(;n&&n!==e;)s.push(n),n=n.parent;return s}function O(t){const e=new Set(t),s=new Set(t),n=C(s);for(const t of e)if("compound"!==t.type||n.get(t)&&n.get(t).length){if("parallel"===t.type)for(const e of j(t))if("history"!==e.type&&!s.has(e))for(const t of N(e))s.add(t)}else N(t).forEach((t=>s.add(t)));for(const t of s){let e=t.parent;for(;e;)s.add(e),e=e.parent}return s}function P(t,e){const s=e.get(t);if(!s)return{};if("compound"===t.type){const t=s[0];if(!t)return{};if($(t))return t.key}const n={};for(const t of s)n[t.key]=P(t,e);return n}function C(t){const e=new Map;for(const s of t)e.has(s)||e.set(s,[]),s.parent&&(e.has(s.parent)||e.set(s.parent,[]),e.get(s.parent).push(s));return e}function M(t,e){return P(t,C(O(e)))}const A=t=>"#"===t[0];function N(t){const e=new Set;return function s(n){if(!e.has(n))if(e.add(n),"compound"===n.type)for(const i of n.initial.target){for(const s of R(i,t))e.add(s);s(i)}else if("parallel"===n.type)for(const t of j(n))s(t)}(t),[...e]}function Q(t,e){if(A(e))return t.machine.getStateNodeById(e);if(!t.states)throw new Error(`Unable to retrieve child state '${e}' from '${t.id}'; no child states exist.`);const s=t.states[e];if(!s)throw new Error(`Child state '${e}' does not exist on '${t.id}'`);return s}function q(t,e){const s=e instanceof D?e.value:y(e);if("string"==typeof s)return[t,t.states[s]];const n=Object.keys(s),i=n.map((e=>Q(t,e))).filter(Boolean);return[t.machine.root,t].concat(i,n.reduce(((e,n)=>{const i=Q(t,n);if(!i)return e;const o=q(i,s[n]);return e.concat(o)}),[]))}class D{static from(t,e={},s){if(t instanceof D)return t.context!==e?new D({value:t.value,context:e,meta:{},configuration:[],children:{},status:"active"},s):t;const n=O(q(s.root,t));return new D({value:t,context:e,meta:void 0,configuration:Array.from(n),children:{},status:"active"},s)}constructor(t,e){this.machine=e,this.tags=void 0,this.value=void 0,this.status=void 0,this.error=void 0,this.context=void 0,this.historyValue={},this._internalQueue=void 0,this.configuration=void 0,this.children=void 0,this.context=t.context,this._internalQueue=t._internalQueue??[],this.historyValue=t.historyValue||{},this.matches=this.matches.bind(this),this.toStrings=this.toStrings.bind(this),this.configuration=t.configuration??Array.from(O(q(e.root,t.value))),this.children=t.children,this.value=M(e.root,this.configuration),this.tags=new Set(_(this.configuration.map((t=>t.tags)))),this.status=t.status,this.output=t.output,this.error=t.error}toStrings(t=this.value){if("string"==typeof t)return[t];const s=Object.keys(t);return s.concat(...s.map((s=>this.toStrings(t[s]).map((t=>s+e+t)))))}toJSON(){const{configuration:t,tags:e,machine:s,...n}=this;return{...n,tags:Array.from(e),meta:this.meta}}matches(t){return p(t,this.value)}hasTag(t){return this.tags.has(t)}can(t){const e=this.machine.getTransitionData(this,t);return!!e?.length&&e.some((t=>void 0!==t.target||t.actions.length))}get nextEvents(){return function(t,e,s){let n=i.get(t);return n?e in n||(n[e]=s()):(n={[e]:s()},i.set(t,n)),n[e]}(this,"nextEvents",(()=>[...new Set(_([...this.configuration.map((t=>t.ownEvents))]))]))}get meta(){return this.configuration.reduce(((t,e)=>(void 0!==e.meta&&(t[e.id]=e.meta),t)),{})}}function V(t,e={}){return new D({...t,...e},t.machine)}function W(t,{machine:e,context:s},n,i){return(r,c)=>{const a=((o,r={})=>{const{systemId:c}=r;if("string"==typeof o){const a=function(t){return t?"transition"in t?{src:t,input:void 0}:t:void 0}(e.implementations.actors[o]);if(!a)throw new Error(`Actor logic '${o}' not implemented in machine '${e.id}'`);const h="input"in r?r.input:a.input,u=E(a.src,{id:r.id,parent:t.self,input:"function"==typeof h?h({context:s,event:n,self:t.self}):h,systemId:c});return i[u.id]=u,r.syncSnapshot&&u.subscribe({next:e=>{"active"===e.status&&t.self.send({type:`xstate.snapshot.${u.id}`,snapshot:e})},error:()=>{}}),u}{const e=E(o,{id:r.id,parent:t.self,input:r.input,systemId:c});return r.syncSnapshot&&e.subscribe({next:s=>{"active"===s.status&&t.self.send({type:`xstate.snapshot.${e.id}`,snapshot:s,id:e.id})},error:()=>{}}),e}})(r,c);return i[a.id]=a,t.defer((()=>{if(a.status!==b.Stopped)try{a.start?.()}catch(e){return void t.self.send(o(a.id,e))}})),a}}function B(t,e,s,{assignment:n}){if(!e.context)throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");const i={},o={context:e.context,event:s.event,action:s.action,spawn:W(t,e,s.event,i),self:t?.self,system:t?.system};let r={};if("function"==typeof n)r=n(o);else for(const t of Object.keys(n)){const e=n[t];r[t]="function"==typeof e?e(o):e}return[V(e,{context:Object.assign({},e.context,r),children:Object.keys(i).length?{...e.children,...i}:e.children})]}function J(t,e,s,{branches:n}){const i=n.find((t=>!t.guard||k(t.guard,e.context,s.event,e)))?.actions;return[e,void 0,g(i)]}function U(t,e,s,{value:n,label:i}){return[e,{value:"function"==typeof n?n(s):n,label:i}]}function z({logger:t},{value:e,label:s}){s?t(s,e):t(e)}function G(t,e,s,{get:n}){return[e,void 0,g(n({context:s.context,event:s.event}))]}function X(t,e,s,{event:n,id:i,delay:o}){const r=e.machine.implementations.delays;if("string"==typeof n)throw new Error(`Only event objects may be used with raise; use raise({ type: "${n}" }) instead`);const c="function"==typeof n?n(s):n;let a;if("string"==typeof o){const t=r&&r[o];a="function"==typeof t?t(s):t}else a="function"==typeof o?o(s):o;return["number"!=typeof a?V(e,{_internalQueue:e._internalQueue.concat(c)}):e,{event:c,id:i,delay:a}]}function F(t,e){"number"!=typeof e.delay||t.self.delaySend(e)}let H=function(t){return t.Parent="#_parent",t.Internal="#_internal",t}({});function K(t,e,s,{to:n,event:i,id:o,delay:r}){const c=e.machine.implementations.delays;if("string"==typeof i)throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${i}" }) instead`);const a="function"==typeof i?i(s):i;let h;if("string"==typeof r){const t=c&&c[r];h="function"==typeof t?t(s):t}else h="function"==typeof r?r(s):r;const u="function"==typeof n?n(s):n;let d;if("string"==typeof u){if(d=u===H.Parent?t?.self._parent:u===H.Internal?t?.self:u.startsWith("#_")?e.children[u.slice(2)]:e.children[u],!d)throw new Error(`Unable to send event to actor '${u}' from machine '${e.machine.id}'.`)}else d=u||t?.self;return[e,{to:d,event:a,id:o,delay:h}]}function L(t,e){if("number"==typeof e.delay)return void t.self.delaySend(e);const{to:n,event:i}=e;t.defer((()=>{t?.system._relay(t.self,n,i.type===s?o(t.self.id,i.data):i)}))}function Y(t,e,s){function n(t){}return n.type="xstate.sendTo",n.to=t,n.event=e,n.id=s?.id,n.delay=s?.delay,n.resolve=K,n.execute=L,n}function Z(t,e){return Y(H.Parent,t,e)}t.assign=function(t){function e(t){}return e.type="xstate.assign",e.assignment=t,e.resolve=B,e},t.cancel=function(t){function e(t){}return e.type="xstate.cancel",e.sendId=t,e.resolve=r,e.execute=c,e},t.choose=function(t){function e(t){}return e.type="xstate.choose",e.branches=t,e.resolve=J,e},t.escalate=function(t,e){return Z((e=>({type:s,data:"function"==typeof t?t(e):t})),e)},t.forwardTo=function(t,e){return Y(t,(({event:t})=>t),e)},t.log=function(t=(({context:t,event:e})=>({context:t,event:e})),e){function s(t){}return s.type="xstate.log",s.value=t,s.label=e,s.resolve=U,s.execute=z,s},t.pure=function(t){function e(t){}return e.type="xstate.pure",e.get=t,e.resolve=G,e},t.raise=function(t,e){function s(t){}return s.type="xstate.raise",s.event=t,s.id=e?.id,s.delay=e?.delay,s.resolve=X,s.execute=F,s},t.sendParent=Z,t.sendTo=Y,t.stop=function(t){function e(t){}return e.type="xstate.stop",e.actorRef=t,e.resolve=I,e.execute=T,e},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=xstate-actions.umd.min.js.map
