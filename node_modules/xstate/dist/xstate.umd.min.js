!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).XState={})}(this,(function(t){"use strict";const e=".",n="",s="",i="xstate.init",o="xstate.error",r="xstate.stop",a=new WeakMap;function c(t,e,n){let s=a.get(t);return s?e in s||(s[e]=n()):(s={[e]:n()},a.set(t,s)),s[e]}function u(t,e){return{type:`xstate.done.state.${t}`,output:e}}function h(t,e){return{type:`xstate.error.actor.${t}`,data:e}}function f(t){return{type:i,input:t}}function d(t,e,n,{sendId:s}){return[e,"function"==typeof s?s(n):s]}function p(t,e){t.self.cancel(e)}function l(t){function e(t){}return e.type="xstate.cancel",e.sendId=t,e.resolve=d,e.execute=p,e}class y{constructor(t){this._process=t,this._active=!1,this._current=null,this._last=null}start(){this._active=!0,this.flush()}clear(){this._current&&(this._current.next=null,this._last=this._current)}prepend(t){this._current?this._current={value:t,next:this._current}:this.enqueue(t)}enqueue(t){const e={value:t,next:null};if(this._current)return this._last.next=e,void(this._last=e);this._current=e,this._last=e,this._active&&this.flush()}flush(){for(;this._current;){const t=this._current;this._process(t.value),t===this._current&&(this._current=this._current.next)}this._last=null}}function v(){const t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:window;if(t.__xstate__)return t.__xstate__}const g=t=>{const e=v();e&&e.register(t)};function m(t){setTimeout((()=>{throw t}))}const _="function"==typeof Symbol&&Symbol.observable||"@@observable";let x=0;function b(t,e){const n=w(t),s=w(e);return"string"==typeof s?"string"==typeof n&&s===n:"string"==typeof n?n in s:Object.keys(n).every((t=>t in s&&b(n[t],s[t])))}function S(t){try{return j(t)?t:t.toString().split(e)}catch(e){throw new Error(`'${t}' is not a valid state path.`)}}function w(t){if("object"==typeof(e=t)&&"value"in e&&"context"in e&&"event"in e)return t.value;var e;if(j(t))return $(t);if("string"!=typeof t)return t;return $(S(t))}function $(t){if(1===t.length)return t[0];const e={};let n=e;for(let e=0;e<t.length-1;e++)if(e===t.length-2)n[t[e]]=t[e+1];else{const s=n;n={},s[t[e]]=n}return e}function k(t,e){const n={},s=Object.keys(t);for(let i=0;i<s.length;i++){const o=s[i];n[o]=e(t[o],o,t,i)}return n}function I(t){return[].concat(...t)}function T(t){return j(t)?t:[t]}function E(t){return void 0===t?[]:T(t)}function O(t,e,n,s){return"function"==typeof t?t({context:e,event:n,self:s}):t}function j(t){return Array.isArray(t)}function M(t){return T(t).map((t=>void 0===t||"string"==typeof t?{target:t}:t))}function P(t){if(void 0!==t&&t!==n)return E(t)}function N(t,e,n){const s="object"==typeof t,i=s?t:void 0;return{next:(s?t.next:t)?.bind(i),error:(s?t.error:e)?.bind(i),complete:(s?t.complete:n)?.bind(i)}}function A(t){return t?"transition"in t?{src:t,input:void 0}:t:void 0}let R=function(t){return t[t.NotStarted=0]="NotStarted",t[t.Running=1]="Running",t[t.Stopped=2]="Stopped",t}({});const C=R,D={clock:{setTimeout:(t,e)=>setTimeout(t,e),clearTimeout:t=>clearTimeout(t)},logger:console.log.bind(console),devTools:!1};class Q{constructor(t,e){this.logic=t,this._state=void 0,this.clock=void 0,this.options=void 0,this.id=void 0,this.mailbox=new y(this._process.bind(this)),this.delayedEventsMap={},this.observers=new Set,this.logger=void 0,this.status=R.NotStarted,this._parent=void 0,this.ref=void 0,this._actorContext=void 0,this._systemId=void 0,this.sessionId=void 0,this.system=void 0,this._doneEvent=void 0,this.src=void 0,this._deferred=[];const n={...D,...e},{clock:s,logger:i,parent:o,id:r,systemId:a,inspect:c}=n;this.system=o?.system??function(t){const e=new Map,n=new Map,s=new WeakMap,i=new Set,o={_bookId:()=>"x:"+x++,_register:(t,n)=>(e.set(t,n),t),_unregister:t=>{e.delete(t.sessionId);const i=s.get(t);void 0!==i&&(n.delete(i),s.delete(t))},get:t=>n.get(t),_set:(t,e)=>{const i=n.get(t);if(i&&i!==e)throw new Error(`Actor with system ID '${t}' already exists.`);n.set(t,e),s.set(e,t)},inspect:t=>{i.add(t)},_sendInspectionEvent:e=>{const n={...e,rootId:t.sessionId};i.forEach((t=>t.next?.(n)))},_relay:(t,e,n)=>{o._sendInspectionEvent({type:"@xstate.event",sourceRef:t,targetRef:e,event:n}),e._send(n)}};return o}(this),c&&!o&&this.system.inspect(N(c)),a&&(this._systemId=a,this.system._set(a,this)),this.sessionId=this.system._bookId(),this.id=r??this.sessionId,this.logger=i,this.clock=s,this._parent=o,this.options=n,this.src=n.src,this.ref=this,this._actorContext={self:this,id:this.id,sessionId:this.sessionId,logger:this.logger,defer:t=>{this._deferred.push(t)},system:this.system,stopChild:t=>{if(t._parent!==this)throw new Error(`Cannot stop child actor ${t.id} of ${this.id} because it is not a child`);t._stop()}},this.send=this.send.bind(this),this.system._sendInspectionEvent({type:"@xstate.actor",actorRef:this}),this._initState()}_initState(){this._state=this.options.state?this.logic.restoreState?this.logic.restoreState(this.options.state,this._actorContext):this.options.state:this.logic.getInitialState(this._actorContext,this.options?.input)}update(t,e){let n;for(this._state=t;n=this._deferred.shift();)n();for(const e of this.observers)try{e.next?.(t)}catch(t){m(t)}switch(this._state.status){case"done":this._stopProcedure(),this._complete(),this._doneEvent=(s=this.id,i=this._state.output,{type:`xstate.done.actor.${s}`,output:i}),this._parent&&this.system._relay(this,this._parent,this._doneEvent);break;case"error":this._stopProcedure(),this._error(this._state.error),this._parent&&this.system._relay(this,this._parent,h(this.id,this._state.error))}var s,i;this.system._sendInspectionEvent({type:"@xstate.snapshot",actorRef:this,event:e,snapshot:t})}subscribe(t,e,n){const s=N(t,e,n);if(this.status!==R.Stopped)this.observers.add(s);else try{s.complete?.()}catch(t){m(t)}return{unsubscribe:()=>{this.observers.delete(s)}}}start(){if(this.status===R.Running)return this;this.system._register(this.sessionId,this),this._systemId&&this.system._set(this._systemId,this),this.status=R.Running;const t=f(this.options.input);this.system._sendInspectionEvent({type:"@xstate.event",sourceRef:this._parent,targetRef:this,event:t});switch(this._state.status){case"done":this.update(this._state,t);case"error":return this}if(this.logic.start)try{this.logic.start(this._state,this._actorContext)}catch(t){return this._stopProcedure(),this._error(t),this._parent?.send(h(this.id,t)),this}return this.update(this._state,t),this.options.devTools&&this.attachDevTools(),this.mailbox.start(),this}_process(t){let e,n;try{e=this.logic.transition(this._state,t,this._actorContext)}catch(t){n={err:t}}if(n){const{err:t}=n;return this._stopProcedure(),this._error(t),void this._parent?.send(h(this.id,t))}this.update(e,t),t.type===r&&(this._stopProcedure(),this._complete())}_stop(){return this.status===R.Stopped?this:(this.mailbox.clear(),this.status===R.NotStarted?(this.status=R.Stopped,this):(this.mailbox.enqueue({type:r}),this))}stop(){if(this._parent)throw new Error("A non-root actor cannot be stopped directly.");return this._stop()}_complete(){for(const t of this.observers)try{t.complete?.()}catch(t){m(t)}this.observers.clear()}_error(t){if(!this.observers.size)return void(this._parent||m(t));let e=!1;for(const n of this.observers){const s=n.error;e||=!s;try{s?.(t)}catch(t){m(t)}}this.observers.clear(),e&&m(t)}_stopProcedure(){if(this.status!==R.Running)return this;for(const t of Object.keys(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[t]);return this.mailbox.clear(),this.mailbox=new y(this._process.bind(this)),this.status=R.Stopped,this.system._unregister(this),this}_send(t){this.status!==R.Stopped&&this.mailbox.enqueue(t)}send(t){this.system._relay(void 0,this,t)}delaySend({event:t,id:e,delay:n,to:s}){const i=this.clock.setTimeout((()=>{this.system._relay(this,s??this,t)}),n);e&&(this.delayedEventsMap[e]=i)}cancel(t){this.clock.clearTimeout(this.delayedEventsMap[t]),delete this.delayedEventsMap[t]}attachDevTools(){const{devTools:t}=this.options;if(t){("function"==typeof t?t:g)(this)}}toJSON(){return{id:this.id}}getPersistedState(){return this.logic.getPersistedState?.(this._state)}[_](){return this}getSnapshot(){return this._state}}function V(t,e){return new Q(t,e)}const J=V;function B(t,e,n,{id:s,systemId:i,src:o,input:r,syncSnapshot:a}){const c=A(e.machine.implementations.actors[o]);let u;if(c){const h=r||c.input;u=V(c.src,{id:s,src:o,parent:t?.self,systemId:i,input:"function"==typeof h?h({context:e.context,event:n.event,self:t?.self}):h}),a&&u.subscribe({next:e=>{"active"===e.status&&t.self.send({type:`xstate.snapshot.${s}`,snapshot:e})},error:()=>{}})}return[Ct(e,{children:{...e.children,[s]:u}}),{id:s,actorRef:u}]}function z(t,{id:e,actorRef:n}){n&&t.defer((()=>{if(n.status!==R.Stopped)try{n.start?.()}catch(n){return void t.self.send(h(e,n))}}))}function U({id:t,systemId:e,src:n,input:s,onSnapshot:i}){function o(t){}return o.type="xstate.invoke",o.id=t,o.systemId=e,o.src=n,o.input=s,o.syncSnapshot=!!i,o.resolve=B,o.execute=z,o}function W(t,e,n,{actorRef:s}){const i="function"==typeof s?s(n):s,o="string"==typeof i?e.children[i]:i;let r=e.children;return o&&(r={...r},delete r[o.id]),[Ct(e,{children:r}),o]}function q(t,e){e&&(e.status===R.Running?t.defer((()=>{t.stopChild(e)})):t.stopChild(e))}function G(t){function e(t){}return e.type="xstate.stop",e.actorRef=t,e.resolve=W,e.execute=q,e}function F(t,e,{stateValue:n}){return"string"==typeof n&&rt(n)?t.configuration.some((t=>t.id===n.slice(1))):t.matches(n)}function L(t,{context:e,event:n},{guards:s}){return!K(s[0],e,n,t)}function X(t,{context:e,event:n},{guards:s}){return s.every((s=>K(s,e,n,t)))}function H(t,{context:e,event:n},{guards:s}){return s.some((s=>K(s,e,n,t)))}function K(t,e,n,s){const{machine:i}=s,o="function"==typeof t,r=o?t:i.implementations.guards["string"==typeof t?t:t.type];if(!o&&!r)throw new Error(`Guard '${"string"==typeof t?t:t.type}' is not implemented.'.`);if("function"!=typeof r)return K(r,e,n,s);const a={context:e,event:n,guard:o?void 0:"string"==typeof t?{type:t}:"function"==typeof t.params?{type:t.type,params:t.params({context:e,event:n})}:t};if(!("check"in r))return r(a);return r.check(s,a,r)}const Y=t=>"atomic"===t.type||"final"===t.type;function Z(t){return Object.values(t.states).filter((t=>"history"!==t.type))}function tt(t,e){const n=[];let s=t.parent;for(;s&&s!==e;)n.push(s),s=s.parent;return n}function et(t){const e=new Set(t),n=new Set(t),s=st(n);for(const t of e)if("compound"!==t.type||s.get(t)&&s.get(t).length){if("parallel"===t.type)for(const e of Z(t))if("history"!==e.type&&!n.has(e))for(const t of ft(e))n.add(t)}else ft(t).forEach((t=>n.add(t)));for(const t of n){let e=t.parent;for(;e;)n.add(e),e=e.parent}return n}function nt(t,e){const n=e.get(t);if(!n)return{};if("compound"===t.type){const t=n[0];if(!t)return{};if(Y(t))return t.key}const s={};for(const t of n)s[t.key]=nt(t,e);return s}function st(t){const e=new Map;for(const n of t)e.has(n)||e.set(n,[]),n.parent&&(e.has(n.parent)||e.set(n.parent,[]),e.get(n.parent).push(n));return e}function it(t,e){return nt(t,st(et(e)))}function ot(t,e=t[0].machine.root){return"compound"===e.type?Z(e).some((e=>"final"===e.type&&t.includes(e))):"parallel"===e.type&&Z(e).every((e=>ot(t,e)))}const rt=t=>"#"===t[0];function at(t,e,n){const s=P(n.target),i=n.reenter??!1,o=ct(t,s),r={...n,actions:E(n.actions),guard:n.guard,target:o,source:t,reenter:i,eventType:e,toJSON:()=>({...r,source:`#${t.id}`,target:o?o.map((t=>`#${t.id}`)):void 0})};return r}function ct(t,n){if(void 0!==n)return n.map((n=>{if("string"!=typeof n)return n;if(rt(n))return t.machine.getStateNodeById(n);const s=n[0]===e;if(s&&!t.parent)return pt(t,n.slice(1));const i=s?t.key+n:n;if(!t.parent)throw new Error(`Invalid target: "${n}" is not a valid target from the root node. Did you mean ".${n}"?`);try{return pt(t.parent,i)}catch(e){throw new Error(`Invalid transition definition for state node '${t.id}':\n${e.message}`)}}))}function ut(t){const e=P(t.config.target);return e?e.map((e=>"string"==typeof e?pt(t.parent,e):e)):t.parent.initial.target}function ht(t){return"history"===t.type}function ft(t){const e=new Set;return function n(s){if(!e.has(s))if(e.add(s),"compound"===s.type)for(const i of s.initial.target){for(const n of tt(i,t))e.add(n);n(i)}else if("parallel"===s.type)for(const t of Z(s))n(t)}(t),[...e]}function dt(t,e){if(rt(e))return t.machine.getStateNodeById(e);if(!t.states)throw new Error(`Unable to retrieve child state '${e}' from '${t.id}'; no child states exist.`);const n=t.states[e];if(!n)throw new Error(`Child state '${e}' does not exist on '${t.id}'`);return n}function pt(t,e){if("string"==typeof e&&rt(e))try{return t.machine.getStateNodeById(e)}catch(t){}const n=S(e).slice();let s=t;for(;n.length;){const t=n.shift();if(!t.length)break;s=dt(s,t)}return s}function lt(t,e){const n=e instanceof Rt?e.value:w(e);if("string"==typeof n)return[t,t.states[n]];const s=Object.keys(n),i=s.map((e=>dt(t,e))).filter(Boolean);return[t.machine.root,t].concat(i,s.reduce(((e,s)=>{const i=dt(t,s);if(!i)return e;const o=lt(i,n[s]);return e.concat(o)}),[]))}function yt(t,e,n,s){return"string"==typeof e?function(t,e,n,s){const i=dt(t,e).next(n,s);return i&&i.length?i:t.next(n,s)}(t,e,n,s):1===Object.keys(e).length?function(t,e,n,s){const i=Object.keys(e),o=yt(dt(t,i[0]),e[i[0]],n,s);return o&&o.length?o:t.next(n,s)}(t,e,n,s):function(t,e,n,s){const i=[];for(const o of Object.keys(e)){const r=e[o];if(!r)continue;const a=yt(dt(t,o),r,n,s);a&&i.push(...a)}return i.length?i:t.next(n,s)}(t,e,n,s)}function vt(t){return Object.keys(t.states).map((e=>t.states[e])).filter((t=>"history"===t.type))}function gt(t,e){let n=t;for(;n.parent&&n.parent!==e;)n=n.parent;return n.parent===e}function mt(t){const e=[];let n=t.parent;for(;n;)e.unshift(n),n=n.parent;return e}function _t(t,e){const n=new Set(t),s=new Set(e);for(const t of n)if(s.has(t))return!0;for(const t of s)if(n.has(t))return!0;return!1}function xt(t,e,n){const s=new Set;for(const i of t){let t=!1;const o=new Set;for(const r of s)if(_t(wt([i],e,n),wt([r],e,n))){if(!gt(i.source,r.source)){t=!0;break}o.add(r)}if(!t){for(const t of o)s.delete(t);s.add(i)}}return Array.from(s)}function bt(t,e){if(!t.target)return[];const n=new Set;for(const s of t.target)if(ht(s))if(e[s.id])for(const t of e[s.id])n.add(t);else for(const t of bt({target:ut(s)},e))n.add(t);else n.add(s);return[...n]}function St(t,e){const n=bt(t,e);if(!n)return null;if(!t.reenter&&"parallel"!==t.source.type&&n.every((e=>gt(e,t.source))))return t.source;return function(t){const[e]=t;let n=mt(e),s=[];for(const e of t){const t=mt(e);s=n.filter((e=>t.includes(e))),n=s,s=[]}return n[n.length-1]}(n.concat(t.source))}function wt(t,e,n){const s=new Set;for(const i of t)if(i.target?.length){const t=St(i,n);for(const n of e)gt(n,t)&&s.add(n)}return[...s]}function $t(t,e,n,s,i){const o=new Set(e.configuration);if(!t.length)return e;const r=function(t,e,n,s,i,o){const r=[],a={...e.historyValue},c=xt(t,n,a),h=[...e._internalQueue];o||function(t,e,n,s){const i=wt(t,e,n);i.sort(((t,e)=>e.order-t.order));for(const t of i)for(const s of vt(t)){let i;i="deep"===s.history?e=>Y(e)&&gt(e,t):e=>e.parent===t,n[s.id]=Array.from(e).filter(i)}for(const t of i)s.push(...t.exit,...t.invoke.map((t=>G(t.id)))),e.delete(t)}(c,n,a,r);r.push(...c.flatMap((t=>t.actions))),function(t,e,n,s,i,o,r,a,c){const h=new Set,f=new Set;kt(e,r,f,h),a&&f.add(o.machine.root);for(const e of[...h].sort(((t,e)=>t.order-e.order))){n.add(e);for(const t of e.invoke)s.push(U(t));if(s.push(...e.entry),f.has(e))for(const t of f){const e=t.initial.actions;s.push(...e)}if("final"===e.type){const s=e.parent;if(!s.parent)continue;if(i.push(u(s.id,e.output?O(e.output,o.context,t,c.self):void 0)),s.parent){const t=s.parent;"parallel"===t.type&&Z(t).every((t=>ot([...n],t)))&&i.push(u(t.id))}}}}(s,c,n,r,h,e,a,o,i);const f=[...n],d=ot(f);if(d){const t=f.sort(((t,e)=>e.order-t.order)).flatMap((t=>t.exit));r.push(...t)}try{const t=Et(r,s,e,i),n=d?function(t,e,n,s){const{machine:i}=t[0],{root:o}=i;if(!o.output)return;const r=t.find((t=>"final"===t.type&&t.parent===i.root)),a=u(r.id,r.output?O(r.output,e,n,s):void 0);return O(o.output,e,a,s)}(f,t.context,s,i.self):void 0;return h.push(...t._internalQueue),Ct(e,{configuration:f,historyValue:a,_internalQueue:h,context:t.context,status:d?"done":e.status,output:n,children:t.children})}catch(t){throw t}}(t,e,o,s,n,i);return Ct(r,{value:{}})}function kt(t,e,n,s){for(const i of t){for(const t of i.target||[])It(t,e,n,s);const t=St(i,e),o=bt(i,e);for(const i of o)Tt(i,t,s,e,n)}}function It(t,e,n,s){if(ht(t))if(e[t.id]){const i=e[t.id];for(const t of i)It(t,e,n,s);for(const o of i){Tt(o,t.parent,s,e,n);for(const t of n)n.add(t)}}else{const i=ut(t);for(const t of i)It(t,e,n,s);for(const o of i){Tt(o,t,s,e,n);for(const t of n)n.add(t)}}else if(s.add(t),"compound"===t.type){n.add(t);const i=t.initial.target;for(const t of i)It(t,e,n,s);for(const o of i)Tt(o,t,s,e,n)}else if("parallel"===t.type)for(const i of Z(t).filter((t=>!ht(t))))[...s].some((t=>gt(t,i)))||It(i,e,n,s)}function Tt(t,e,n,s,i){const o=tt(t,e);for(const t of o)if(n.add(t),"parallel"===t.type)for(const e of Z(t).filter((t=>!ht(t))))[...n].some((t=>gt(t,e)))||It(e,s,i,n)}function Et(t,e,n,s){const{machine:i}=n;let o=Ct(n,{_internalQueue:[]});for(const n of t){const t="function"==typeof n,r=t?n:i.implementations.actions["string"==typeof n?n:n.type];if(!r)continue;const a={context:o.context,event:e,self:s?.self,system:s?.system,action:t?void 0:"string"==typeof n?{type:n}:"function"==typeof n.params?{type:n.type,params:n.params({context:o.context,event:e})}:n};if(!("resolve"in r)){s?.self.status===R.Running?r(a):s?.defer((()=>{r(a)}));continue}const c=r,[u,h,f]=c.resolve(s,o,a,r);o=u,"execute"in r&&(s?.self.status===R.Running?c.execute(s,h):s?.defer(c.execute.bind(null,s,h))),f&&(o=Et(f,e,o,s))}return o}function Ot(t,e,n){let s=t;const o=[];if(e.type===r)return s=jt(e,s,n),o.push(s),{state:s,microstates:o};let a=e;if(a.type!==i){s=$t(Mt(a,s),t,n,a,!1),o.push(s)}for(;"active"===s.status;){let t=Pt(s,a);if(t.length)s=$t(t,s,n,a,!1),o.push(s);else{if(!s._internalQueue.length)break;a=s._internalQueue[0];s=$t(Mt(a,s),s,n,a,!1),s._internalQueue.shift(),o.push(s)}}return"active"!==s.status&&jt(a,s,n),{state:s,microstates:o}}function jt(t,e,n){const s=[];for(const t of e.configuration.sort(((t,e)=>e.order-t.order)))s.push(...t.exit);for(const t of Object.values(e.children))s.push(G(t));return Et(s,t,e,n)}function Mt(t,e){return e.machine.getTransitionData(e,t)}function Pt(t,e){const n=new Set,s=t.configuration.filter(Y);for(const i of s)t:for(const s of[i].concat(tt(i,null)))if(s.always)for(const i of s.always)if(void 0===i.guard||K(i.guard,t.context,e,t)){n.add(i);break t}return xt(Array.from(n),new Set(t.configuration),t.historyValue)}function Nt(t,e){return it(t,[...et(lt(t,e))])}function At(t){const e=[],n=t.initial,s=new Set;kt([n],{},new Set([t]),s);for(const t of[...s].sort(((t,e)=>t.order-e.order)))e.push(t);return e}class Rt{static from(t,e={},n){if(t instanceof Rt)return t.context!==e?new Rt({value:t.value,context:e,meta:{},configuration:[],children:{},status:"active"},n):t;const s=et(lt(n.root,t));return new Rt({value:t,context:e,meta:void 0,configuration:Array.from(s),children:{},status:"active"},n)}constructor(t,e){this.machine=e,this.tags=void 0,this.value=void 0,this.status=void 0,this.error=void 0,this.context=void 0,this.historyValue={},this._internalQueue=void 0,this.configuration=void 0,this.children=void 0,this.context=t.context,this._internalQueue=t._internalQueue??[],this.historyValue=t.historyValue||{},this.matches=this.matches.bind(this),this.toStrings=this.toStrings.bind(this),this.configuration=t.configuration??Array.from(et(lt(e.root,t.value))),this.children=t.children,this.value=it(e.root,this.configuration),this.tags=new Set(I(this.configuration.map((t=>t.tags)))),this.status=t.status,this.output=t.output,this.error=t.error}toStrings(t=this.value){if("string"==typeof t)return[t];const n=Object.keys(t);return n.concat(...n.map((n=>this.toStrings(t[n]).map((t=>n+e+t)))))}toJSON(){const{configuration:t,tags:e,machine:n,...s}=this;return{...s,tags:Array.from(e),meta:this.meta}}matches(t){return b(t,this.value)}hasTag(t){return this.tags.has(t)}can(t){const e=this.machine.getTransitionData(this,t);return!!e?.length&&e.some((t=>void 0!==t.target||t.actions.length))}get nextEvents(){return c(this,"nextEvents",(()=>[...new Set(I([...this.configuration.map((t=>t.ownEvents))]))]))}get meta(){return this.configuration.reduce(((t,e)=>(void 0!==e.meta&&(t[e.id]=e.meta),t)),{})}}function Ct(t,e={}){return new Rt({...t,...e},t.machine)}function Dt(t,{machine:e,context:n},s,i){return(o,r)=>{const a=((o,r={})=>{const{systemId:a}=r;if("string"==typeof o){const c=A(e.implementations.actors[o]);if(!c)throw new Error(`Actor logic '${o}' not implemented in machine '${e.id}'`);const u="input"in r?r.input:c.input,h=V(c.src,{id:r.id,parent:t.self,input:"function"==typeof u?u({context:n,event:s,self:t.self}):u,systemId:a});return i[h.id]=h,r.syncSnapshot&&h.subscribe({next:e=>{"active"===e.status&&t.self.send({type:`xstate.snapshot.${h.id}`,snapshot:e})},error:()=>{}}),h}{const e=V(o,{id:r.id,parent:t.self,input:r.input,systemId:a});return r.syncSnapshot&&e.subscribe({next:n=>{"active"===n.status&&t.self.send({type:`xstate.snapshot.${e.id}`,snapshot:n,id:e.id})},error:()=>{}}),e}})(o,r);return i[a.id]=a,t.defer((()=>{if(a.status!==R.Stopped)try{a.start?.()}catch(e){return void t.self.send(h(a.id,e))}})),a}}function Qt(t,e,n,{assignment:s}){if(!e.context)throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");const i={},o={context:e.context,event:n.event,action:n.action,spawn:Dt(t,e,n.event,i),self:t?.self,system:t?.system};let r={};if("function"==typeof s)r=s(o);else for(const t of Object.keys(s)){const e=s[t];r[t]="function"==typeof e?e(o):e}return[Ct(e,{context:Object.assign({},e.context,r),children:Object.keys(i).length?{...e.children,...i}:e.children})]}function Vt(t){function e(t){}return e.type="xstate.assign",e.assignment=t,e.resolve=Qt,e}function Jt(t,e,n,{branches:s}){const i=s.find((t=>!t.guard||K(t.guard,e.context,n.event,e)))?.actions;return[e,void 0,E(i)]}function Bt(t,e,n,{value:s,label:i}){return[e,{value:"function"==typeof s?s(n):s,label:i}]}function zt({logger:t},{value:e,label:n}){n?t(n,e):t(e)}function Ut(t,e,n,{get:s}){return[e,void 0,E(s({context:n.context,event:n.event}))]}function Wt(t,e,n,{event:s,id:i,delay:o}){const r=e.machine.implementations.delays;if("string"==typeof s)throw new Error(`Only event objects may be used with raise; use raise({ type: "${s}" }) instead`);const a="function"==typeof s?s(n):s;let c;if("string"==typeof o){const t=r&&r[o];c="function"==typeof t?t(n):t}else c="function"==typeof o?o(n):o;return["number"!=typeof c?Ct(e,{_internalQueue:e._internalQueue.concat(a)}):e,{event:a,id:i,delay:c}]}function qt(t,e){"number"!=typeof e.delay||t.self.delaySend(e)}function Gt(t,e){function n(t){}return n.type="xstate.raise",n.event=t,n.id=e?.id,n.delay=e?.delay,n.resolve=Wt,n.execute=qt,n}let Ft=function(t){return t.Parent="#_parent",t.Internal="#_internal",t}({});function Lt(t,e,n,{to:s,event:i,id:o,delay:r}){const a=e.machine.implementations.delays;if("string"==typeof i)throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${i}" }) instead`);const c="function"==typeof i?i(n):i;let u;if("string"==typeof r){const t=a&&a[r];u="function"==typeof t?t(n):t}else u="function"==typeof r?r(n):r;const h="function"==typeof s?s(n):s;let f;if("string"==typeof h){if(f=h===Ft.Parent?t?.self._parent:h===Ft.Internal?t?.self:h.startsWith("#_")?e.children[h.slice(2)]:e.children[h],!f)throw new Error(`Unable to send event to actor '${h}' from machine '${e.machine.id}'.`)}else f=h||t?.self;return[e,{to:f,event:c,id:o,delay:u}]}function Xt(t,e){if("number"==typeof e.delay)return void t.self.delaySend(e);const{to:n,event:s}=e;t.defer((()=>{t?.system._relay(t.self,n,s.type===o?h(t.self.id,s.data):s)}))}function Ht(t,e,n){function s(t){}return s.type="xstate.sendTo",s.to=t,s.event=e,s.id=n?.id,s.delay=n?.delay,s.resolve=Lt,s.execute=Xt,s}function Kt(t,e){return Ht(Ft.Parent,t,e)}function Yt(t,e){return{config:t,transition:(e,n,s)=>({...e,context:t(e.context,n,s)}),getInitialState:(t,n)=>({status:"active",output:void 0,error:void 0,context:"function"==typeof e?e({input:n}):e}),getPersistedState:t=>t,restoreState:t=>t}}const Zt="$$xstate.resolve",te="$$xstate.reject";const ee=Yt((t=>{}),void 0);const ne={},se=t=>"string"==typeof t?{type:t}:"function"==typeof t?"resolve"in t?{type:t.type}:{type:t.name}:t;class ie{constructor(t,n){if(this.config=t,this.key=void 0,this.id=void 0,this.type=void 0,this.path=void 0,this.states=void 0,this.history=void 0,this.entry=void 0,this.exit=void 0,this.parent=void 0,this.machine=void 0,this.meta=void 0,this.output=void 0,this.order=-1,this.description=void 0,this.tags=[],this.transitions=void 0,this.always=void 0,this.parent=n._parent,this.key=n._key,this.machine=n._machine,this.path=this.parent?this.parent.path.concat(this.key):[],this.id=this.config.id||[this.machine.id,...this.path].join(e),this.type=this.config.type||(this.config.states&&Object.keys(this.config.states).length?"compound":this.config.history?"history":"atomic"),this.description=this.config.description,this.order=this.machine.idMap.size,this.machine.idMap.set(this.id,this),this.states=this.config.states?k(this.config.states,((t,e)=>new ie(t,{_parent:this,_key:e,_machine:this.machine}))):ne,"compound"===this.type&&!this.config.initial)throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);this.history=!0===this.config.history?"shallow":this.config.history||!1,this.entry=E(this.config.entry).slice(),this.exit=E(this.config.exit).slice(),this.meta=this.config.meta,this.output="final"!==this.type&&this.parent?void 0:this.config.output,this.tags=E(t.tags).slice()}_initialize(){this.transitions=function(t){const e=new Map;if(t.config.on)for(const n of Object.keys(t.config.on)){if(n===s)throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');const i=t.config.on[n];e.set(n,M(i).map((e=>at(t,n,e))))}if(t.config.onDone){const n=`xstate.done.state.${t.id}`;e.set(n,M(t.config.onDone).map((e=>at(t,n,e))))}for(const n of t.invoke){if(n.onDone){const s=`xstate.done.actor.${n.id}`;e.set(s,M(n.onDone).map((e=>at(t,s,e))))}if(n.onError){const s=`xstate.error.actor.${n.id}`;e.set(s,M(n.onError).map((e=>at(t,s,e))))}if(n.onSnapshot){const s=`xstate.snapshot.${n.id}`;e.set(s,M(n.onSnapshot).map((e=>at(t,s,e))))}}for(const n of t.after){let t=e.get(n.eventType);t||(t=[],e.set(n.eventType,t)),t.push(n)}return e}(this),this.config.always&&(this.always=M(this.config.always).map((t=>at(this,s,t)))),Object.keys(this.states).forEach((t=>{this.states[t]._initialize()}))}get definition(){return{id:this.id,key:this.key,version:this.machine.version,type:this.type,initial:this.initial?{target:this.initial.target,source:this,actions:this.initial.actions.map(se),eventType:null,reenter:!1,toJSON:()=>({target:this.initial.target.map((t=>`#${t.id}`)),source:`#${this.id}`,actions:this.initial.actions.map(se),eventType:null})}:void 0,history:this.history,states:k(this.states,(t=>t.definition)),on:this.on,transitions:[...this.transitions.values()].flat().map((t=>({...t,actions:t.actions.map(se)}))),entry:this.entry.map(se),exit:this.exit.map(se),meta:this.meta,order:this.order||-1,output:this.output,invoke:this.invoke,description:this.description,tags:this.tags}}toJSON(){return this.definition}get invoke(){return c(this,"invoke",(()=>E(this.config.invoke).map(((t,e)=>{const{src:n,systemId:s}=t,i=t.id||`${this.id}:invocation[${e}]`;const o="string"==typeof n||"type"in n?n:i;return this.machine.implementations.actors[i]||"string"==typeof n||"type"in n||(this.machine.implementations.actors={...this.machine.implementations.actors,[i]:n}),{...t,src:o,id:i,systemId:s,toJSON(){const{onDone:e,onError:n,...s}=t;return{...s,type:"xstate.invoke",src:o,id:i}}}}))))}get on(){return c(this,"on",(()=>[...this.transitions].flatMap((([t,e])=>e.map((e=>[t,e])))).reduce(((t,[e,n])=>(t[e]=t[e]||[],t[e].push(n),t)),{})))}get after(){return c(this,"delayedTransitions",(()=>function(t){const e=t.config.after;if(!e)return[];const n=(e,n)=>{const s=(o="function"==typeof e?`${t.id}:delay[${n}]`:e,r=t.id,{type:`xstate.after(${o})${r?`#${r}`:""}`}),i=s.type;var o,r;return t.entry.push(Gt(s,{id:i,delay:e})),t.exit.push(l(i)),i};return(j(e)?e.map(((t,e)=>{const s=n(t.delay,e);return{...t,event:s}})):Object.keys(e).flatMap(((t,s)=>{const i=e[t],o="string"==typeof i?{target:i}:i,r=isNaN(+t)?t:+t,a=n(r,s);return E(o).map((t=>({...t,event:a,delay:r})))}))).map((e=>{const{delay:n}=e;return{...at(t,e.event,e),delay:n}}))}(this)))}get initial(){return c(this,"initial",(()=>function(t,n){if("string"==typeof n||j(n)){const e=E(n).map((e=>{const n="string"==typeof e?rt(e)?t.machine.getStateNodeById(e):t.states[e]:e;if(!n)throw new Error(`Initial state node "${e}" not found on parent state node #${t.id}`);if(!gt(n,t))throw new Error(`Invalid initial target: state node #${n.id} is not a descendant of #${t.id}`);return n})),s=ct(t,e),i={source:t,actions:[],eventType:null,reenter:!1,target:s,toJSON:()=>({...i,source:`#${t.id}`,target:s?s.map((t=>`#${t.id}`)):void 0})};return i}return at(t,"__INITIAL__",{target:E(n.target).map((t=>"string"==typeof t?rt(t)?t:`${e}${t}`:t)),actions:n.actions})}(this,this.config.initial||[])))}next(t,e){const n=e.type,s=[];let i;const o=c(this,`candidates-${n}`,(()=>{return e=n,(t=this).transitions.get(e)||[...t.transitions.keys()].filter((t=>{if("*"===t)return!0;if(!t.endsWith(".*"))return!1;const n=t.split("."),s=e.split(".");for(let t=0;t<n.length;t++){const e=n[t],i=s[t];if("*"===e)return t===n.length-1;if(e!==i)return!1}return!0})).sort(((t,e)=>e.length-t.length)).flatMap((e=>t.transitions.get(e)));var t,e}));for(const r of o){const{guard:o}=r,a=t.context;let c=!1;try{c=!o||K(o,a,e,t)}catch(t){const e="string"==typeof o?o:"object"==typeof o?o.type:void 0;throw new Error(`Unable to evaluate guard ${e?`'${e}' `:""}in transition for event '${n}' in state node '${this.id}':\n${t.message}`)}if(c){s.push(...r.actions),i=r;break}}return i?[i]:void 0}get events(){return c(this,"events",(()=>{const{states:t}=this,e=new Set(this.ownEvents);if(t)for(const n of Object.keys(t)){const s=t[n];if(s.states)for(const t of s.events)e.add(`${t}`)}return Array.from(e)}))}get ownEvents(){const t=new Set([...this.transitions.keys()].filter((t=>this.transitions.get(t).some((t=>!(!t.target&&!t.actions.length&&!t.reenter))))));return Array.from(t)}}class oe{constructor(t,e){this.config=t,this.version=void 0,this.implementations=void 0,this.types=void 0,this.__xstatenode=!0,this.idMap=new Map,this.root=void 0,this.id=void 0,this.states=void 0,this.events=void 0,this.__TContext=void 0,this.__TEvent=void 0,this.__TActor=void 0,this.__TAction=void 0,this.__TGuard=void 0,this.__TDelay=void 0,this.__TTag=void 0,this.__TInput=void 0,this.__TOutput=void 0,this.__TResolvedTypesMeta=void 0,this.id=t.id||"(machine)",this.implementations={actors:e?.actors??{},actions:e?.actions??{},delays:e?.delays??{},guards:e?.guards??{}},this.version=this.config.version,this.types=this.config.types??{},this.transition=this.transition.bind(this),this.getInitialState=this.getInitialState.bind(this),this.restoreState=this.restoreState.bind(this),this.start=this.start.bind(this),this.getPersistedState=this.getPersistedState.bind(this),this.root=new ie(t,{_key:this.id,_machine:this}),this.root._initialize(),this.states=this.root.states,this.events=this.root.events}provide(t){const{actions:e,guards:n,actors:s,delays:i}=this.implementations;return new oe(this.config,{actions:{...e,...t.actions},guards:{...n,...t.guards},actors:{...s,...t.actors},delays:{...i,...t.delays}})}resolveState(t){const e=et(lt(this.root,t.value)),n=Array.from(e);return this.createState({...t,value:Nt(this.root,t.value),configuration:n,status:ot(n)?"done":t.status})}resolveStateValue(t,...[e]){const n=Nt(this.root,t);return this.resolveState(Rt.from(n,e,this))}transition(t,e,n){if(function(t){return t.type.startsWith("xstate.error.actor")}(e)&&!t.nextEvents.some((t=>t===e.type)))return Ct(t,{status:"error",error:e.data});const{state:s}=Ot(t,e,n);return s}microstep(t,e,n){return Ot(t,e,n).microstates}getTransitionData(t,e){return yt(this.root,t.value,t,e)||[]}getPreInitialState(t,e){const{context:n}=this.config,s=this.resolveState(this.createState({value:{},context:"function"!=typeof n&&n?n:{},meta:void 0,configuration:At(this.root),children:{},status:"active"}));if("function"==typeof n){return Et([Vt((({spawn:t,event:e})=>n({spawn:t,input:e.input})))],e,s,t)}return s}getInitialState(t,e){const n=f(e),s=this.getPreInitialState(t,n),i=$t([{target:[...s.configuration].filter(Y),source:this.root,reenter:!0,actions:[],eventType:null,toJSON:null}],s,t,n,!0),{state:o}=Ot(i,n,t);return o}start(t){Object.values(t.children).forEach((t=>{0===t.status&&t.start?.()}))}getStateNodeById(t){const n=t.split(e),s=n.slice(1),i=rt(n[0])?n[0].slice(1):n[0],o=this.idMap.get(i);if(!o)throw new Error(`Child state node '#${i}' does not exist on machine '${this.id}'`);return pt(o,s)}get definition(){return this.root.definition}toJSON(){return this.definition}getPersistedState(t){return function(t){const{configuration:e,tags:n,machine:s,children:i,...o}=t,r={};for(const t in i){const e=i[t];r[t]={state:e.getPersistedState?.(),src:e.src}}return{...o,children:r}}(t)}createState(t){return t instanceof Rt?t:new Rt(t,this)}restoreState(t,e){const n={};return Object.keys(t.children).forEach((s=>{const i=t.children[s],o=i.state,r=i.src,a=r?A(this.implementations.actors[r])?.src:void 0;if(!a)return;const c=a.restoreState?.(o,e),u=V(a,{id:s,parent:e?.self,state:c});n[s]=u})),this.createState(new Rt({...t,children:n},this))}}const re={timeout:1e4};t.Actor=Q,t.ActorStatus=R,t.InterpreterStatus=C,t.SimulatedClock=class{constructor(){this.timeouts=new Map,this._now=0,this._id=0}now(){return this._now}getId(){return this._id++}setTimeout(t,e){const n=this.getId();return this.timeouts.set(n,{start:this.now(),timeout:e,fn:t}),n}clearTimeout(t){this.timeouts.delete(t)}set(t){if(this._now>t)throw new Error("Unable to travel back in time");this._now=t,this.flushTimeouts()}flushTimeouts(){[...this.timeouts].sort((([t,e],[n,s])=>{const i=e.start+e.timeout;return s.start+s.timeout>i?-1:1})).forEach((([t,e])=>{this.now()-e.start>=e.timeout&&(this.timeouts.delete(t),e.fn.call(null))}))}increment(t){this._now+=t,this.flushTimeouts()}},t.SpecialTargets=Ft,t.State=Rt,t.StateMachine=oe,t.StateNode=ie,t.and=function(t){function e(t){return!1}return e.check=X,e.guards=t,e},t.assign=Vt,t.cancel=l,t.choose=function(t){function e(t){}return e.type="xstate.choose",e.branches=t,e.resolve=Jt,e},t.createActor=V,t.createEmptyActor=function(){return V(ee)},t.createMachine=function(t,e){return new oe(t,e)},t.escalate=function(t,e){return Kt((e=>({type:o,data:"function"==typeof t?t(e):t})),e)},t.forwardTo=function(t,e){return Ht(t,(({event:t})=>t),e)},t.fromCallback=function(t){return{config:t,start:(t,{self:e,system:n})=>{n._relay(e,e,{type:i})},transition:(e,n,{self:s,system:o})=>{if(n.type===i){const n=t=>{"stopped"!==e.status&&s._parent&&o._relay(s,s._parent,t)},i=t=>{e._receivers.add(t)};return e._dispose=t({input:e.input,system:o,self:s,sendBack:n,receive:i}),e}return n.type===r?("function"==typeof(e={...e,status:"stopped",error:void 0})._dispose&&e._dispose(),e):(e._receivers.forEach((t=>t(n))),e)},getInitialState:(t,e)=>({status:"active",output:void 0,error:void 0,input:e,_receivers:new Set,_dispose:void 0}),getPersistedState:({_dispose:t,_receivers:e,...n})=>n,restoreState:t=>({_receivers:new Set,_dispose:void 0,...t})}},t.fromEventObservable=function(t){const e="$$xstate.error",n="$$xstate.complete";return{config:t,transition:(t,s)=>{if("active"!==t.status)return t;switch(s.type){case e:return{...t,status:"error",error:s.data,input:void 0,_subscription:void 0};case n:return{...t,status:"done",input:void 0,_subscription:void 0};case r:return t._subscription.unsubscribe(),{...t,status:"stopped",input:void 0,_subscription:void 0};default:return t}},getInitialState:(t,e)=>({status:"active",output:void 0,error:void 0,context:void 0,input:e,_subscription:void 0}),start:(s,{self:i,system:o})=>{"done"!==s.status&&(s._subscription=t({input:s.input,system:o,self:i}).subscribe({next:t=>{i._parent&&o._relay(i,i._parent,t)},error:t=>{o._relay(i,i,{type:e,data:t})},complete:()=>{o._relay(i,i,{type:n})}}))},getPersistedState:({_subscription:t,...e})=>e,restoreState:t=>({...t,_subscription:void 0})}},t.fromObservable=function(t){const e="$$xstate.next",n="$$xstate.error",s="$$xstate.complete";return{config:t,transition:(t,i,{self:o,id:a,defer:c,system:u})=>{if("active"!==t.status)return t;switch(i.type){case e:return{...t,context:i.data};case n:return{...t,status:"error",error:i.data,input:void 0,_subscription:void 0};case s:return{...t,status:"done",input:void 0,_subscription:void 0};case r:return t._subscription.unsubscribe(),{...t,status:"stopped",input:void 0,_subscription:void 0};default:return t}},getInitialState:(t,e)=>({status:"active",output:void 0,error:void 0,context:void 0,input:e,_subscription:void 0}),start:(i,{self:o,system:r})=>{"done"!==i.status&&(i._subscription=t({input:i.input,system:r,self:o}).subscribe({next:t=>{r._relay(o,o,{type:e,data:t})},error:t=>{r._relay(o,o,{type:n,data:t})},complete:()=>{r._relay(o,o,{type:s})}}))},getPersistedState:({_subscription:t,...e})=>e,restoreState:t=>({...t,_subscription:void 0})}},t.fromPromise=function(t){return{config:t,transition:(t,e)=>{if("active"!==t.status)return t;switch(e.type){case Zt:{const n=e.data;return{...t,status:"done",output:n,input:void 0}}case te:return{...t,status:"error",error:e.data,input:void 0};case r:return{...t,status:"stopped",input:void 0};default:return t}},start:(e,{self:n,system:s})=>{if("active"!==e.status)return;Promise.resolve(t({input:e.input,system:s,self:n})).then((t=>{"active"===n.getSnapshot().status&&s._relay(n,n,{type:Zt,data:t})}),(t=>{"active"===n.getSnapshot().status&&s._relay(n,n,{type:te,data:t})}))},getInitialState:(t,e)=>({status:"active",output:void 0,error:void 0,input:e}),getPersistedState:t=>t,restoreState:t=>t}},t.fromTransition=Yt,t.getStateNodes=lt,t.interpret=J,t.log=function(t=(({context:t,event:e})=>({context:t,event:e})),e){function n(t){}return n.type="xstate.log",n.value=t,n.label=e,n.resolve=Bt,n.execute=zt,n},t.mapState=function(t,e){let n;for(const s of Object.keys(t))b(s,e)&&(!n||e.length>n.length)&&(n=s);return t[n]},t.matchesState=b,t.not=function(t){function e(t){return!1}return e.check=L,e.guards=[t],e},t.or=function(t){function e(t){return!1}return e.check=H,e.guards=t,e},t.pathToStateValue=$,t.pure=function(t){function e(t){}return e.type="xstate.pure",e.get=t,e.resolve=Ut,e},t.raise=Gt,t.sendParent=Kt,t.sendTo=Ht,t.stateIn=function(t){function e(t){return!1}return e.check=F,e.stateValue=t,e},t.stop=G,t.toObserver=N,t.waitFor=function(t,e,n){const s={...re,...n};return new Promise(((n,i)=>{let o=!1;const r=s.timeout===1/0?void 0:setTimeout((()=>{u.unsubscribe(),i(new Error(`Timeout of ${s.timeout} ms exceeded`))}),s.timeout),a=()=>{clearTimeout(r),o=!0,u?.unsubscribe()};function c(t){e(t)&&(a(),n(t))}let u;c(t.getSnapshot()),o||(u=t.subscribe({next:c,error:t=>{a(),i(t)},complete:()=>{a(),i(new Error("Actor terminated without satisfying predicate"))}}),o&&u.unsubscribe())}))},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=xstate.umd.min.js.map
