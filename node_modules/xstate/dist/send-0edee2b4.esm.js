import { j as cloneState, e as evaluateGuard } from './raise-2d92eae8.esm.js';
import { f as ActorStatus, k as createErrorActorEvent, r as resolveReferencedActor, d as createActor, t as toArray, y as XSTATE_ERROR } from './interpreter-03737810.esm.js';

function createSpawner(actorContext, {
  machine,
  context
}, event, spawnedChildren) {
  const spawn = (src, options = {}) => {
    const {
      systemId
    } = options;
    if (typeof src === 'string') {
      const referenced = resolveReferencedActor(machine.implementations.actors[src]);
      if (!referenced) {
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      }
      const input = 'input' in options ? options.input : referenced.input;

      // TODO: this should also receive `src`
      const actorRef = createActor(referenced.src, {
        id: options.id,
        parent: actorContext.self,
        input: typeof input === 'function' ? input({
          context,
          event,
          self: actorContext.self
        }) : input,
        systemId
      });
      spawnedChildren[actorRef.id] = actorRef;
      if (options.syncSnapshot) {
        actorRef.subscribe({
          next: snapshot => {
            if (snapshot.status === 'active') {
              actorContext.self.send({
                type: `xstate.snapshot.${actorRef.id}`,
                snapshot
              });
            }
          },
          error: () => {
            /* TODO */
          }
        });
      }
      return actorRef;
    } else {
      // TODO: this should also receive `src`
      const actorRef = createActor(src, {
        id: options.id,
        parent: actorContext.self,
        input: options.input,
        systemId
      });
      if (options.syncSnapshot) {
        actorRef.subscribe({
          next: snapshot => {
            if (snapshot.status === 'active') {
              actorContext.self.send({
                type: `xstate.snapshot.${actorRef.id}`,
                snapshot,
                id: actorRef.id
              });
            }
          },
          error: () => {
            /* TODO */
          }
        });
      }
      return actorRef;
    }
  };
  return (src, options) => {
    const actorRef = spawn(src, options); // TODO: fix types
    spawnedChildren[actorRef.id] = actorRef;
    actorContext.defer(() => {
      if (actorRef.status === ActorStatus.Stopped) {
        return;
      }
      try {
        actorRef.start?.();
      } catch (err) {
        actorContext.self.send(createErrorActorEvent(actorRef.id, err));
        return;
      }
    });
    return actorRef;
  };
}

function resolveAssign(actorContext, state, actionArgs, {
  assignment
}) {
  if (!state.context) {
    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');
  }
  const spawnedChildren = {};
  const assignArgs = {
    context: state.context,
    event: actionArgs.event,
    action: actionArgs.action,
    spawn: createSpawner(actorContext, state, actionArgs.event, spawnedChildren),
    self: actorContext?.self,
    system: actorContext?.system
  };
  let partialUpdate = {};
  if (typeof assignment === 'function') {
    partialUpdate = assignment(assignArgs);
  } else {
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key];
      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs) : propAssignment;
    }
  }
  const updatedContext = Object.assign({}, state.context, partialUpdate);
  return [cloneState(state, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? {
      ...state.children,
      ...spawnedChildren
    } : state.children
  })];
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */
function assign(assignment) {
  function assign(_) {
  }
  assign.type = 'xstate.assign';
  assign.assignment = assignment;
  assign.resolve = resolveAssign;
  return assign;
}

function resolveChoose(_, state, actionArgs, {
  branches
}) {
  const matchedActions = branches.find(condition => {
    return !condition.guard || evaluateGuard(condition.guard, state.context, actionArgs.event, state);
  })?.actions;
  return [state, undefined, toArray(matchedActions)];
}
function choose(branches) {
  function choose(_) {
  }
  choose.type = 'xstate.choose';
  choose.branches = branches;
  choose.resolve = resolveChoose;
  return choose;
}

function resolveLog(_, state, actionArgs, {
  value,
  label
}) {
  return [state, {
    value: typeof value === 'function' ? value(actionArgs) : value,
    label
  }];
}
function executeLog({
  logger
}, {
  value,
  label
}) {
  if (label) {
    logger(label, value);
  } else {
    logger(value);
  }
}
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */
function log(value = ({
  context,
  event
}) => ({
  context,
  event
}), label) {
  function log(_) {
  }
  log.type = 'xstate.log';
  log.value = value;
  log.label = label;
  log.resolve = resolveLog;
  log.execute = executeLog;
  return log;
}

function resolvePure(_, state, args, {
  get
}) {
  return [state, undefined, toArray(get({
    context: args.context,
    event: args.event
  }))];
}
function pure(getActions) {
  function pure(_) {
  }
  pure.type = 'xstate.pure';
  pure.get = getActions;
  pure.resolve = resolvePure;
  return pure;
}

/**
 * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.
 * It especially is a problem when the union has a function member, like here:
 *
 * ```ts
 * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;
 * test((arg) => {}) // oops, implicit any
 * ```
 *
 * This type can be used to avoid this problem. This union represents the same value space as `unknown`.
 */

// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887

/**
 * The full definition of an event, with a string `type`.
 */

/**
 * The string or object representing the state value relative to the parent state node.
 *
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
 */

// TODO: remove once TS fixes this type-widening issue

// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something

let SpecialTargets = /*#__PURE__*/function (SpecialTargets) {
  SpecialTargets["Parent"] = "#_parent";
  SpecialTargets["Internal"] = "#_internal";
  return SpecialTargets;
}({});

function resolveSendTo(actorContext, state, args, {
  to,
  event: eventOrExpr,
  id,
  delay
}) {
  const delaysMap = state.machine.implementations.delays;
  if (typeof eventOrExpr === 'string') {
    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`);
  }
  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay === 'string') {
    const configDelay = delaysMap && delaysMap[delay];
    resolvedDelay = typeof configDelay === 'function' ? configDelay(args) : configDelay;
  } else {
    resolvedDelay = typeof delay === 'function' ? delay(args) : delay;
  }
  const resolvedTarget = typeof to === 'function' ? to(args) : to;
  let targetActorRef;
  if (typeof resolvedTarget === 'string') {
    if (resolvedTarget === SpecialTargets.Parent) {
      targetActorRef = actorContext?.self._parent;
    } else if (resolvedTarget === SpecialTargets.Internal) {
      targetActorRef = actorContext?.self;
    } else if (resolvedTarget.startsWith('#_')) {
      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor
      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.
      targetActorRef = state.children[resolvedTarget.slice(2)];
    } else {
      targetActorRef = state.children[resolvedTarget];
    }
    if (!targetActorRef) {
      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${state.machine.id}'.`);
    }
  } else {
    targetActorRef = resolvedTarget || actorContext?.self;
  }
  return [state, {
    to: targetActorRef,
    event: resolvedEvent,
    id,
    delay: resolvedDelay
  }];
}
function executeSendTo(actorContext, params) {
  if (typeof params.delay === 'number') {
    actorContext.self.delaySend(params);
    return;
  }
  const {
    to,
    event
  } = params;
  actorContext.defer(() => {
    actorContext?.system._relay(actorContext.self, to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorContext.self.id, event.data) : event);
  });
}
/**
 * Sends an event to an actor.
 *
 * @param actor The `ActorRef` to send the event to.
 * @param event The event to send, or an expression that evaluates to the event to send
 * @param options Send action options
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 */
function sendTo(to, eventOrExpr, options) {
  function sendTo(_) {
  }
  sendTo.type = 'xstate.sendTo';
  sendTo.to = to;
  sendTo.event = eventOrExpr;
  sendTo.id = options?.id;
  sendTo.delay = options?.delay;
  sendTo.resolve = resolveSendTo;
  sendTo.execute = executeSendTo;
  return sendTo;
}

/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */
function sendParent(event, options) {
  return sendTo(SpecialTargets.Parent, event, options);
}
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */
function forwardTo(target, options) {
  return sendTo(target, ({
    event
  }) => event, options);
}

/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */
function escalate(errorData, options) {
  return sendParent(arg => {
    return {
      type: XSTATE_ERROR,
      data: typeof errorData === 'function' ? errorData(arg) : errorData
    };
  }, options);
}

export { SpecialTargets as S, assign as a, sendTo as b, choose as c, escalate as e, forwardTo as f, log as l, pure as p, sendParent as s };
