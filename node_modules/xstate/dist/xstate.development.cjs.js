'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var actors_dist_xstateActors = require('../actors/dist/xstate-actors.development.cjs.js');
var interpreter = require('./interpreter-0c630f66.development.cjs.js');
var guards_dist_xstateGuards = require('./raise-4c6a5a96.development.cjs.js');
var send = require('./send-0e8675c8.development.cjs.js');
require('../dev/dist/xstate-dev.development.cjs.js');

class SimulatedClock {
  constructor() {
    this.timeouts = new Map();
    this._now = 0;
    this._id = 0;
  }
  now() {
    return this._now;
  }
  getId() {
    return this._id++;
  }
  setTimeout(fn, timeout) {
    const id = this.getId();
    this.timeouts.set(id, {
      start: this.now(),
      timeout,
      fn
    });
    return id;
  }
  clearTimeout(id) {
    this.timeouts.delete(id);
  }
  set(time) {
    if (this._now > time) {
      throw new Error('Unable to travel back in time');
    }
    this._now = time;
    this.flushTimeouts();
  }
  flushTimeouts() {
    [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {
      const endA = timeoutA.start + timeoutA.timeout;
      const endB = timeoutB.start + timeoutB.timeout;
      return endB > endA ? -1 : 1;
    }).forEach(([id, timeout]) => {
      if (this.now() - timeout.start >= timeout.timeout) {
        this.timeouts.delete(id);
        timeout.fn.call(null);
      }
    });
  }
  increment(ms) {
    this._now += ms;
    this.flushTimeouts();
  }
}

const EMPTY_OBJECT = {};
const toSerializableAction = action => {
  if (typeof action === 'string') {
    return {
      type: action
    };
  }
  if (typeof action === 'function') {
    if ('resolve' in action) {
      return {
        type: action.type
      };
    }
    return {
      type: action.name
    };
  }
  return action;
};
class StateNode {
  /**
   * The relative key of the state node, which represents its location in the overall state value.
   */

  /**
   * The unique ID of the state node.
   */

  /**
   * The type of this state node:
   *
   *  - `'atomic'` - no child state nodes
   *  - `'compound'` - nested child state nodes (XOR)
   *  - `'parallel'` - orthogonal nested child state nodes (AND)
   *  - `'history'` - history state node
   *  - `'final'` - final state node
   */

  /**
   * The string path from the root machine node to this node.
   */

  /**
   * The child state nodes.
   */

  /**
   * The type of history on this state node. Can be:
   *
   *  - `'shallow'` - recalls only top-level historical state value
   *  - `'deep'` - recalls historical state value at all levels
   */

  /**
   * The action(s) to be executed upon entering the state node.
   */

  /**
   * The action(s) to be executed upon exiting the state node.
   */

  /**
   * The parent state node.
   */

  /**
   * The root machine node.
   */

  /**
   * The meta data associated with this state node, which will be returned in State instances.
   */

  /**
   * The output data sent with the "xstate.done.state._id_" event if this is a final state node.
   */

  /**
   * The order this state node appears. Corresponds to the implicit document order.
   */

  constructor(
  /**
   * The raw config used to create the machine.
   */
  config, options) {
    this.config = config;
    this.key = void 0;
    this.id = void 0;
    this.type = void 0;
    this.path = void 0;
    this.states = void 0;
    this.history = void 0;
    this.entry = void 0;
    this.exit = void 0;
    this.parent = void 0;
    this.machine = void 0;
    this.meta = void 0;
    this.output = void 0;
    this.order = -1;
    this.description = void 0;
    this.tags = [];
    this.transitions = void 0;
    this.always = void 0;
    this.parent = options._parent;
    this.key = options._key;
    this.machine = options._machine;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.id = this.config.id || [this.machine.id, ...this.path].join(interpreter.STATE_DELIMITER);
    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');
    this.description = this.config.description;
    this.order = this.machine.idMap.size;
    this.machine.idMap.set(this.id, this);
    this.states = this.config.states ? interpreter.mapValues(this.config.states, (stateConfig, key) => {
      const stateNode = new StateNode(stateConfig, {
        _parent: this,
        _key: key,
        _machine: this.machine
      });
      return stateNode;
    }) : EMPTY_OBJECT;
    if (this.type === 'compound' && !this.config.initial) {
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    }

    // History config
    this.history = this.config.history === true ? 'shallow' : this.config.history || false;
    this.entry = interpreter.toArray(this.config.entry).slice();
    this.exit = interpreter.toArray(this.config.exit).slice();
    this.meta = this.config.meta;
    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;
    this.tags = interpreter.toArray(config.tags).slice();
  }
  _initialize() {
    this.transitions = guards_dist_xstateGuards.formatTransitions(this);
    if (this.config.always) {
      this.always = interpreter.toTransitionConfigArray(this.config.always).map(t => guards_dist_xstateGuards.formatTransition(this, interpreter.NULL_EVENT, t));
    }
    Object.keys(this.states).forEach(key => {
      this.states[key]._initialize();
    });
  }

  /**
   * The well-structured state node definition.
   */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: false,
        toJSON: () => ({
          target: this.initial.target.map(t => `#${t.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : undefined,
      history: this.history,
      states: interpreter.mapValues(this.states, state => {
        return state.definition;
      }),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map(t => ({
        ...t,
        actions: t.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  toJSON() {
    return this.definition;
  }

  /**
   * The logic invoked as actors by this state node.
   */
  get invoke() {
    return guards_dist_xstateGuards.memo(this, 'invoke', () => interpreter.toArray(this.config.invoke).map((invokeConfig, i) => {
      const {
        src,
        systemId
      } = invokeConfig;
      const resolvedId = invokeConfig.id || interpreter.createInvokeId(this.id, i);
      // TODO: resolving should not happen here
      const resolvedSrc = typeof src === 'string' ? src : !('type' in src) ? resolvedId : src;
      if (!this.machine.implementations.actors[resolvedId] && typeof src !== 'string' && !('type' in src)) {
        this.machine.implementations.actors = {
          ...this.machine.implementations.actors,
          // TODO: this should accept `src` as-is
          [resolvedId]: src
        };
      }
      return {
        ...invokeConfig,
        src: resolvedSrc,
        id: resolvedId,
        systemId: systemId,
        toJSON() {
          const {
            onDone,
            onError,
            ...invokeDefValues
          } = invokeConfig;
          return {
            ...invokeDefValues,
            type: 'xstate.invoke',
            src: resolvedSrc,
            id: resolvedId
          };
        }
      };
    }));
  }

  /**
   * The mapping of events to transitions.
   */
  get on() {
    return guards_dist_xstateGuards.memo(this, 'on', () => {
      const transitions = this.transitions;
      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {
        map[descriptor] = map[descriptor] || [];
        map[descriptor].push(transition);
        return map;
      }, {});
    });
  }
  get after() {
    return guards_dist_xstateGuards.memo(this, 'delayedTransitions', () => guards_dist_xstateGuards.getDelayedTransitions(this));
  }
  get initial() {
    return guards_dist_xstateGuards.memo(this, 'initial', () => guards_dist_xstateGuards.formatInitialTransition(this, this.config.initial || []));
  }
  next(state, event) {
    const eventType = event.type;
    const actions = [];
    let selectedTransition;
    const candidates = guards_dist_xstateGuards.memo(this, `candidates-${eventType}`, () => guards_dist_xstateGuards.getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate;
      const resolvedContext = state.context;
      let guardPassed = false;
      try {
        guardPassed = !guard || guards_dist_xstateGuards.evaluateGuard(guard, resolvedContext, event, state);
      } catch (err) {
        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\n${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions);
        selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : undefined;
  }

  /**
   * All the event types accepted by this state node and its descendants.
   */
  get events() {
    return guards_dist_xstateGuards.memo(this, 'events', () => {
      const {
        states
      } = this;
      const events = new Set(this.ownEvents);
      if (states) {
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states) {
            for (const event of state.events) {
              events.add(`${event}`);
            }
          }
        }
      }
      return Array.from(events);
    });
  }

  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter(descriptor => {
      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));
    }));
    return Array.from(events);
  }
}

const STATE_IDENTIFIER = '#';
class StateMachine {
  /**
   * The machine's own version.
   */

  constructor(
  /**
   * The raw config used to create the machine.
   */
  config, implementations) {
    this.config = config;
    this.version = void 0;
    this.implementations = void 0;
    this.types = void 0;
    this.__xstatenode = true;
    this.idMap = new Map();
    this.root = void 0;
    this.id = void 0;
    this.states = void 0;
    this.events = void 0;
    this.__TContext = void 0;
    this.__TEvent = void 0;
    this.__TActor = void 0;
    this.__TAction = void 0;
    this.__TGuard = void 0;
    this.__TDelay = void 0;
    this.__TTag = void 0;
    this.__TInput = void 0;
    this.__TOutput = void 0;
    this.__TResolvedTypesMeta = void 0;
    this.id = config.id || '(machine)';
    this.implementations = {
      actors: implementations?.actors ?? {},
      actions: implementations?.actions ?? {},
      delays: implementations?.delays ?? {},
      guards: implementations?.guards ?? {}
    };
    this.version = this.config.version;
    this.types = this.config.types ?? {};
    this.transition = this.transition.bind(this);
    this.getInitialState = this.getInitialState.bind(this);
    this.restoreState = this.restoreState.bind(this);
    this.start = this.start.bind(this);
    this.getPersistedState = this.getPersistedState.bind(this);
    this.root = new StateNode(config, {
      _key: this.id,
      _machine: this
    });
    this.root._initialize();
    this.states = this.root.states; // TODO: remove!
    this.events = this.root.events;
    if (!this.root.output && Object.values(this.states).some(state => state.type === 'final' && !!state.output)) {
      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');
    }
  }

  /**
   * Clones this state machine with the provided implementations
   * and merges the `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
   *  to recursively merge with the existing options.
   *
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions
      },
      guards: {
        ...guards,
        ...implementations.guards
      },
      actors: {
        ...actors,
        ...implementations.actors
      },
      delays: {
        ...delays,
        ...implementations.delays
      }
    });
  }

  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */
  resolveState(state) {
    const configurationSet = guards_dist_xstateGuards.getConfiguration(guards_dist_xstateGuards.getStateNodes(this.root, state.value));
    const configuration = Array.from(configurationSet);
    return this.createState({
      ...state,
      value: guards_dist_xstateGuards.resolveStateValue(this.root, state.value),
      configuration,
      status: guards_dist_xstateGuards.isInFinalState(configuration) ? 'done' : state.status
    });
  }
  resolveStateValue(stateValue, ...[context]) {
    const resolvedStateValue = guards_dist_xstateGuards.resolveStateValue(this.root, stateValue);
    return this.resolveState(guards_dist_xstateGuards.State.from(resolvedStateValue, context, this));
  }

  /**
   * Determines the next state given the current `state` and received `event`.
   * Calculates a full macrostep from all microsteps.
   *
   * @param state The current State instance or state value
   * @param event The received event
   */
  transition(state, event, actorCtx) {
    // TODO: handle error events in a better way
    if (interpreter.isErrorActorEvent(event) && !state.nextEvents.some(nextEvent => nextEvent === event.type)) {
      return guards_dist_xstateGuards.cloneState(state, {
        status: 'error',
        error: event.data
      });
    }
    const {
      state: nextState
    } = guards_dist_xstateGuards.macrostep(state, event, actorCtx);
    return nextState;
  }

  /**
   * Determines the next state given the current `state` and `event`.
   * Calculates a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(state, event, actorCtx) {
    return guards_dist_xstateGuards.macrostep(state, event, actorCtx).microstates;
  }
  getTransitionData(state, event) {
    return guards_dist_xstateGuards.transitionNode(this.root, state.value, state, event) || [];
  }

  /**
   * The initial state _before_ evaluating any microsteps.
   * This "pre-initial" state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorCtx, initEvent) {
    const {
      context
    } = this.config;
    const preInitial = this.resolveState(this.createState({
      value: {},
      // TODO: this is computed in state constructor
      context: typeof context !== 'function' && context ? context : {},
      meta: undefined,
      configuration: guards_dist_xstateGuards.getInitialConfiguration(this.root),
      children: {},
      status: 'active'
    }));
    if (typeof context === 'function') {
      const assignment = ({
        spawn,
        event
      }) => context({
        spawn,
        input: event.input
      });
      return guards_dist_xstateGuards.resolveActionsAndContext([send.assign(assignment)], initEvent, preInitial, actorCtx);
    }
    return preInitial;
  }

  /**
   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
   */
  getInitialState(actorCtx, input) {
    const initEvent = interpreter.createInitEvent(input); // TODO: fix;

    const preInitialState = this.getPreInitialState(actorCtx, initEvent);
    const nextState = guards_dist_xstateGuards.microstep([{
      target: [...preInitialState.configuration].filter(guards_dist_xstateGuards.isAtomicStateNode),
      source: this.root,
      reenter: true,
      actions: [],
      eventType: null,
      toJSON: null // TODO: fix
    }], preInitialState, actorCtx, initEvent, true);
    const {
      state: macroState
    } = guards_dist_xstateGuards.macrostep(nextState, initEvent, actorCtx);
    return macroState;
  }
  start(state) {
    Object.values(state.children).forEach(child => {
      if (child.status === 0) {
        child.start?.();
      }
    });
  }
  getStateNodeById(stateId) {
    const fullPath = stateId.split(interpreter.STATE_DELIMITER);
    const relativePath = fullPath.slice(1);
    const resolvedStateId = guards_dist_xstateGuards.isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];
    const stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode) {
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    }
    return guards_dist_xstateGuards.getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedState(state) {
    return guards_dist_xstateGuards.getPersistedState(state);
  }
  createState(stateConfig) {
    return stateConfig instanceof guards_dist_xstateGuards.State ? stateConfig : new guards_dist_xstateGuards.State(stateConfig, this);
  }
  restoreState(snapshot, _actorCtx) {
    const children = {};
    Object.keys(snapshot.children).forEach(actorId => {
      const actorData = snapshot.children[actorId];
      const childState = actorData.state;
      const src = actorData.src;
      const logic = src ? interpreter.resolveReferencedActor(this.implementations.actors[src])?.src : undefined;
      if (!logic) {
        return;
      }
      const actorState = logic.restoreState?.(childState, _actorCtx);
      const actorRef = interpreter.createActor(logic, {
        id: actorId,
        parent: _actorCtx?.self,
        state: actorState
      });
      children[actorId] = actorRef;
    });
    return this.createState(new guards_dist_xstateGuards.State({
      ...snapshot,
      children
    }, this));
  }

  /**@deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
}

const defaultWaitForOptions = {
  timeout: 10_000 // 10 seconds
};

/**
 * Subscribes to an actor ref and waits for its emitted value to satisfy
 * a predicate, and then resolves with that value.
 * Will throw if the desired state is not reached after a timeout
 * (defaults to 10 seconds).
 *
 * @example
 * ```js
 * const state = await waitFor(someService, state => {
 *   return state.hasTag('loaded');
 * });
 *
 * state.hasTag('loaded'); // true
 * ```
 *
 * @param actorRef The actor ref to subscribe to
 * @param predicate Determines if a value matches the condition to wait for
 * @param options
 * @returns A promise that eventually resolves to the emitted value
 * that matches the condition
 */
function waitFor(actorRef, predicate, options) {
  const resolvedOptions = {
    ...defaultWaitForOptions,
    ...options
  };
  return new Promise((res, rej) => {
    let done = false;
    if (resolvedOptions.timeout < 0) {
      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');
    }
    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {
      sub.unsubscribe();
      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
    }, resolvedOptions.timeout);
    const dispose = () => {
      clearTimeout(handle);
      done = true;
      sub?.unsubscribe();
    };
    function checkEmitted(emitted) {
      if (predicate(emitted)) {
        dispose();
        res(emitted);
      }
    }
    let sub; // avoid TDZ when disposing synchronously

    // See if the current snapshot already matches the predicate
    checkEmitted(actorRef.getSnapshot());
    if (done) {
      return;
    }
    sub = actorRef.subscribe({
      next: checkEmitted,
      error: err => {
        dispose();
        rej(err);
      },
      complete: () => {
        dispose();
        rej(new Error(`Actor terminated without satisfying predicate`));
      }
    });
    if (done) {
      sub.unsubscribe();
    }
  });
}

function createMachine(config, implementations) {
  return new StateMachine(config, implementations);
}

function mapState(stateMap, stateId) {
  let foundStateId;
  for (const mappedStateId of Object.keys(stateMap)) {
    if (interpreter.matchesState(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) {
      foundStateId = mappedStateId;
    }
  }
  return stateMap[foundStateId];
}

exports.createEmptyActor = actors_dist_xstateActors.createEmptyActor;
exports.fromCallback = actors_dist_xstateActors.fromCallback;
exports.fromEventObservable = actors_dist_xstateActors.fromEventObservable;
exports.fromObservable = actors_dist_xstateActors.fromObservable;
exports.fromPromise = actors_dist_xstateActors.fromPromise;
exports.fromTransition = actors_dist_xstateActors.fromTransition;
exports.Actor = interpreter.Actor;
exports.ActorStatus = interpreter.ActorStatus;
exports.InterpreterStatus = interpreter.InterpreterStatus;
exports.createActor = interpreter.createActor;
exports.interpret = interpreter.interpret;
exports.matchesState = interpreter.matchesState;
exports.pathToStateValue = interpreter.pathToStateValue;
exports.toObserver = interpreter.toObserver;
exports.State = guards_dist_xstateGuards.State;
exports.and = guards_dist_xstateGuards.and;
exports.cancel = guards_dist_xstateGuards.cancel;
exports.getStateNodes = guards_dist_xstateGuards.getStateNodes;
exports.not = guards_dist_xstateGuards.not;
exports.or = guards_dist_xstateGuards.or;
exports.raise = guards_dist_xstateGuards.raise;
exports.stateIn = guards_dist_xstateGuards.stateIn;
exports.stop = guards_dist_xstateGuards.stop;
exports.SpecialTargets = send.SpecialTargets;
exports.assign = send.assign;
exports.choose = send.choose;
exports.escalate = send.escalate;
exports.forwardTo = send.forwardTo;
exports.log = send.log;
exports.pure = send.pure;
exports.sendParent = send.sendParent;
exports.sendTo = send.sendTo;
exports.SimulatedClock = SimulatedClock;
exports.StateMachine = StateMachine;
exports.StateNode = StateNode;
exports.createMachine = createMachine;
exports.mapState = mapState;
exports.waitFor = waitFor;
