import { State } from "./State.js";
import { StateNode } from "./StateNode.js";
import type { AreAllImplementationsAssumedToBeProvided, MarkAllImplementationsAsProvided, ResolveTypegenMeta, TypegenDisabled } from "./typegenTypes.js";
import type { ActorContext, ActorLogic, EventObject, InternalMachineImplementations, MachineConfig, MachineContext, MachineImplementationsSimplified, MachineTypes, NoInfer, StateConfig, StateMachineDefinition, StateValue, TransitionDefinition, PersistedMachineState, ParameterizedObject, AnyActorContext, ProvidedActor, Equals, TODO } from "./types.js";
export declare const STATE_IDENTIFIER = "#";
export declare const WILDCARD = "*";
export type MachineSnapshot<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TTag extends string, TOutput, TResolvedTypesMeta = TypegenDisabled> = (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {
    status: 'active';
    output: undefined;
    error: undefined;
}) | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {
    status: 'done';
    output: TOutput;
    error: undefined;
}) | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {
    status: 'error';
    output: undefined;
    error: unknown;
}) | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {
    status: 'stopped';
    output: undefined;
    error: undefined;
});
export declare class StateMachine<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string, TInput, TOutput, TResolvedTypesMeta = ResolveTypegenMeta<TypegenDisabled, NoInfer<TEvent>, TActor, TAction, TGuard, TDelay, TTag>> implements ActorLogic<MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, TEvent, TInput, PersistedMachineState<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, TODO> {
    /**
     * The raw config used to create the machine.
     */
    config: MachineConfig<TContext, TEvent, any, any, any, any, any, any, TOutput, any>;
    /**
     * The machine's own version.
     */
    version?: string;
    implementations: MachineImplementationsSimplified<TContext, TEvent>;
    types: MachineTypes<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, TInput, TOutput, TResolvedTypesMeta>;
    __xstatenode: true;
    idMap: Map<string, StateNode<TContext, TEvent>>;
    root: StateNode<TContext, TEvent>;
    id: string;
    states: StateNode<TContext, TEvent>['states'];
    events: Array<TEvent['type']>;
    constructor(
    /**
     * The raw config used to create the machine.
     */
    config: MachineConfig<TContext, TEvent, any, any, any, any, any, any, TOutput, any>, implementations?: MachineImplementationsSimplified<TContext, TEvent>);
    /**
     * Clones this state machine with the provided implementations
     * and merges the `context` (if provided).
     *
     * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)
     *  to recursively merge with the existing options.
     *
     * @returns A new `StateMachine` instance with the provided implementations.
     */
    provide(implementations: InternalMachineImplementations<TContext, TEvent, TActor, TAction, TDelay, TResolvedTypesMeta, true>): StateMachine<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, TInput, TOutput, AreAllImplementationsAssumedToBeProvided<TResolvedTypesMeta> extends false ? MarkAllImplementationsAsProvided<TResolvedTypesMeta> : TResolvedTypesMeta>;
    /**
     * Resolves the given `state` to a new `State` instance relative to this machine.
     *
     * This ensures that `.nextEvents` represent the correct values.
     *
     * @param state The state to resolve
     */
    resolveState(state: State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta>): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    resolveStateValue(stateValue: StateValue, ...[context]: Equals<TContext, MachineContext> extends true ? [] : [TContext]): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    /**
     * Determines the next state given the current `state` and received `event`.
     * Calculates a full macrostep from all microsteps.
     *
     * @param state The current State instance or state value
     * @param event The received event
     */
    transition(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, event: TEvent, actorCtx: ActorContext<typeof state, TEvent>): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    /**
     * Determines the next state given the current `state` and `event`.
     * Calculates a microstep.
     *
     * @param state The current state
     * @param event The received event
     */
    microstep(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, event: TEvent, actorCtx: AnyActorContext): Array<MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>>;
    getTransitionData(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, event: TEvent): Array<TransitionDefinition<TContext, TEvent>>;
    /**
     * The initial state _before_ evaluating any microsteps.
     * This "pre-initial" state is provided to initial actions executed in the initial state.
     */
    private getPreInitialState;
    /**
     * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.
     */
    getInitialState(actorCtx: ActorContext<MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, TEvent>, input?: TInput): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    start(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>): void;
    getStateNodeById(stateId: string): StateNode<TContext, TEvent>;
    get definition(): StateMachineDefinition<TContext, TEvent>;
    toJSON(): StateMachineDefinition<TContext, TEvent>;
    getPersistedState(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>): PersistedMachineState<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    createState(stateConfig: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta> | StateConfig<TContext, TEvent>): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    restoreState(snapshot: PersistedMachineState<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, _actorCtx: ActorContext<MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>, TEvent>): MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
    /**@deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TContext: TContext;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TEvent: TEvent;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TActor: TActor;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TAction: TAction;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TGuard: TGuard;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TDelay: TDelay;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TTag: TTag;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TInput: TInput;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TOutput: TOutput;
    /** @deprecated an internal property acting as a "phantom" type, not meant to be used at runtime */
    __TResolvedTypesMeta: TResolvedTypesMeta;
}
