import { symbolObservable } from "./symbolObservable.js";
import { AreAllImplementationsAssumedToBeProvided, MissingImplementationsError } from "./typegenTypes.js";
import type { ActorSystem, AnyActorLogic, AnyStateMachine, EventFromLogic, PersistedStateFrom, SnapshotFrom, AnyActorRef } from "./types.js";
import { ActorRef, EventObject, InteropSubscribable, ActorOptions, Observer, Subscription } from "./types.js";
export type SnapshotListener<TLogic extends AnyActorLogic> = (state: SnapshotFrom<TLogic>) => void;
export type EventListener<TEvent extends EventObject = EventObject> = (event: TEvent) => void;
export type Listener = () => void;
export type ErrorListener = (error: any) => void;
export interface Clock {
    setTimeout(fn: (...args: any[]) => void, timeout: number): any;
    clearTimeout(id: any): void;
}
export declare enum ActorStatus {
    NotStarted = 0,
    Running = 1,
    Stopped = 2
}
/**
 * @deprecated Use `ActorStatus` instead.
 */
export declare const InterpreterStatus: typeof ActorStatus;
export declare class Actor<TLogic extends AnyActorLogic> implements ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>> {
    logic: TLogic;
    /**
     * The current internal state of the actor.
     */
    private _state;
    /**
     * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
     */
    clock: Clock;
    options: Readonly<ActorOptions<TLogic>>;
    /**
     * The unique identifier for this actor relative to its parent.
     */
    id: string;
    private mailbox;
    private delayedEventsMap;
    private observers;
    private logger;
    /**
     * Whether the service is started.
     */
    status: ActorStatus;
    _parent?: ActorRef<any, any>;
    ref: ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>;
    private _actorContext;
    private _systemId;
    /**
     * The globally unique process ID for this invocation.
     */
    sessionId: string;
    system: ActorSystem<any>;
    private _doneEvent?;
    src?: string;
    /**
     * Creates a new actor instance for the given logic with the provided options, if any.
     *
     * @param logic The logic to create an actor from
     * @param options Actor options
     */
    constructor(logic: TLogic, options?: ActorOptions<TLogic>);
    private _initState;
    private _deferred;
    private update;
    subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;
    subscribe(nextListener?: (state: SnapshotFrom<TLogic>) => void, errorListener?: (error: any) => void, completeListener?: () => void): Subscription;
    /**
     * Starts the Actor from the initial state
     */
    start(): this;
    private _process;
    private _stop;
    /**
     * Stops the Actor and unsubscribe all listeners.
     */
    stop(): this;
    private _complete;
    private _error;
    private _stopProcedure;
    /**
     * Sends an event to the running Actor to trigger a transition.
     *
     * @param event The event to send
     */
    send(event: EventFromLogic<TLogic>): void;
    delaySend({ event, id, delay, to }: {
        event: EventObject;
        id: string | undefined;
        delay: number;
        to?: AnyActorRef;
    }): void;
    cancel(sendId: string | number): void;
    private attachDevTools;
    toJSON(): {
        id: string;
    };
    getPersistedState(): PersistedStateFrom<TLogic> | undefined;
    [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>>;
    getSnapshot(): SnapshotFrom<TLogic>;
}
/**
 * Creates a new `ActorRef` instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to create an actor from
 * @param options `ActorRef` options
 */
export declare function createActor<TMachine extends AnyStateMachine>(machine: AreAllImplementationsAssumedToBeProvided<TMachine['__TResolvedTypesMeta']> extends true ? TMachine : MissingImplementationsError<TMachine['__TResolvedTypesMeta']>, options?: ActorOptions<TMachine>): Actor<TMachine>;
export declare function createActor<TLogic extends AnyActorLogic>(logic: TLogic, options?: ActorOptions<TLogic>): Actor<TLogic>;
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @deprecated Use `createActor` instead
 */
export declare const interpret: typeof createActor;
/**
 * @deprecated Use `Actor` instead.
 */
export type Interpreter = typeof Actor;
