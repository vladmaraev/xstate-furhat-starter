import { MachineSnapshot } from "./StateMachine.js";
import type { StateNode } from "./StateNode.js";
import { TypegenDisabled, TypegenEnabled } from "./typegenTypes.js";
import type { ProvidedActor, ActorRefFrom, AnyState, AnyStateMachine, EventObject, HistoryValue, MachineContext, PersistedMachineState, Prop, StateConfig, StateValue, TODO, AnyActorRef, Compute, EventDescriptor } from "./types.js";
type ComputeConcreteChildren<TActor extends ProvidedActor> = {
    [A in TActor as 'id' extends keyof A ? A['id'] & string : never]?: ActorRefFrom<A['logic']>;
};
type ComputeChildren<TActor extends ProvidedActor> = string extends TActor['src'] ? Record<string, AnyActorRef> : Compute<ComputeConcreteChildren<TActor> & (undefined extends TActor['id'] ? {
    [id: string]: TActor extends any ? ActorRefFrom<TActor['logic']> | undefined : never;
} : {})>;
export declare function isStateConfig<TContext extends MachineContext, TEvent extends EventObject>(state: any): state is StateConfig<TContext, TEvent>;
/**
 * @deprecated Use `isStateConfig(object)` or `state instanceof State` instead.
 */
export declare const isState: typeof isStateConfig;
export declare class State<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TTag extends string, TResolvedTypesMeta = TypegenDisabled> {
    machine: AnyStateMachine;
    tags: Set<string>;
    value: StateValue;
    /**
     * Indicates whether the state is a final state.
     */
    status: 'active' | 'done' | 'error' | 'stopped';
    /**
     * The output data of the top-level finite state.
     */
    error: unknown;
    context: TContext;
    historyValue: Readonly<HistoryValue<TContext, TEvent>>;
    _internalQueue: Array<TEvent>;
    /**
     * The enabled state nodes representative of the state value.
     */
    configuration: Array<StateNode<TContext, TEvent>>;
    /**
     * An object mapping actor names to spawned/invoked actors.
     */
    children: ComputeChildren<TActor>;
    /**
     * Creates a new State instance for the given `stateValue` and `context`.
     * @param stateValue
     * @param context
     */
    static from<TContext extends MachineContext, TEvent extends EventObject = EventObject>(stateValue: State<TContext, TEvent, TODO, any, // tags
    any> | StateValue, context: TContext | undefined, machine: AnyStateMachine): State<TContext, TEvent, TODO, any, // tags
    any>;
    /**
     * Creates a new `State` instance that represents the current state of a running machine.
     *
     * @param config
     */
    constructor(config: StateConfig<TContext, TEvent>, machine: AnyStateMachine);
    /**
     * Returns an array of all the string leaf state node paths.
     * @param stateValue
     * @param delimiter The character(s) that separate each subpath in the string state node path.
     */
    toStrings(stateValue?: StateValue): string[];
    toJSON(): Omit<this, "toJSON" | "meta" | "tags" | "configuration" | "machine" | "toStrings" | "matches" | "hasTag" | "can" | "nextEvents"> & {
        tags: string[];
        meta: Record<string, any>;
    };
    /**
     * Whether the current state value is a subset of the given parent state value.
     * @param parentStateValue
     */
    matches<TSV extends TResolvedTypesMeta extends TypegenEnabled ? Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'matchesStates'> : StateValue>(parentStateValue: TSV): boolean;
    /**
     * Whether the current state configuration has a state node with the specified `tag`.
     * @param tag
     */
    hasTag(tag: TTag): boolean;
    /**
     * Determines whether sending the `event` will cause a non-forbidden transition
     * to be selected, even if the transitions have no actions nor
     * change the state value.
     *
     * @param event The event to test
     * @returns Whether the event will cause a transition
     */
    can(event: TEvent): boolean;
    /**
     * The next events that will cause a transition from the current state.
     */
    get nextEvents(): Array<EventDescriptor<TEvent>>;
    get meta(): Record<string, any>;
}
export declare function cloneState<TState extends AnyState>(state: TState, config?: Partial<StateConfig<any, any>>): TState;
export declare function getPersistedState<TContext extends MachineContext, TEvent extends EventObject, TActor extends ProvidedActor, TTag extends string, TOutput, TResolvedTypesMeta = TypegenDisabled>(state: MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>): PersistedMachineState<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>;
export {};
