import { Compute, EventObject, IndexByType, IsNever, Prop, Values, IsAny, ParameterizedObject, ProvidedActor, OutputFrom, AnyActorLogic, IndexByProp } from "./types.js";
export interface TypegenDisabled {
    '@@xstate/typegen': false;
}
export interface TypegenEnabled {
    '@@xstate/typegen': true;
}
export interface TypegenMeta extends TypegenEnabled {
    /**
     * Allows you to specify all the results of state.matches
     */
    matchesStates: string | {};
    /**
     * Allows you to specify all tags used by the machine
     */
    tags: string;
    /**
     * Allows you to specify all the missing implementations
     * of the machine
     */
    missingImplementations: {
        actions: string;
        actors: string;
        delays: string;
        guards: string;
    };
    /**
     * A map for the internal events of the machine.
     *
     * key: 'xstate.done.actor.myActor'
     * value: {
     *   type: 'xstate.done.actor.myActor';
     *   data: unknown;
     *   __tip: 'Declare the type in event types!';
     * }
     */
    internalEvents: {};
    /**
     * Maps the src of the invoked actor to the event type that includes its known id
     *
     * key: 'invokeSrc'
     * value: 'xstate.done.actor.invokeName'
     */
    invokeSrcNameMap: Record<string, string>;
    /**
     * Keeps track of which events lead to which
     * actions.
     *
     * Key: 'EVENT_NAME'
     * Value: 'actionName' | 'otherActionName'
     */
    eventsCausingActions: Record<string, string>;
    /**
     * Keeps track of which events lead to which
     * delays.
     *
     * Key: 'EVENT_NAME'
     * Value: 'delayName' | 'otherDelayName'
     */
    eventsCausingDelays: Record<string, string>;
    /**
     * Keeps track of which events lead to which
     * guards.
     *
     * Key: 'EVENT_NAME'
     * Value: 'guardName' | 'otherGuardName'
     */
    eventsCausingGuards: Record<string, string>;
    /**
     * Keeps track of which events lead to which
     * actors.
     *
     * Key: 'EVENT_NAME'
     * Value: 'actorName' | 'otherActorName'
     */
    eventsCausingActors: Record<string, string>;
}
export interface ResolvedTypegenMeta extends TypegenMeta {
    resolved: TypegenMeta & {
        indexedActors: Record<string, ProvidedActor>;
        indexedActions: Record<string, ParameterizedObject>;
        indexedEvents: Record<string, EventObject>;
        indexedGuards: Record<string, ParameterizedObject>;
        indexedDelays: Record<string, ParameterizedObject>;
    };
}
export type TypegenConstraint = TypegenEnabled | TypegenDisabled;
export type AreAllImplementationsAssumedToBeProvided<TResolvedTypesMeta, TMissingImplementations = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'missingImplementations'>> = IsAny<TResolvedTypesMeta> extends true ? true : TResolvedTypesMeta extends TypegenEnabled ? IsNever<Values<{
    [K in keyof TMissingImplementations]: TMissingImplementations[K];
}>> extends true ? true : false : true;
export type MissingImplementationsError<TResolvedTypesMeta, TMissingImplementations = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'missingImplementations'>> = Compute<[
    'Some implementations missing',
    Values<{
        [K in keyof TMissingImplementations]: TMissingImplementations[K];
    }>
]>;
interface AllImplementationsProvided {
    missingImplementations: {
        actions: never;
        actors: never;
        delays: never;
        guards: never;
    };
}
export interface MarkAllImplementationsAsProvided<TResolvedTypesMeta> {
    '@@xstate/typegen': Prop<TResolvedTypesMeta, '@@xstate/typegen'>;
    resolved: Prop<TResolvedTypesMeta, 'resolved'> & AllImplementationsProvided;
}
type GenerateActorEvents<TActor extends ProvidedActor, TInvokeSrcNameMap> = string extends TActor['src'] ? never : TActor extends any ? {
    type: TActor['id'] extends string ? `xstate.done.actor.${TActor['id']}` : TActor['src'] extends keyof TInvokeSrcNameMap ? `xstate.done.actor.${TInvokeSrcNameMap[TActor['src']] & string}` : `xstate.done.actor.${string}`;
    output: OutputFrom<TActor['logic']>;
} : never;
type MergeWithInternalEvents<TIndexedEvents, TInternalEvents> = TIndexedEvents & Pick<TInternalEvents, Exclude<keyof TInternalEvents, keyof TIndexedEvents>>;
type AllowAllEvents = {
    eventsCausingActions: Record<string, string>;
    eventsCausingActors: Record<string, string>;
    eventsCausingDelays: Record<string, string>;
    eventsCausingGuards: Record<string, string>;
};
type IndexParameterizedImplementation<TParameterizedImplementation extends ParameterizedObject, TCausingLookup> = string extends TParameterizedImplementation['type'] ? IsNever<TCausingLookup> extends true ? never : Record<keyof TCausingLookup, ParameterizedObject> : IndexByType<TParameterizedImplementation>;
type WrapIntoParameterizedObject<T extends string> = T extends any ? {
    type: T;
} : never;
export interface ResolveTypegenMeta<TTypesMeta extends TypegenConstraint, TEvent extends EventObject, TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string> {
    '@@xstate/typegen': TTypesMeta['@@xstate/typegen'];
    resolved: {
        enabled: TTypesMeta & {
            indexedActions: IndexParameterizedImplementation<TAction, Prop<TTypesMeta, 'eventsCausingActions'>>;
            indexedActors: string extends TActor['src'] ? Record<keyof Prop<TTypesMeta, 'eventsCausingActors'>, {
                logic: AnyActorLogic;
            }> : IndexByProp<TActor, 'src'>;
            indexedEvents: MergeWithInternalEvents<IndexByType<(string extends TEvent['type'] ? never : TEvent) | GenerateActorEvents<TActor, Prop<TTypesMeta, 'invokeSrcNameMap'>>>, Prop<TTypesMeta, 'internalEvents'>>;
            indexedGuards: IndexParameterizedImplementation<TGuard, Prop<TTypesMeta, 'eventsCausingGuards'>>;
            indexedDelays: IndexParameterizedImplementation<WrapIntoParameterizedObject<TDelay>, Prop<TTypesMeta, 'eventsCausingDelays'>>;
            tags: string extends TTag ? Prop<TTypesMeta, 'tags'> : TTag;
        };
        disabled: TypegenDisabled & AllImplementationsProvided & AllowAllEvents & {
            indexedActions: IndexByType<TAction>;
            indexedActors: IndexByProp<TActor, 'src'>;
            indexedEvents: Record<string, TEvent>;
            indexedGuards: IndexByType<TGuard>;
            indexedDelays: IndexByType<WrapIntoParameterizedObject<TDelay>>;
            invokeSrcNameMap: Record<string, string>;
            tags: TTag;
        };
    }[IsNever<TTypesMeta> extends true ? 'disabled' : TTypesMeta['@@xstate/typegen'] extends true ? 'enabled' : 'disabled'];
}
export {};
