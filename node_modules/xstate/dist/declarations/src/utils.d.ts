import { AnyActorLogic, AnyState } from "./index.js";
import type { StateNode } from "./StateNode.js";
import type { ActorLogic, AnyEventObject, EventObject, MachineContext, Mapper, Observer, ErrorActorEvent, SingleOrArray, StateLike, StateValue, Subscribable, TransitionConfigTarget, AnyActorRef, AnyTransitionConfig, NonReducibleUnknown } from "./types.js";
export declare function keys<T extends object>(value: T): Array<keyof T & string>;
export declare function matchesState(parentStateId: StateValue, childStateId: StateValue): boolean;
export declare function toStatePath(stateId: string | string[]): string[];
export declare function isStateLike(state: any): state is AnyState;
export declare function toStateValue(stateValue: StateLike<any> | StateValue | string[]): StateValue;
export declare function pathToStateValue(statePath: string[]): StateValue;
export declare function mapValues<P, O extends Record<string, unknown>>(collection: O, iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P): {
    [key in keyof O]: P;
};
export declare function mapFilterValues<T, P>(collection: {
    [key: string]: T;
}, iteratee: (item: T, key: string, collection: {
    [key: string]: T;
}) => P, predicate: (item: T) => boolean): {
    [key: string]: P;
};
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */
export declare function path<T extends Record<string, any>>(props: string[]): any;
export declare function toStatePaths(stateValue: StateValue | undefined): string[][];
export declare function flatten<T>(array: Array<T | T[]>): T[];
export declare function toArrayStrict<T>(value: readonly T[] | T): readonly T[];
export declare function toArray<T>(value: readonly T[] | T | undefined): readonly T[];
export declare function resolveOutput<TContext extends MachineContext, TExpressionEvent extends EventObject>(mapper: Mapper<TContext, TExpressionEvent, unknown, EventObject> | NonReducibleUnknown, context: TContext, event: TExpressionEvent, self: AnyActorRef): unknown;
export declare function isBuiltInEvent(eventType: string): boolean;
export declare function isPromiseLike(value: any): value is PromiseLike<any>;
export declare function isActorLogic(value: any): value is ActorLogic<any, any>;
export declare function partition<T, A extends T, B extends T>(items: T[], predicate: (item: T) => item is A): [A[], B[]];
export declare function isArray(value: any): value is readonly any[];
export declare function isObservable<T>(value: any): value is Subscribable<T>;
export declare function isErrorActorEvent(event: AnyEventObject): event is ErrorActorEvent;
export declare function toTransitionConfigArray<TContext extends MachineContext, TEvent extends EventObject>(configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>): Array<AnyTransitionConfig>;
export declare function normalizeTarget<TContext extends MachineContext, TEvent extends EventObject>(target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined;
export declare function reportUnhandledExceptionOnInvocation(originalError: any, currentError: any, id: string): void;
export declare function toObserver<T>(nextHandler?: Observer<T> | ((value: T) => void), errorHandler?: (error: any) => void, completionHandler?: () => void): Observer<T>;
export declare function createInvokeId(stateNodeId: string, index: number): string;
export declare function resolveReferencedActor(referenced: AnyActorLogic | {
    src: AnyActorLogic;
    input: Mapper<MachineContext, EventObject, unknown, EventObject> | NonReducibleUnknown;
} | undefined): {
    src: AnyActorLogic;
    input: Mapper<MachineContext, EventObject, unknown, EventObject> | NonReducibleUnknown;
} | undefined;
