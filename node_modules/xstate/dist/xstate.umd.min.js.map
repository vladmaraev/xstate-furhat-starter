{"version":3,"file":"xstate.umd.min.js","sources":["../src/constants.ts","../src/memo.ts","../src/eventUtils.ts","../src/actions/cancel.ts","../src/Mailbox.ts","../src/dev/index.ts","../src/reportUnhandledError.ts","../src/symbolObservable.ts","../src/system.ts","../src/utils.ts","../src/interpreter.ts","../src/actions/invoke.ts","../src/actions/stop.ts","../src/guards.ts","../src/stateUtils.ts","../src/State.ts","../src/spawn.ts","../src/actions/assign.ts","../src/actions/choose.ts","../src/actions/log.ts","../src/actions/pure.ts","../src/actions/raise.ts","../src/types.ts","../src/actions/send.ts","../src/actors/transition.ts","../src/actors/promise.ts","../src/actors/index.ts","../src/StateNode.ts","../src/StateMachine.ts","../src/waitFor.ts","../src/SimulatedClock.ts","../src/Machine.ts","../src/actors/callback.ts","../src/actors/observable.ts","../src/mapState.ts"],"sourcesContent":["export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n\nexport function evict(object: any, key?: string): void {\n  if (!key) {\n    return void cache.delete(object);\n  }\n\n  const memoizedData = cache.get(object);\n\n  if (memoizedData) {\n    delete memoizedData[key];\n  }\n}\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id?: string) {\n  const idSuffix = id ? `#${id}` : '';\n  return { type: `xstate.after(${delayRef})${idSuffix}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  data?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, data };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorContext,\n  AnyActor,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n) {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs) : sendId;\n  return [state, resolvedSendId];\n}\n\nfunction executeCancel(actorContext: AnyActorContext, resolvedSendId: string) {\n  (actorContext.self as AnyActor).cancel(resolvedSendId);\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\n * be executed, nor will its event be sent, unless it has already been sent\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\n *\n * @param sendId The `id` of the `send(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  >\n): CancelAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function cancel(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  // TODO: rethink this design\n  public prepend(event: T): void {\n    if (!this._current) {\n      this.enqueue(event);\n      return;\n    }\n\n    // we know that something is already queued up\n    // so the mailbox is already flushing or it's inactive\n    // therefore the only thing that we need to do is to reassign `this._current`\n    this._current = {\n      value: event,\n      next: this._current\n    };\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      // something could have been prepended in the meantime\n      // so we need to be defensive here to avoid skipping over a prepended item\n      if (consumed === this._current) {\n        this._current = this._current.next;\n      }\n    }\n    this._last = null;\n  }\n}\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if (!!(w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate macrotask.\n * It allows those errors to be detected by global error handlers and reported to bug tracking services\n * without interrupting our own stack of execution.\n *\n * @param err error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import {\n  AnyEventObject,\n  ActorSystem,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  Snapshot\n} from './types.ts';\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const observers = new Set<Observer<InspectionEvent>>();\n\n  const system: ActorSystem<T> = {\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observer) => {\n      observers.add(observer);\n    },\n    _sendInspectionEvent: (event) => {\n      const resolvedInspectionEvent: InspectionEvent = {\n        ...event,\n        rootId: rootActor.sessionId\n      };\n      observers.forEach((observer) => observer.next?.(resolvedInspectionEvent));\n    },\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        targetRef: target,\n        event\n      });\n\n      target._send(event);\n    }\n  };\n\n  return system;\n}\nexport interface BaseInspectionEventProperties {\n  rootId: string; // the session ID of the root\n}\n\nexport interface InspectedSnapshotEvent extends BaseInspectionEventProperties {\n  type: '@xstate.snapshot';\n  actorRef: AnyActorRef; // Only available locally\n  event: AnyEventObject; // { type: string, ... }\n  snapshot: Snapshot<unknown>;\n}\n\nexport interface InspectedEventEvent extends BaseInspectionEventProperties {\n  type: '@xstate.event';\n  // The source might not exist, e.g. when:\n  // - root init events\n  // - events sent from external (non-actor) sources\n  sourceRef: AnyActorRef | undefined;\n  targetRef: AnyActorRef; // Session ID, required\n  event: AnyEventObject; // { type: string, ... }\n}\n\nexport interface InspectedActorEvent extends BaseInspectionEventProperties {\n  type: '@xstate.actor';\n  actorRef: AnyActorRef;\n}\n\nexport type InspectionEvent =\n  | InspectedSnapshotEvent\n  | InspectedEventEvent\n  | InspectedActorEvent;\n","import isDevelopment from '#is-development';\nimport { AnyActorLogic, AnyState } from './index.ts';\nimport { STATE_DELIMITER, TARGETLESS_KEY } from './constants.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type {\n  ActorLogic,\n  AnyEventObject,\n  EventObject,\n  MachineContext,\n  Mapper,\n  Observer,\n  ErrorActorEvent,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  Subscribable,\n  TransitionConfigTarget,\n  AnyActorRef,\n  AnyTransitionConfig,\n  NonReducibleUnknown\n} from './types.ts';\n\nexport function keys<T extends object>(value: T): Array<keyof T & string> {\n  return Object.keys(value) as Array<keyof T & string>;\n}\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  try {\n    if (isArray(stateId)) {\n      return stateId;\n    }\n\n    return stateId.toString().split(STATE_DELIMITER);\n  } catch (e) {\n    throw new Error(`'${stateId}' is not a valid state path.`);\n  }\n}\n\nexport function isStateLike(state: any): state is AnyState {\n  return (\n    typeof state === 'object' &&\n    'value' in state &&\n    'context' in state &&\n    'event' in state\n  );\n}\n\nexport function toStateValue(\n  stateValue: StateLike<any> | StateValue | string[]\n): StateValue {\n  if (isStateLike(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (isArray(stateValue)) {\n    return pathToStateValue(stateValue);\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue as string);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nexport function mapFilterValues<T, P>(\n  collection: { [key: string]: T },\n  iteratee: (item: T, key: string, collection: { [key: string]: T }) => P,\n  predicate: (item: T) => boolean\n): { [key: string]: P } {\n  const result: { [key: string]: P } = {};\n\n  for (const key of Object.keys(collection)) {\n    const item = collection[key];\n\n    if (!predicate(item)) {\n      continue;\n    }\n\n    result[key] = iteratee(item, key, collection);\n  }\n\n  return result;\n}\n\n/**\n * Retrieves a value at the given path.\n * @param props The deep path to the prop of the desired value\n */\nexport function path<T extends Record<string, any>>(props: string[]): any {\n  return (object: T): any => {\n    let result: T = object;\n\n    for (const prop of props) {\n      result = result[prop as keyof typeof result];\n    }\n\n    return result;\n  };\n}\n\nexport function toStatePaths(stateValue: StateValue | undefined): string[][] {\n  if (!stateValue) {\n    return [[]];\n  }\n\n  if (typeof stateValue === 'string') {\n    return [[stateValue]];\n  }\n\n  const result = flatten(\n    Object.keys(stateValue).map((key) => {\n      const subStateValue = stateValue[key];\n\n      if (\n        typeof subStateValue !== 'string' &&\n        (!subStateValue || !Object.keys(subStateValue).length)\n      ) {\n        return [[key]];\n      }\n\n      return toStatePaths(stateValue[key]).map((subPath) => {\n        return [key].concat(subPath);\n      });\n    })\n  );\n\n  return result;\n}\n\nexport function flatten<T>(array: Array<T | T[]>): T[] {\n  return ([] as T[]).concat(...array);\n}\n\nexport function toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([key, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nexport function isBuiltInEvent(eventType: string): boolean {\n  return /^(done|error)\\./.test(eventType);\n}\n\nexport function isPromiseLike(value: any): value is PromiseLike<any> {\n  if (value instanceof Promise) {\n    return true;\n  }\n  // Check if shape matches the Promise/A+ specification for a \"thenable\".\n  if (\n    value !== null &&\n    (typeof value === 'function' || typeof value === 'object') &&\n    typeof value.then === 'function'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isActorLogic(value: any): value is ActorLogic<any, any> {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'transition' in value &&\n    typeof value.transition === 'function'\n  );\n}\n\nexport function partition<T, A extends T, B extends T>(\n  items: T[],\n  predicate: (item: T) => item is A\n): [A[], B[]] {\n  const [truthy, falsy] = [[], []] as [A[], B[]];\n\n  for (const item of items) {\n    if (predicate(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item as B);\n    }\n  }\n\n  return [truthy, falsy];\n}\n\nexport function isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isObservable<T>(value: any): value is Subscribable<T> {\n  return (\n    !!value && 'subscribe' in value && typeof value.subscribe === 'function'\n  );\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function reportUnhandledExceptionOnInvocation(\n  originalError: any,\n  currentError: any,\n  id: string\n) {\n  if (isDevelopment) {\n    const originalStackTrace = originalError.stack\n      ? ` Stacktrace was '${originalError.stack}'`\n      : '';\n    if (originalError === currentError) {\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler for invocation '${id}', error was '${originalError}'.${originalStackTrace}`\n      );\n    } else {\n      const stackTrace = currentError.stack\n        ? ` Stacktrace was '${currentError.stack}'`\n        : '';\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler and/or unhandled exception/promise rejection for invocation '${id}'. ` +\n          `Original error: '${originalError}'. ${originalStackTrace} Current error is '${currentError}'.${stackTrace}`\n      );\n    }\n  }\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${stateNodeId}:invocation[${index}]`;\n}\n\nexport function resolveReferencedActor(\n  referenced:\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input:\n          | Mapper<MachineContext, EventObject, unknown, EventObject>\n          | NonReducibleUnknown;\n      }\n    | undefined\n) {\n  return referenced\n    ? 'transition' in referenced\n      ? { src: referenced, input: undefined }\n      : referenced\n    : undefined;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { createSystem } from './system.ts';\nimport {\n  AreAllImplementationsAssumedToBeProvided,\n  MissingImplementationsError\n} from './typegenTypes.ts';\nimport type {\n  ActorLogic,\n  ActorContext,\n  ActorSystem,\n  AnyActorLogic,\n  AnyStateMachine,\n  EventFromLogic,\n  PersistedStateFrom,\n  SnapshotFrom,\n  AnyActorRef,\n  OutputFrom,\n  DoneActorEvent\n} from './types.ts';\nimport {\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  ActorOptions,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport type SnapshotListener<TLogic extends AnyActorLogic> = (\n  state: SnapshotFrom<TLogic>\n) => void;\n\nexport type EventListener<TEvent extends EventObject = EventObject> = (\n  event: TEvent\n) => void;\n\nexport type Listener = () => void;\nexport type ErrorListener = (error: any) => void;\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\nexport enum ActorStatus {\n  NotStarted,\n  Running,\n  Stopped\n}\n\n/**\n * @deprecated Use `ActorStatus` instead.\n */\nexport const InterpreterStatus = ActorStatus;\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\nexport class Actor<TLogic extends AnyActorLogic>\n  implements ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>\n{\n  /**\n   * The current internal state of the actor.\n   */\n  private _state!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private delayedEventsMap: Record<string, unknown> = {};\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private logger: (...args: any[]) => void;\n  /**\n   * Whether the service is started.\n   */\n  public status: ActorStatus = ActorStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: ActorRef<any, any>;\n  public ref: ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>;\n  // TODO: add typings for system\n  private _actorContext: ActorContext<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    any\n  >;\n\n  private _systemId: string | undefined;\n\n  /**\n   * The globally unique process ID for this invocation.\n   */\n  public sessionId: string;\n\n  public system: ActorSystem<any>;\n  private _doneEvent?: DoneActorEvent;\n\n  public src?: string;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options, if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(public logic: TLogic, options?: ActorOptions<TLogic>) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    } as ActorOptions<TLogic> & typeof defaultOptions;\n\n    const { clock, logger, parent, id, systemId, inspect } = resolvedOptions;\n\n    this.system = parent?.system ?? createSystem(this);\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = logger;\n    this.clock = clock;\n    this._parent = parent;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src;\n    this.ref = this;\n    this._actorContext = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    this._initState();\n  }\n\n  private _initState() {\n    this._state = this.options.state\n      ? this.logic.restoreState\n        ? this.logic.restoreState(this.options.state, this._actorContext)\n        : this.options.state\n      : this.logic.getInitialState(this._actorContext, this.options?.input);\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._state = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      deferredFn();\n    }\n\n    for (const observer of this.observers) {\n      // TODO: should observers be notified in case of the error?\n      try {\n        observer.next?.(snapshot);\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    switch ((this._state as any).status) {\n      case 'done':\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._state as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._stopProcedure();\n        this._error((this._state as any).error);\n        if (this._parent) {\n          this.system._relay(\n            this,\n            this._parent,\n            createErrorActorEvent(this.id, (this._state as any).error)\n          );\n        }\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (state: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((state: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this.status !== ActorStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  /**\n   * Starts the Actor from the initial state\n   */\n  public start(): this {\n    if (this.status === ActorStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this.status = ActorStatus.Running;\n\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      targetRef: this,\n      event: initEvent\n    });\n\n    const status = (this._state as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon intialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._state,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n      // fallthrough\n      case 'error':\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._state, this._actorContext);\n      } catch (err) {\n        this._stopProcedure();\n        this._error(err);\n        this._parent?.send(createErrorActorEvent(this.id, err));\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._state, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    // TODO: reexamine what happens when an action (or a guard or smth) throws\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._state, event, this._actorContext);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._stopProcedure();\n      this._error(err);\n      this._parent?.send(createErrorActorEvent(this.id, err));\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this.status === ActorStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this.status === ActorStatus.NotStarted) {\n      this.status = ActorStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /**\n   * Stops the Actor and unsubscribe all listeners.\n   */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _error(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _stopProcedure(): this {\n    if (this.status !== ActorStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    for (const key of Object.keys(this.delayedEventsMap)) {\n      this.clock.clearTimeout(this.delayedEventsMap[key]);\n    }\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this.status = ActorStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this.status === ActorStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public delaySend({\n    event,\n    id,\n    delay,\n    to\n  }: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number;\n    to?: AnyActorRef;\n  }): void {\n    const timerId = this.clock.setTimeout(() => {\n      this.system._relay(this, to ?? this, event as EventFromLogic<TLogic>);\n    }, delay);\n\n    // TODO: consider the rehydration story here\n    if (id) {\n      this.delayedEventsMap[id] = timerId;\n    }\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public cancel(sendId: string | number): void {\n    this.clock.clearTimeout(this.delayedEventsMap[sendId]);\n    delete this.delayedEventsMap[sendId];\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      id: this.id\n    };\n  }\n\n  public getPersistedState(): PersistedStateFrom<TLogic> | undefined {\n    return this.logic.getPersistedState?.(this._state);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    return this._state;\n  }\n}\n\n/**\n * Creates a new `ActorRef` instance for the given machine with the provided options, if any.\n *\n * @param machine The machine to create an actor from\n * @param options `ActorRef` options\n */\nexport function createActor<TMachine extends AnyStateMachine>(\n  machine: AreAllImplementationsAssumedToBeProvided<\n    TMachine['__TResolvedTypesMeta']\n  > extends true\n    ? TMachine\n    : MissingImplementationsError<TMachine['__TResolvedTypesMeta']>,\n  options?: ActorOptions<TMachine>\n): Actor<TMachine>;\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: ActorOptions<TLogic>\n): Actor<TLogic>;\nexport function createActor(logic: any, options?: ActorOptions<any>): any {\n  const interpreter = new Actor(logic, options);\n\n  return interpreter;\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @deprecated Use `createActor` instead\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport { createErrorActorEvent } from '../eventUtils.ts';\nimport { ActorStatus, createActor } from '../interpreter.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyActorRef,\n  AnyActor,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  Snapshot\n} from '../types.ts';\nimport { resolveReferencedActor } from '../utils.ts';\n\nfunction resolveInvoke(\n  actorContext: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    id,\n    systemId,\n    src,\n    input,\n    syncSnapshot\n  }: {\n    id: string;\n    systemId: string | undefined;\n    src: string;\n    input?: unknown;\n    syncSnapshot: boolean;\n  }\n) {\n  const referenced = resolveReferencedActor(\n    state.machine.implementations.actors[src]\n  );\n\n  let actorRef: AnyActorRef | undefined;\n\n  if (referenced) {\n    // TODO: inline `input: undefined` should win over the referenced one\n    const configuredInput = input || referenced.input;\n    actorRef = createActor(referenced.src, {\n      id,\n      src,\n      parent: actorContext?.self,\n      systemId,\n      input:\n        typeof configuredInput === 'function'\n          ? configuredInput({\n              context: state.context,\n              event: actionArgs.event,\n              self: actorContext?.self\n            })\n          : configuredInput\n    });\n\n    if (syncSnapshot) {\n      actorRef.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            actorContext.self.send({\n              type: `xstate.snapshot.${id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {\n          /* TODO */\n        }\n      });\n    }\n  }\n\n  if (isDevelopment && !actorRef) {\n    console.warn(\n      `Actor type '${src}' not found in machine '${actorContext.id}'.`\n    );\n  }\n  return [\n    cloneState(state, {\n      children: {\n        ...state.children,\n        [id]: actorRef!\n      }\n    }),\n    {\n      id,\n      actorRef\n    }\n  ];\n}\n\nfunction executeInvoke(\n  actorContext: AnyActorContext,\n  { id, actorRef }: { id: string; actorRef: AnyActorRef }\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  actorContext.defer(() => {\n    if (actorRef.status === ActorStatus.Stopped) {\n      return;\n    }\n    try {\n      actorRef.start?.();\n    } catch (err) {\n      (actorContext.self as AnyActor).send(createErrorActorEvent(id, err));\n      return;\n    }\n  });\n}\n\n// we don't export this since it's an internal action that is not meant to be used in the user's code\ninterface InvokeAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\nexport function invoke<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>({\n  id,\n  systemId,\n  src,\n  input,\n  onSnapshot\n}: {\n  id: string;\n  systemId: string | undefined;\n  src: string;\n  input?: unknown;\n  onSnapshot?: {}; // TODO: transition object\n}): InvokeAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function invoke(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  invoke.type = 'xstate.invoke';\n  invoke.id = id;\n  invoke.systemId = systemId;\n  invoke.src = src;\n  invoke.input = input;\n  invoke.syncSnapshot = !!onSnapshot;\n\n  invoke.resolve = resolveInvoke;\n  invoke.execute = executeInvoke;\n\n  return invoke;\n}\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport { ActorStatus } from '../interpreter.ts';\nimport {\n  ActionArgs,\n  ActorRef,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ActorRef<any, any>\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => ActorRef<any, any> | string);\n\nfunction resolveStop(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n) {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args) : actorRef;\n  const resolvedActorRef: ActorRef<any, any> | undefined =\n    typeof actorRefOrString === 'string'\n      ? state.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = state.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneState(state, {\n      children\n    }),\n    resolvedActorRef\n  ];\n}\nfunction executeStop(\n  actorContext: AnyActorContext,\n  actorRef: ActorRef<any, any> | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n  if (actorRef.status !== ActorStatus.Running) {\n    actorContext.stopChild(actorRef);\n    return;\n  }\n  // TODO: recheck why this one has to be deferred\n  actorContext.defer(() => {\n    actorContext.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n * Stops an actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stop<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  >\n): StopAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function stop(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stop';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyState,\n  NoRequiredParams,\n  NoInfer,\n  WithDynamicParams\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  guard: TExpressionGuard;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TExpressionGuard, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject,\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    state: AnyState,\n    guardArgs: GuardArgs<any, any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  state: AnyState,\n  _: GuardArgs<any, any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    return state.configuration.some((sn) => sn.id === stateValue.slice(1));\n  }\n\n  return state.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n>(stateValue: StateValue) {\n  function stateIn(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    any // TODO: recheck if we could replace this with something better here\n  >;\n}\n\nfunction checkNot(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, state);\n}\n\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(guard: Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>) {\n  function not(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkAnd(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function and(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkOr(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function or(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  state: AnyState\n): boolean {\n  const { machine } = state;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, state);\n  }\n\n  const guardArgs = {\n    context,\n    event,\n    guard: isInline\n      ? undefined\n      : typeof guard === 'string'\n      ? { type: guard }\n      : typeof guard.params === 'function'\n      ? {\n          type: guard.type,\n          params: guard.params({ context, event })\n        }\n      : guard\n  };\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    state,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { State, cloneState } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { invoke } from './actions/invoke.ts';\nimport { stop } from './actions/stop.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { ActorStatus } from './interpreter.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyState,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayExpr,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  SingleOrArray,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  AnyActorRef,\n  UnknownAction,\n  ParameterizedObject,\n  ActionFunction,\n  AnyTransitionConfig,\n  ProvidedActor\n} from './types.ts';\nimport {\n  isArray,\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toStateValue,\n  toTransitionConfigArray\n} from './utils.ts';\n\ntype Configuration<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyConfiguration = Configuration<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nfunction getOutput<TContext extends MachineContext, TEvent extends EventObject>(\n  configuration: StateNode<TContext, TEvent>[],\n  context: TContext,\n  event: TEvent,\n  self: AnyActorRef\n) {\n  const { machine } = configuration[0];\n  const { root } = machine;\n\n  if (!root.output) {\n    return undefined;\n  }\n\n  const finalChildStateNode = configuration.find(\n    (stateNode) =>\n      stateNode.type === 'final' && stateNode.parent === machine.root\n  )!;\n\n  const doneStateEvent = createDoneStateEvent(\n    finalChildStateNode.id,\n    finalChildStateNode.output\n      ? resolveOutput(finalChildStateNode.output, context, event, self)\n      : undefined\n  );\n\n  return resolveOutput(root.output, context, doneStateEvent, self);\n}\n\nexport const isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getConfiguration(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const configuration = new Set(stateNodes);\n  const configurationSet = new Set(stateNodes);\n\n  const adjList = getAdjList(configurationSet);\n\n  // add descendants\n  for (const s of configuration) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodes(s).forEach((sn) => configurationSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!configurationSet.has(child)) {\n            for (const initialStateNode of getInitialStateNodes(child)) {\n              configurationSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of configurationSet) {\n    let m = s.parent;\n\n    while (m) {\n      configurationSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return configurationSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nexport function getAdjList<\n  TContext extends MachineContext,\n  TE extends EventObject\n>(configuration: Configuration<TContext, TE>): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of configuration) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  configuration: AnyConfiguration\n): StateValue {\n  const config = getConfiguration(configuration);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  configuration: Array<AnyStateNode>,\n  stateNode: AnyStateNode = configuration[0].machine.root\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && configuration.includes(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(configuration, sn)\n    );\n  }\n\n  return false;\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((descriptor) => {\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (descriptor === WILDCARD) {\n          return true;\n        }\n\n        if (!descriptor.endsWith('.*')) {\n          return false;\n        }\n\n        if (isDevelopment && /.*\\*.+/.test(descriptor)) {\n          console.warn(\n            `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`\n          );\n        }\n\n        const partialEventTokens = descriptor.split('.');\n        const eventTokens = receivedEventType.split('.');\n\n        for (\n          let tokenIndex = 0;\n          tokenIndex < partialEventTokens.length;\n          tokenIndex++\n        ) {\n          const partialEventToken = partialEventTokens[tokenIndex];\n          const eventToken = eventTokens[tokenIndex];\n\n          if (partialEventToken === '*') {\n            const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n            if (isDevelopment && !isLastToken) {\n              console.warn(\n                `Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`\n              );\n            }\n\n            return isLastToken;\n          }\n\n          if (partialEventToken !== eventToken) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/**\n * All delayed transitions from the config.\n */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >,\n    i: number\n  ) => {\n    const delayRef =\n      typeof delay === 'function' ? `${stateNode.id}:delay[${i}]` : delay;\n    const afterEvent = createAfterEvent(delayRef, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, { id: eventType, delay }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = isArray(afterConfig)\n    ? afterConfig.map((transition, i) => {\n        const eventType = mutateEntryExit(transition.delay, i);\n        return { ...transition, event: eventType };\n      })\n    : Object.keys(afterConfig).flatMap((delay, i) => {\n        const configTransition = afterConfig[delay];\n        const resolvedTransition =\n          typeof configTransition === 'string'\n            ? { target: configTransition }\n            : configTransition;\n        const resolvedDelay = !isNaN(+delay) ? +delay : delay;\n        const eventType = mutateEntryExit(resolvedDelay, i);\n        return toArray(resolvedTransition).map((transition) => ({\n          ...transition,\n          event: eventType,\n          delay: resolvedDelay\n        }));\n      });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | SingleOrArray<string>\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  if (typeof _target === 'string' || isArray(_target)) {\n    const targets = toArray(_target).map((t) => {\n      // Resolve state string keys (which represent children)\n      // to their state node\n      const descStateNode =\n        typeof t === 'string'\n          ? isStateId(t)\n            ? stateNode.machine.getStateNodeById(t)\n            : stateNode.states[t]\n          : t;\n\n      if (!descStateNode) {\n        throw new Error(\n          `Initial state node \"${t}\" not found on parent state node #${stateNode.id}`\n        );\n      }\n\n      if (!isDescendant(descStateNode, stateNode)) {\n        throw new Error(\n          `Invalid initial target: state node #${descStateNode.id} is not a descendant of #${stateNode.id}`\n        );\n      }\n\n      return descStateNode;\n    });\n    const resolvedTarget = resolveTarget(stateNode, targets);\n\n    const transition = {\n      source: stateNode,\n      actions: [],\n      eventType: null as any,\n      reenter: false,\n      target: resolvedTarget!,\n      toJSON: () => ({\n        ...transition,\n        source: `#${stateNode.id}`,\n        target: resolvedTarget\n          ? resolvedTarget.map((t) => `#${t.id}`)\n          : undefined\n      })\n    };\n\n    return transition;\n  }\n\n  return formatTransition(stateNode, '__INITIAL__', {\n    target: toArray(_target.target).map((t) => {\n      if (typeof t === 'string') {\n        return isStateId(t) ? t : `${STATE_DELIMITER}${t}`;\n      }\n\n      return t;\n    }),\n    actions: _target.actions\n  }) as InitialTransitionDefinition<TContext, TEvent>;\n}\n\nexport function resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }): ReadonlyArray<AnyStateNode> {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial.target;\n  }\n  return normalizedTarget.map((t) =>\n    typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n  );\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nexport function getInitialStateNodes(\n  stateNode: AnyStateNode\n): Array<AnyStateNode> {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      for (const targetStateNode of descStateNode.initial.target) {\n        for (const a of getProperAncestors(targetStateNode, stateNode)) {\n          set.add(a);\n        }\n\n        iter(targetStateNode);\n      }\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return [...set];\n}\n/**\n * Returns the child state node from its relative `stateKey`, or throws.\n */\nexport function getStateNode(\n  stateNode: AnyStateNode,\n  stateKey: string\n): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch (e) {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param state The state value or State instance\n */\nexport function getStateNodes<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  state: StateValue | State<TContext, TEvent, TODO, TODO, TODO>\n): Array<AnyStateNode> {\n  const stateValue = state instanceof State ? state.value : toStateValue(state);\n\n  if (typeof stateValue === 'string') {\n    return [stateNode, stateNode.states[stateValue]];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nexport function transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(state, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]],\n    state,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      state,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(state, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  state: State<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO // tags\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, state, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, state, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, state, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction getPathFromRootToNode(stateNode: AnyStateNode): Array<AnyStateNode> {\n  const path: Array<AnyStateNode> = [];\n  let marker = stateNode.parent;\n\n  while (marker) {\n    path.unshift(marker);\n    marker = marker.parent;\n  }\n\n  return path;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], configuration, historyValue),\n          computeExitSet([t2], configuration, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLCCA(stateNodes: Array<AnyStateNode>): AnyStateNode {\n  const [head] = stateNodes;\n\n  let current = getPathFromRootToNode(head);\n  let candidates: Array<AnyStateNode> = [];\n\n  for (const stateNode of stateNodes) {\n    const path = getPathFromRootToNode(stateNode);\n\n    candidates = current.filter((sn) => path.includes(sn));\n    current = candidates;\n    candidates = [];\n  }\n\n  return current[current.length - 1];\n}\n\nfunction getEffectiveTargetStates(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          {\n            target: resolveHistoryTarget(targetNode)\n          } as AnyTransitionDefinition,\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | null {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return null;\n  }\n\n  if (\n    !transition.reenter &&\n    transition.source.type !== 'parallel' &&\n    targetStates.every((targetStateNode) =>\n      isDescendant(targetStateNode, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lcca = findLCCA(targetStates.concat(transition.source));\n\n  return lcca;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      for (const stateNode of configuration) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\n/**\n * https://www.w3.org/TR/scxml/#microstepProcedure\n *\n * @private\n * @param transitions\n * @param currentState\n * @param mutConfiguration\n */\n\nexport function microstep<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  transitions: Array<TransitionDefinition<TContext, TEvent>>,\n  currentState: AnyState,\n  actorCtx: AnyActorContext,\n  event: TEvent,\n  isInitial: boolean\n): AnyState {\n  const mutConfiguration = new Set(currentState.configuration);\n\n  if (!transitions.length) {\n    return currentState;\n  }\n\n  const microstate = microstepProcedure(\n    transitions,\n    currentState,\n    mutConfiguration,\n    event,\n    actorCtx,\n    isInitial\n  );\n\n  return cloneState(microstate, {\n    value: {} // TODO: make optional\n  });\n}\n\nfunction microstepProcedure(\n  transitions: Array<AnyTransitionDefinition>,\n  currentState: AnyState,\n  mutConfiguration: Set<AnyStateNode>,\n  event: AnyEventObject,\n  actorCtx: AnyActorContext,\n  isInitial: boolean\n): typeof currentState {\n  const actions: UnknownAction[] = [];\n  const historyValue = {\n    ...currentState.historyValue\n  };\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  const internalQueue = [...currentState._internalQueue];\n\n  // Exit states\n  if (!isInitial) {\n    exitStates(filteredTransitions, mutConfiguration, historyValue, actions);\n  }\n\n  // Execute transition content\n  actions.push(...filteredTransitions.flatMap((t) => t.actions));\n\n  // Enter states\n  enterStates(\n    event,\n    filteredTransitions,\n    mutConfiguration,\n    actions,\n    internalQueue,\n    currentState,\n    historyValue,\n    isInitial,\n    actorCtx\n  );\n\n  const nextConfiguration = [...mutConfiguration];\n\n  const done = isInFinalState(nextConfiguration);\n\n  if (done) {\n    const finalActions = nextConfiguration\n      .sort((a, b) => b.order - a.order)\n      .flatMap((state) => state.exit);\n    actions.push(...finalActions);\n  }\n\n  try {\n    const nextState = resolveActionsAndContext(\n      actions,\n      event,\n      currentState,\n      actorCtx\n    );\n\n    const output = done\n      ? getOutput(nextConfiguration, nextState.context, event, actorCtx.self)\n      : undefined;\n\n    internalQueue.push(...nextState._internalQueue);\n\n    return cloneState(currentState, {\n      configuration: nextConfiguration,\n      historyValue,\n      _internalQueue: internalQueue,\n      context: nextState.context,\n      status: done ? 'done' : currentState.status,\n      output,\n      children: nextState.children\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction enterStates(\n  event: AnyEventObject,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  currentState: AnyState,\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean,\n  actorContext: AnyActorContext\n): void {\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentState.machine.root);\n  }\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutConfiguration.add(stateNodeToEnter);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(invoke(invokeDef));\n    }\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      for (const stateNode of statesForDefaultEntry) {\n        const initialActions = stateNode.initial!.actions;\n        actions.push(...initialActions);\n      }\n    }\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent!;\n\n      if (!parent.parent) {\n        continue;\n      }\n\n      internalQueue.push(\n        createDoneStateEvent(\n          parent!.id,\n          stateNodeToEnter.output\n            ? resolveOutput(\n                stateNodeToEnter.output,\n                currentState.context,\n                event,\n                actorContext.self\n              )\n            : undefined\n        )\n      );\n\n      if (parent.parent) {\n        const grandparent = parent.parent;\n\n        if (grandparent.type === 'parallel') {\n          if (\n            getChildren(grandparent).every((parentNode) =>\n              isInFinalState([...mutConfiguration], parentNode)\n            )\n          ) {\n            internalQueue.push(createDoneStateEvent(grandparent.id));\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    for (const s of t.target || []) {\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const ancestor = getTransitionDomain(t, historyValue);\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      addAncestorStatesToEnter(\n        s,\n        ancestor,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode.parent!,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    } else {\n      const targets = resolveHistoryTarget<TContext, TEvent>(stateNode);\n      for (const s of targets) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of targets) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    }\n  } else {\n    statesToEnter.add(stateNode);\n    if (stateNode.type === 'compound') {\n      statesForDefaultEntry.add(stateNode);\n      const initialStates = stateNode.initial.target;\n\n      for (const initialState of initialStates) {\n        addDescendantStatesToEnter(\n          initialState,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const initialState of initialStates) {\n        addAncestorStatesToEnter(\n          initialState,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  const properAncestors = getProperAncestors(stateNode, toStateNode);\n  for (const anc of properAncestors) {\n    statesToEnter.add(anc);\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction exitStates(\n  transitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  actions: UnknownAction[]\n) {\n  const statesToExit = computeExitSet(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      historyValue[historyNode.id] =\n        Array.from(mutConfiguration).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    actions.push(...s.exit, ...s.invoke.map((def) => stop(def.id)));\n    mutConfiguration.delete(s);\n  }\n}\n\ninterface BuiltinAction {\n  (): void;\n  resolve: (\n    actorContext: AnyActorContext,\n    state: AnyState,\n    actionArgs: ActionArgs<any, any, any, any>,\n    action: unknown\n  ) => [newState: AnyState, params: unknown, actions?: UnknownAction[]];\n  execute: (actorContext: AnyActorContext, params: unknown) => void;\n}\n\nexport function resolveActionsAndContext<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  actions: UnknownAction[],\n  event: TExpressionEvent,\n  currentState: AnyState,\n  actorCtx: AnyActorContext\n): AnyState {\n  const { machine } = currentState;\n  // TODO: this `cloneState` is really just a hack to prevent infinite loops\n  // we need to take another look at how internal queue is managed\n  let intermediateState = cloneState(currentState, {\n    _internalQueue: []\n  });\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        (\n          machine.implementations.actions as Record<\n            string,\n            ActionFunction<\n              MachineContext,\n              EventObject,\n              EventObject,\n              ParameterizedObject | undefined,\n              ProvidedActor,\n              ParameterizedObject,\n              ParameterizedObject,\n              string\n            >\n          >\n        )[typeof action === 'string' ? action : action.type];\n\n    if (!resolvedAction) {\n      continue;\n    }\n\n    const actionArgs = {\n      context: intermediateState.context,\n      event,\n      self: actorCtx?.self,\n      system: actorCtx?.system,\n      action: isInline\n        ? undefined\n        : typeof action === 'string'\n        ? { type: action }\n        : typeof action.params === 'function'\n        ? {\n            type: action.type,\n            params: action.params({ context: intermediateState.context, event })\n          }\n        : // TS isn't able to narrow it down here\n          (action as { type: string })\n    };\n\n    if (!('resolve' in resolvedAction)) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        resolvedAction(actionArgs);\n      } else {\n        actorCtx?.defer(() => {\n          resolvedAction(actionArgs);\n        });\n      }\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorCtx,\n      intermediateState,\n      actionArgs,\n      resolvedAction // this holds all params\n    );\n    intermediateState = nextState;\n\n    if ('execute' in resolvedAction) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        builtinAction.execute(actorCtx!, params);\n      } else {\n        actorCtx?.defer(builtinAction.execute.bind(null, actorCtx!, params));\n      }\n    }\n\n    if (actions) {\n      intermediateState = resolveActionsAndContext(\n        actions,\n        event,\n        intermediateState,\n        actorCtx\n      );\n    }\n  }\n\n  return intermediateState;\n}\n\nexport function macrostep(\n  state: AnyState,\n  event: EventObject,\n  actorCtx: AnyActorContext\n): {\n  state: typeof state;\n  microstates: Array<typeof state>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextState = state;\n  const states: AnyState[] = [];\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextState = stopStep(event, nextState, actorCtx);\n    states.push(nextState);\n\n    return {\n      state: nextState,\n      microstates: states\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const transitions = selectTransitions(nextEvent, nextState);\n    nextState = microstep(transitions, state, actorCtx, nextEvent, false);\n    states.push(nextState);\n  }\n\n  while (nextState.status === 'active') {\n    let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);\n\n    if (!enabledTransitions.length) {\n      if (!nextState._internalQueue.length) {\n        break;\n      } else {\n        nextEvent = nextState._internalQueue[0];\n        const transitions = selectTransitions(nextEvent, nextState);\n        nextState = microstep(\n          transitions,\n          nextState,\n          actorCtx,\n          nextEvent,\n          false\n        );\n        nextState._internalQueue.shift();\n\n        states.push(nextState);\n      }\n    } else {\n      nextState = microstep(\n        enabledTransitions,\n        nextState,\n        actorCtx,\n        nextEvent,\n        false\n      );\n\n      states.push(nextState);\n    }\n  }\n\n  if (nextState.status !== 'active') {\n    // Perform the stop step to ensure that child actors are stopped\n    stopStep(nextEvent, nextState, actorCtx);\n  }\n\n  return {\n    state: nextState,\n    microstates: states\n  };\n}\n\nfunction stopStep(\n  event: AnyEventObject,\n  nextState: AnyState,\n  actorCtx: AnyActorContext\n) {\n  const actions: UnknownAction[] = [];\n\n  for (const stateNode of nextState.configuration.sort(\n    (a, b) => b.order - a.order\n  )) {\n    actions.push(...stateNode.exit);\n  }\n\n  for (const child of Object.values(nextState.children)) {\n    actions.push(stop(child));\n  }\n\n  return resolveActionsAndContext(actions, event, nextState, actorCtx);\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyState\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyState,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState.configuration.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, null)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState.configuration),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const configuration = getConfiguration(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...configuration]);\n}\n\nexport function stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a as StateValueMap);\n  const bKeys = Object.keys(b as StateValueMap);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nexport function getInitialConfiguration(\n  rootNode: AnyStateNode\n): AnyStateNode[] {\n  const configuration: AnyStateNode[] = [];\n  const initialTransition = rootNode.initial;\n\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>([rootNode]);\n\n  computeEntrySet(\n    [initialTransition],\n    {},\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    configuration.push(stateNodeToEnter);\n  }\n\n  return configuration;\n}\n","import isDevelopment from '#is-development';\nimport { STATE_DELIMITER } from './constants.ts';\nimport { memo } from './memo.ts';\nimport { MachineSnapshot } from './StateMachine.ts';\nimport type { StateNode } from './StateNode.ts';\nimport {\n  getConfiguration,\n  getStateNodes,\n  getStateValue\n} from './stateUtils.ts';\nimport { TypegenDisabled, TypegenEnabled } from './typegenTypes.ts';\nimport type {\n  ProvidedActor,\n  ActorRefFrom,\n  AnyState,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  PersistedMachineState,\n  Prop,\n  StateConfig,\n  StateValue,\n  TODO,\n  AnyActorRef,\n  Compute,\n  EventDescriptor\n} from './types.ts';\nimport { flatten, matchesState } from './utils.ts';\n\ntype ComputeConcreteChildren<TActor extends ProvidedActor> = {\n  [A in TActor as 'id' extends keyof A\n    ? A['id'] & string\n    : never]?: ActorRefFrom<A['logic']>;\n};\n\ntype ComputeChildren<TActor extends ProvidedActor> =\n  // only proceed further if all configured `src`s are literal strings\n  string extends TActor['src']\n    ? // TODO: replace with UnknownActorRef~\n      // TODO: consider adding `| undefined` here\n      Record<string, AnyActorRef>\n    : Compute<\n        ComputeConcreteChildren<TActor> &\n          // check if all actors have IDs\n          (undefined extends TActor['id']\n            ? // if they don't we need to create an index signature containing all possible actor types\n              {\n                [id: string]: TActor extends any\n                  ? ActorRefFrom<TActor['logic']> | undefined\n                  : never;\n              }\n            : {})\n      >;\n\nexport function isStateConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(state: any): state is StateConfig<TContext, TEvent> {\n  if (typeof state !== 'object' || state === null) {\n    return false;\n  }\n\n  return 'value' in state;\n}\n\n/**\n * @deprecated Use `isStateConfig(object)` or `state instanceof State` instead.\n */\nexport const isState = isStateConfig;\nexport class State<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TResolvedTypesMeta = TypegenDisabled\n> {\n  public tags: Set<string>;\n\n  public value: StateValue;\n  /**\n   * Indicates whether the state is a final state.\n   */\n  public status: 'active' | 'done' | 'error' | 'stopped';\n  /**\n   * The output data of the top-level finite state.\n   */\n  public error: unknown;\n  public context: TContext;\n  public historyValue: Readonly<HistoryValue<TContext, TEvent>> = {};\n  public _internalQueue: Array<TEvent>;\n  /**\n   * The enabled state nodes representative of the state value.\n   */\n  public configuration: Array<StateNode<TContext, TEvent>>;\n  /**\n   * An object mapping actor names to spawned/invoked actors.\n   */\n  public children: ComputeChildren<TActor>;\n\n  /**\n   * Creates a new State instance for the given `stateValue` and `context`.\n   * @param stateValue\n   * @param context\n   */\n  public static from<\n    TContext extends MachineContext,\n    TEvent extends EventObject = EventObject\n  >(\n    stateValue:\n      | State<\n          TContext,\n          TEvent,\n          TODO,\n          any, // tags\n          any // typegen\n        >\n      | StateValue,\n    context: TContext = {} as TContext,\n    machine: AnyStateMachine\n  ): State<\n    TContext,\n    TEvent,\n    TODO,\n    any, // tags\n    any // typegen\n  > {\n    if (stateValue instanceof State) {\n      if (stateValue.context !== context) {\n        return new State<TContext, TEvent, TODO, any, any>(\n          {\n            value: stateValue.value,\n            context,\n            meta: {},\n            configuration: [], // TODO: fix,\n            children: {},\n            status: 'active'\n          },\n          machine\n        );\n      }\n\n      return stateValue;\n    }\n\n    const configuration = getConfiguration(\n      getStateNodes(machine.root, stateValue)\n    );\n\n    return new State<TContext, TEvent, TODO, any, any>(\n      {\n        value: stateValue,\n        context,\n        meta: undefined,\n        configuration: Array.from(configuration),\n        children: {},\n        status: 'active'\n      },\n      machine\n    );\n  }\n\n  /**\n   * Creates a new `State` instance that represents the current state of a running machine.\n   *\n   * @param config\n   */\n  constructor(\n    config: StateConfig<TContext, TEvent>,\n    public machine: AnyStateMachine\n  ) {\n    this.context = config.context;\n    this._internalQueue = config._internalQueue ?? [];\n    this.historyValue = config.historyValue || {};\n    this.matches = this.matches.bind(this);\n    this.toStrings = this.toStrings.bind(this);\n    this.configuration =\n      config.configuration ??\n      Array.from(getConfiguration(getStateNodes(machine.root, config.value)));\n    this.children = config.children as any;\n\n    this.value = getStateValue(machine.root, this.configuration);\n    this.tags = new Set(flatten(this.configuration.map((sn) => sn.tags)));\n    this.status = config.status;\n    (this as any).output = config.output;\n    (this as any).error = config.error;\n  }\n\n  /**\n   * Returns an array of all the string leaf state node paths.\n   * @param stateValue\n   * @param delimiter The character(s) that separate each subpath in the string state node path.\n   */\n  public toStrings(stateValue: StateValue = this.value): string[] {\n    if (typeof stateValue === 'string') {\n      return [stateValue];\n    }\n    const valueKeys = Object.keys(stateValue);\n\n    return valueKeys.concat(\n      ...valueKeys.map((key) =>\n        this.toStrings(stateValue[key]).map((s) => key + STATE_DELIMITER + s)\n      )\n    );\n  }\n\n  public toJSON() {\n    const { configuration, tags, machine, ...jsonValues } = this;\n\n    return { ...jsonValues, tags: Array.from(tags), meta: this.meta };\n  }\n\n  /**\n   * Whether the current state value is a subset of the given parent state value.\n   * @param parentStateValue\n   */\n  public matches<\n    TSV extends TResolvedTypesMeta extends TypegenEnabled\n      ? Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'matchesStates'>\n      : StateValue\n  >(parentStateValue: TSV): boolean {\n    return matchesState(parentStateValue as any, this.value);\n  }\n\n  /**\n   * Whether the current state configuration has a state node with the specified `tag`.\n   * @param tag\n   */\n  public hasTag(tag: TTag): boolean {\n    return this.tags.has(tag as string);\n  }\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden transition\n   * to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  public can(event: TEvent): boolean {\n    if (isDevelopment && !this.machine) {\n      console.warn(\n        `state.can(...) used outside of a machine-created State object; this will always return false.`\n      );\n    }\n\n    const transitionData = this.machine.getTransitionData(this as any, event);\n\n    return (\n      !!transitionData?.length &&\n      // Check that at least one transition is not forbidden\n      transitionData.some((t) => t.target !== undefined || t.actions.length)\n    );\n  }\n\n  /**\n   * The next events that will cause a transition from the current state.\n   */\n  public get nextEvents(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'nextEvents', () => {\n      return [\n        ...new Set(flatten([...this.configuration.map((sn) => sn.ownEvents)]))\n      ];\n    });\n  }\n\n  public get meta(): Record<string, any> {\n    return this.configuration.reduce((acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    }, {} as Record<string, any>);\n  }\n}\n\nexport function cloneState<TState extends AnyState>(\n  state: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return new State(\n    { ...state, ...config } as StateConfig<any, any>,\n    state.machine\n  ) as TState;\n}\n\nexport function getPersistedState<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TOutput,\n  TResolvedTypesMeta = TypegenDisabled\n>(\n  state: MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  >\n): PersistedMachineState<\n  TContext,\n  TEvent,\n  TActor,\n  TTag,\n  TOutput,\n  TResolvedTypesMeta\n> {\n  const { configuration, tags, machine, children, ...jsonValues } = state;\n\n  const childrenJson: Partial<\n    PersistedMachineState<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >['children']\n  > = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    childrenJson[id as keyof typeof childrenJson] = {\n      state: child.getPersistedState?.(),\n      src: child.src\n    };\n  }\n\n  return {\n    ...jsonValues,\n    children: childrenJson\n  } as PersistedMachineState<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  >;\n}\n","import { createErrorActorEvent } from './eventUtils.ts';\nimport { ActorStatus, createActor } from './interpreter.ts';\nimport {\n  ActorRefFrom,\n  AnyActorContext,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyEventObject,\n  AnyState,\n  InputFrom,\n  IsLiteralString,\n  ProvidedActor,\n  Snapshot,\n  TODO\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? 'id' extends keyof TActor\n    ? [\n        options: {\n          id: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        }\n      ]\n    : [\n        options?: {\n          id?: string;\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        }\n      ]\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> = IsLiteralString<\n  TActor['src']\n> extends true\n  ? <TSrc extends TActor['src']>(\n      logic: TSrc,\n      ...[options = {} as any]: SpawnOptions<TActor, TSrc>\n    ) => ActorRefFrom<(TActor & { src: TSrc })['logic']>\n  : // TODO: do not accept machines without all implementations\n    <TLogic extends AnyActorLogic | string>(\n      src: TLogic,\n      options?: {\n        id?: string;\n        systemId?: string;\n        input?: unknown;\n        syncSnapshot?: boolean;\n      }\n    ) => TLogic extends string ? AnyActorRef : ActorRefFrom<TLogic>;\n\nexport function createSpawner(\n  actorContext: AnyActorContext,\n  { machine, context }: AnyState,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = (src, options = {}) => {\n    const { systemId } = options;\n    if (typeof src === 'string') {\n      const referenced = resolveReferencedActor(\n        machine.implementations.actors[src]\n      );\n\n      if (!referenced) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const input = 'input' in options ? options.input : referenced.input;\n\n      // TODO: this should also receive `src`\n      const actorRef = createActor(referenced.src, {\n        id: options.id,\n        parent: actorContext.self,\n        input:\n          typeof input === 'function'\n            ? input({\n                context,\n                event,\n                self: actorContext.self\n              })\n            : input,\n        systemId\n      }) as any;\n      spawnedChildren[actorRef.id] = actorRef;\n\n      if (options.syncSnapshot) {\n        actorRef.subscribe({\n          next: (snapshot: Snapshot<unknown>) => {\n            if (snapshot.status === 'active') {\n              actorContext.self.send({\n                type: `xstate.snapshot.${actorRef.id}`,\n                snapshot\n              });\n            }\n          },\n          error: () => {\n            /* TODO */\n          }\n        });\n      }\n      return actorRef;\n    } else {\n      // TODO: this should also receive `src`\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorContext.self,\n        input: options.input,\n        systemId\n      });\n\n      if (options.syncSnapshot) {\n        actorRef.subscribe({\n          next: (snapshot: Snapshot<unknown>) => {\n            if (snapshot.status === 'active') {\n              actorContext.self.send({\n                type: `xstate.snapshot.${actorRef.id}`,\n                snapshot,\n                id: actorRef.id\n              });\n            }\n          },\n          error: () => {\n            /* TODO */\n          }\n        });\n      }\n\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorContext.defer(() => {\n      if (actorRef.status === ActorStatus.Stopped) {\n        return;\n      }\n      try {\n        actorRef.start?.();\n      } catch (err) {\n        actorContext.self.send(createErrorActorEvent(actorRef.id, err));\n        return;\n      }\n    });\n    return actorRef;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorContext,\n  AnyActorRef,\n  AnyEventObject,\n  AnyState,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorContext: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n) {\n  if (!state.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any, any> = {\n    context: state.context,\n    event: actionArgs.event,\n    action: actionArgs.action,\n    spawn: createSpawner(\n      actorContext,\n      state,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorContext?.self,\n    system: actorContext?.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, state.context, partialUpdate);\n\n  return [\n    cloneState(state, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...state.children,\n            ...spawnedChildren\n          }\n        : state.children\n    })\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject = AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TEvent extends EventObject = EventObject,\n  TActor extends ProvidedActor = ProvidedActor\n>(\n  assignment:\n    | Assigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor\n      >\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor\n      >\n): AssignAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TActor> {\n  function assign(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import isDevelopment from '#is-development';\nimport {\n  EventObject,\n  ChooseBranch,\n  MachineContext,\n  AnyActorContext,\n  AnyState,\n  ActionArgs,\n  ParameterizedObject,\n  NoInfer,\n  ProvidedActor\n} from '../types.ts';\nimport { evaluateGuard } from '../guards.ts';\nimport { toArray } from '../utils.ts';\n\nfunction resolveChoose(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    branches\n  }: {\n    branches: Array<\n      ChooseBranch<\n        MachineContext,\n        EventObject,\n        EventObject,\n        ProvidedActor,\n        ParameterizedObject,\n        ParameterizedObject,\n        string\n      >\n    >;\n  }\n) {\n  const matchedActions = branches.find((condition) => {\n    return (\n      !condition.guard ||\n      evaluateGuard(condition.guard, state.context, actionArgs.event, state)\n    );\n  })?.actions;\n\n  return [state, undefined, toArray(matchedActions)];\n}\n\nexport interface ChooseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n}\n\nexport function choose<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n>(\n  branches: ReadonlyArray<\n    ChooseBranch<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TActor,\n      NoInfer<TAction>,\n      NoInfer<TGuard>,\n      TDelay\n    >\n  >\n): ChooseAction<\n  TContext,\n  TExpressionEvent,\n  TExpressionAction,\n  TEvent,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay\n> {\n  function choose(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  choose.type = 'xstate.choose';\n  choose.branches = branches;\n\n  choose.resolve = resolveChoose;\n\n  return choose;\n}\n","import isDevelopment from '#is-development';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  LogExpr,\n  MachineContext,\n  ParameterizedObject\n} from '../types.ts';\n\ntype ResolvableLogValue<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = string | LogExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n\nfunction resolveLog(\n  _: AnyActorContext,\n  state: AnyState,\n  actionArgs: ActionArgs<any, any, any, any>,\n  {\n    value,\n    label\n  }: {\n    value: ResolvableLogValue<any, any, any, any>;\n    label: string | undefined;\n  }\n) {\n  return [\n    state,\n    {\n      value: typeof value === 'function' ? value(actionArgs) : value,\n      label\n    }\n  ];\n}\n\nfunction executeLog(\n  { logger }: AnyActorContext,\n  { value, label }: { value: unknown; label: string | undefined }\n) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n\nexport interface LogAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n}\n\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nexport function log<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n>(\n  value: ResolvableLogValue<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent\n  > = ({ context, event }) => ({ context, event }),\n  label?: string\n): LogAction<TContext, TExpressionEvent, TExpressionAction, TEvent> {\n  function log(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n\n  return log;\n}\n","import isDevelopment from '#is-development';\nimport {\n  Actions,\n  ActionArgs,\n  UnknownAction,\n  AnyActorContext,\n  AnyState,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  SingleOrArray,\n  NoInfer,\n  ProvidedActor\n} from '../types.ts';\nimport { toArray } from '../utils.ts';\n\nfunction resolvePure(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    get\n  }: {\n    get: ({\n      context,\n      event\n    }: {\n      context: MachineContext;\n      event: EventObject;\n    }) => SingleOrArray<UnknownAction> | undefined;\n  }\n) {\n  return [\n    state,\n    undefined,\n    toArray(get({ context: args.context, event: args.event }))\n  ];\n}\n\nexport interface PureAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TEvent?: TEvent;\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n}\n\nexport function pure<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TEvent extends EventObject = TExpressionEvent,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n>(\n  getActions: ({\n    context,\n    event\n  }: {\n    context: TContext;\n    event: TExpressionEvent;\n  }) =>\n    | Actions<\n        TContext,\n        TExpressionEvent,\n        NoInfer<TEvent>,\n        undefined,\n        TActor,\n        NoInfer<TAction>,\n        NoInfer<TGuard>,\n        TDelay\n      >\n    | undefined\n): PureAction<\n  TContext,\n  TExpressionEvent,\n  TExpressionAction,\n  TEvent,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay\n> {\n  function pure(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  pure.type = 'xstate.pure';\n  pure.get = getActions;\n\n  pure.resolve = resolvePure;\n\n  return pure;\n}\n","import isDevelopment from '#is-development';\nimport { cloneState } from '../State.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyActor,\n  AnyState,\n  DelayExpr,\n  EventObject,\n  MachineContext,\n  NoInfer,\n  RaiseActionOptions,\n  SendExpr,\n  ParameterizedObject\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >\n      | undefined;\n  }\n) {\n  const delaysMap = state.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function' ? eventOrExpr(args) : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function' ? configDelay(args) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args) : delay;\n  }\n  return [\n    typeof resolvedDelay !== 'number'\n      ? cloneState(state, {\n          _internalQueue: state._internalQueue.concat(resolvedEvent)\n        })\n      : state,\n    { event: resolvedEvent, id, delay: resolvedDelay }\n  ];\n}\n\nfunction executeRaise(\n  actorContext: AnyActorContext,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  if (typeof params.delay === 'number') {\n    (actorContext.self as AnyActor).delaySend(\n      params as typeof params & { delay: number }\n    );\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject = TExpressionEvent,\n  TExpressionAction extends ParameterizedObject | undefined =\n    | ParameterizedObject\n    | undefined,\n  TDelay extends string = string\n>(\n  eventOrExpr:\n    | NoInfer<TEvent>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        NoInfer<TEvent>,\n        TEvent\n      >,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    NoInfer<TEvent>,\n    NoInfer<TDelay>\n  >\n): RaiseAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TDelay> {\n  function raise(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n","import type { StateNode } from './StateNode.ts';\nimport type { State } from './State.ts';\nimport type { ActorStatus, Clock, Actor } from './interpreter.ts';\nimport type { MachineSnapshot, StateMachine } from './StateMachine.ts';\nimport {\n  TypegenDisabled,\n  ResolveTypegenMeta,\n  TypegenConstraint,\n  MarkAllImplementationsAsProvided,\n  AreAllImplementationsAssumedToBeProvided\n} from './typegenTypes.ts';\nimport { PromiseActorLogic } from './actors/promise.ts';\nimport { Guard, GuardPredicate, UnknownGuard } from './guards.ts';\nimport { Spawner } from './spawn.ts';\nimport { AssignArgs } from './actions/assign.ts';\nimport { InspectionEvent } from './system.js';\n\nexport type HomomorphicPick<T, K extends keyof any> = {\n  [P in keyof T as P & K]: T[P];\n};\nexport type HomomorphicOmit<T, K extends keyof any> = {\n  [P in keyof T as Exclude<P, K>]: T[P];\n};\n\n/**\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.\n * It especially is a problem when the union has a function member, like here:\n *\n * ```ts\n * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;\n * test((arg) => {}) // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same value space as `unknown`.\n */\nexport type NonReducibleUnknown = {} | null | undefined;\nexport type AnyFunction = (...args: any[]) => any;\n\ntype ReturnTypeOrValue<T> = T extends AnyFunction ? ReturnType<T> : T;\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\nexport type IsNever<T> = [T] extends [never] ? true : false;\n\nexport type Compute<A extends any> = { [K in keyof A]: A[K] } & unknown;\nexport type Prop<T, K> = K extends keyof T ? T[K] : never;\nexport type Values<T> = T[keyof T];\nexport type Merge<M, N> = Omit<M, keyof N> & N;\nexport type IndexByProp<T extends Record<P, string>, P extends keyof T> = {\n  [E in T as E[P]]: E;\n};\n\nexport type IndexByType<T extends { type: string }> = IndexByProp<T, 'type'>;\n\nexport type Equals<A1 extends any, A2 extends any> = (<A>() => A extends A2\n  ? true\n  : false) extends <A>() => A extends A1 ? true : false\n  ? true\n  : false;\nexport type IsAny<T> = Equals<T, any>;\nexport type Cast<A, B> = A extends B ? A : B;\nexport type NoInfer<T> = [T][T extends any ? 0 : any];\nexport type LowInfer<T> = T & {};\n\nexport type MetaObject = Record<string, any>;\n\nexport type Lazy<T> = () => T;\nexport type MaybeLazy<T> = T | Lazy<T>;\n\n/**\n * The full definition of an event, with a string `type`.\n */\nexport interface EventObject {\n  /**\n   * The type of event that is sent.\n   */\n  type: string;\n}\n\nexport interface AnyEventObject extends EventObject {\n  [key: string]: any;\n}\n\nexport interface ParameterizedObject {\n  type: string;\n  params?: Record<string, unknown>;\n}\n\nexport interface UnifiedArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    TEvent,\n    MachineSnapshot<TContext, TEvent, ProvidedActor, string, unknown>\n  >;\n  system: ActorSystem<any>;\n}\n\nexport type MachineContext = Record<string, any>;\n\nexport interface ActionArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> extends UnifiedArg<TContext, TExpressionEvent, TEvent> {\n  action: TExpressionAction;\n}\n\nexport type InputFrom<T extends AnyActorLogic> = T extends StateMachine<\n  infer _TContext,\n  infer _TEvent,\n  infer _TActor,\n  infer _TAction,\n  infer _TGuard,\n  infer _TDelay,\n  infer _TTag,\n  infer TInput,\n  infer _TOutput,\n  infer _TResolvedTypesMeta\n>\n  ? TInput\n  : T extends ActorLogic<\n      infer _TSnapshot,\n      infer _TEvent,\n      infer TInput,\n      infer _TPersisted,\n      infer _TSystem\n    >\n  ? TInput\n  : never;\n\nexport type OutputFrom<T extends AnyActorLogic> = T extends ActorLogic<\n  infer TSnapshot,\n  infer _TEvent,\n  infer _TInput,\n  infer _TPersisted,\n  infer _TSystem\n>\n  ? (TSnapshot & { status: 'done' })['output']\n  : never;\n\nexport type ActionFunction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = {\n  (\n    args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ): void;\n  _out_TEvent?: TEvent; // TODO: it feels like we should be able to remove this since now `TEvent` is \"observable\" by `self`\n  _out_TActor?: TActor;\n  _out_TAction?: TAction;\n  _out_TGuard?: TGuard;\n  _out_TDelay?: TDelay;\n};\n\nexport interface ChooseBranch<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject = TExpressionEvent,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n> {\n  guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;\n  actions: Actions<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n}\n\nexport type NoRequiredParams<T extends ParameterizedObject> = T extends any\n  ? { type: T['type'] } extends T\n    ? T['type']\n    : never\n  : never;\n\ntype ConditionalRequired<T, Condition extends boolean> = Condition extends true\n  ? Required<T>\n  : T;\n\nexport type WithDynamicParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  T extends ParameterizedObject\n> = T extends any\n  ? ConditionalRequired<\n      {\n        type: T['type'];\n        params?:\n          | T['params']\n          | (({\n              context,\n              event\n            }: {\n              context: TContext;\n              event: TExpressionEvent;\n            }) => T['params']);\n      },\n      undefined extends T['params'] ? false : true\n    >\n  : never;\n\nexport type Action<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  // TODO: consider merging `NoRequiredParams` and `WithDynamicParams` into one\n  // this way we could iterate over `TAction` (and `TGuard` in the `Guard` type) once and not twice\n  | NoRequiredParams<TAction>\n  | WithDynamicParams<TContext, TExpressionEvent, TAction>\n  | ActionFunction<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TExpressionAction,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay\n    >;\n\nexport type UnknownAction = Action<\n  MachineContext,\n  EventObject,\n  EventObject,\n  ParameterizedObject | undefined,\n  ProvidedActor,\n  ParameterizedObject,\n  ParameterizedObject,\n  string\n>;\n\nexport type Actions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = SingleOrArray<\n  Action<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    TExpressionAction,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >\n>;\n\nexport type StateKey = string | AnyState;\n\nexport interface StateValueMap {\n  [key: string]: StateValue;\n}\n\n/**\n * The string or object representing the state value relative to the parent state node.\n *\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success: \"someChildState\" }`.\n */\nexport type StateValue = string | StateValueMap;\n\nexport type TransitionTarget = SingleOrArray<string>;\n\nexport interface TransitionConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  guard?: Guard<TContext, TExpressionEvent, undefined, TGuard>;\n  actions?: Actions<\n    TContext,\n    TExpressionEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  reenter?: boolean;\n  target?: TransitionTarget | undefined;\n  meta?: Record<string, any>;\n  description?: string;\n}\n\nexport interface InitialTransitionConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> extends TransitionConfig<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  > {\n  target: TransitionTarget;\n}\n\nexport type AnyTransitionConfig = TransitionConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\nexport interface InvokeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> {\n  id: string;\n\n  systemId: string | undefined;\n  /**\n   * The source of the actor logic to be invoked\n   */\n  src: string;\n\n  input?:\n    | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n    | NonReducibleUnknown;\n  /**\n   * The transition to take upon the invoked child machine reaching its final top-level state.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneActorEvent<unknown>,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n  /**\n   * The transition to take upon the invoked child machine sending an error event.\n   */\n  onError?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          ErrorActorEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n\n  onSnapshot?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          SnapshotEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >;\n\n  toJSON: () => Omit<\n    InvokeDefinition<TContext, TEvent, TActor, TAction, TGuard, TDelay>,\n    'onDone' | 'onError' | 'toJSON'\n  >;\n}\n\ntype Delay<TDelay extends string> = TDelay | number;\n\nexport type DelayedTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  | {\n      [K in Delay<TDelay>]?:\n        | string\n        | SingleOrArray<\n            TransitionConfig<\n              TContext,\n              TEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n    }\n  | Array<\n      TransitionConfig<\n        TContext,\n        TEvent,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay\n      > & {\n        delay:\n          | Delay<TDelay>\n          | ((args: UnifiedArg<TContext, TEvent, TEvent>) => Delay<TDelay>);\n      }\n    >;\n\nexport type StateTypes =\n  | 'atomic'\n  | 'compound'\n  | 'parallel'\n  | 'final'\n  | 'history'\n  | string; // TODO: remove once TS fixes this type-widening issue\n\nexport type SingleOrArray<T> = readonly T[] | T;\n\nexport type StateNodesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNode<TContext, TEvent>;\n};\n\nexport type StatesConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TOutput\n> = {\n  [K in string]: StateNodeConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TOutput\n  >;\n};\n\nexport type StatesDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in string]: StateNodeDefinition<TContext, TEvent>;\n};\n\nexport type TransitionConfigTarget = string | undefined;\n\nexport type TransitionConfigOrTarget<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = SingleOrArray<\n  | TransitionConfigTarget\n  | TransitionConfig<\n      TContext,\n      TExpressionEvent,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay\n    >\n>;\n\nexport type TransitionsConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> =\n  | {\n      [K in EventDescriptor<TEvent>]?: TransitionConfigOrTarget<\n        TContext,\n        ExtractEvent<TEvent, K>,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay\n      >;\n    };\n\ntype PartialEventDescriptor<TEventType extends string> =\n  TEventType extends `${infer TLeading}.${infer TTail}`\n    ? `${TLeading}.*` | `${TLeading}.${PartialEventDescriptor<TTail>}`\n    : never;\n\nexport type EventDescriptor<TEvent extends EventObject> =\n  | TEvent['type']\n  | PartialEventDescriptor<TEvent['type']>\n  | '*';\n\ntype NormalizeDescriptor<TDescriptor extends string> = TDescriptor extends '*'\n  ? string\n  : TDescriptor extends `${infer TLeading}.*`\n  ? `${TLeading}.${string}`\n  : TDescriptor;\n\nexport type IsLiteralString<T extends string> = string extends T ? false : true;\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TSpecificActor extends ProvidedActor\n> = TSpecificActor extends { src: infer TSrc }\n  ? Compute<\n      {\n        systemId?: string;\n        /**\n         * The source of the machine to be invoked, or the machine itself.\n         */\n        src: TSrc;\n\n        // TODO: currently we do not enforce required inputs here\n        // in a sense, we shouldn't - they could be provided within the `implementations` object\n        // how do we verify if the required input has been provided?\n        input?:\n          | Mapper<TContext, TEvent, InputFrom<TSpecificActor['logic']>, TEvent>\n          | InputFrom<TSpecificActor['logic']>;\n        /**\n         * The transition to take upon the invoked child machine reaching its final top-level state.\n         */\n        onDone?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                DoneActorEvent<OutputFrom<TSpecificActor['logic']>>,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n        /**\n         * The transition to take upon the invoked child machine sending an error event.\n         */\n        onError?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                ErrorActorEvent,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n\n        onSnapshot?:\n          | string\n          | SingleOrArray<\n              TransitionConfigOrTarget<\n                TContext,\n                SnapshotEvent<SnapshotFrom<TSpecificActor['logic']>>,\n                TEvent,\n                TActor,\n                TAction,\n                TGuard,\n                TDelay\n              >\n            >;\n      } & (TSpecificActor['id'] extends string\n        ? {\n            /**\n             * The unique identifier for the invoked machine. If not specified, this\n             * will be the machine's own `id`, or the URL (from `src`).\n             */\n            id: TSpecificActor['id'];\n          }\n        : {\n            /**\n             * The unique identifier for the invoked machine. If not specified, this\n             * will be the machine's own `id`, or the URL (from `src`).\n             */\n            id?: string;\n          })\n    >\n  : never;\n\nexport type InvokeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string\n> = IsLiteralString<TActor['src']> extends true\n  ? DistributeActors<TContext, TEvent, TActor, TAction, TGuard, TDelay, TActor>\n  : {\n      /**\n       * The unique identifier for the invoked machine. If not specified, this\n       * will be the machine's own `id`, or the URL (from `src`).\n       */\n      id?: string;\n\n      systemId?: string;\n      /**\n       * The source of the machine to be invoked, or the machine itself.\n       */\n      src: AnyActorLogic | string; // TODO: fix types\n\n      input?:\n        | Mapper<TContext, TEvent, NonReducibleUnknown, TEvent>\n        | NonReducibleUnknown;\n      /**\n       * The transition to take upon the invoked child machine reaching its final top-level state.\n       */\n      onDone?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              DoneActorEvent<any>, // TODO: consider replacing with `unknown`\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n      /**\n       * The transition to take upon the invoked child machine sending an error event.\n       */\n      onError?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              ErrorActorEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n\n      onSnapshot?:\n        | string\n        | SingleOrArray<\n            TransitionConfigOrTarget<\n              TContext,\n              SnapshotEvent,\n              TEvent,\n              TActor,\n              TAction,\n              TGuard,\n              TDelay\n            >\n          >;\n    };\n\nexport type AnyInvokeConfig = InvokeConfig<any, any, any, any, any, any>;\n\nexport interface StateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TOutput\n> {\n  /**\n   * The initial state transition.\n   */\n  initial?:\n    | InitialTransitionConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>\n    | SingleOrArray<string>\n    | undefined;\n  /**\n   * The type of this state node:\n   *\n   *  - `'atomic'` - no child state nodes\n   *  - `'compound'` - nested child state nodes (XOR)\n   *  - `'parallel'` - orthogonal nested child state nodes (AND)\n   *  - `'history'` - history state node\n   *  - `'final'` - final state node\n   */\n  type?: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /**\n   * Indicates whether the state node is a history state node, and what\n   * type of history:\n   * shallow, deep, true (shallow), false (none), undefined (none)\n   */\n  history?: 'shallow' | 'deep' | boolean | undefined;\n  /**\n   * The mapping of state node keys to their state node configurations (recursive).\n   */\n  states?:\n    | StatesConfig<\n        TContext,\n        TEvent,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        NonReducibleUnknown\n      >\n    | undefined;\n  /**\n   * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.\n   */\n  invoke?: SingleOrArray<\n    InvokeConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>\n  >;\n  /**\n   * The mapping of event types to their potential transition(s).\n   */\n  on?: TransitionsConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay>;\n  /**\n   * The action(s) to be executed upon entering the state node.\n   */\n  entry?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * The action(s) to be executed upon exiting the state node.\n   */\n  exit?: Actions<\n    TContext,\n    TEvent,\n    TEvent,\n    undefined,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * The potential transition(s) to be taken upon reaching a final child state node.\n   *\n   * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.\n   */\n  onDone?:\n    | string\n    | SingleOrArray<\n        TransitionConfig<\n          TContext,\n          DoneStateEvent,\n          TEvent,\n          TActor,\n          TAction,\n          TGuard,\n          TDelay\n        >\n      >\n    | undefined;\n  /**\n   * The mapping (or array) of delays (in milliseconds) to their potential transition(s).\n   * The delayed transitions are taken after the specified delay in an interpreter.\n   */\n  after?: DelayedTransitions<TContext, TEvent, TActor, TAction, TGuard, TDelay>;\n\n  /**\n   * An eventless transition that is always taken when this state node is active.\n   */\n  always?: TransitionConfigOrTarget<\n    TContext,\n    TEvent,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n  /**\n   * @private\n   */\n  parent?: StateNode<TContext, TEvent>;\n  /**\n   * The meta data associated with this state node, which will be returned in State instances.\n   */\n  meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n   *\n   * The output data will be evaluated with the current `context` and placed on the `.data` property\n   * of the event.\n   */\n  output?: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n  /**\n   * The unique ID of the state node, which can be referenced as a transition target via the\n   * `#id` syntax.\n   */\n  id?: string | undefined;\n  /**\n   * The order this state node appears. Corresponds to the implicit document order.\n   */\n  order?: number;\n\n  /**\n   * The tags for this state node, which are accumulated into the `state.tags` property.\n   */\n  tags?: SingleOrArray<TTag>;\n  /**\n   * A text description of the state node\n   */\n  description?: string;\n\n  /**\n   * A default target for a history state\n   */\n  target?: string;\n}\n\nexport type AnyStateNodeConfig = StateNodeConfig<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>;\n\nexport interface StateNodeDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  id: string;\n  version?: string | undefined;\n  key: string;\n  type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  initial: InitialTransitionDefinition<TContext, TEvent> | undefined;\n  history: boolean | 'shallow' | 'deep' | undefined;\n  states: StatesDefinition<TContext, TEvent>;\n  on: TransitionDefinitionMap<TContext, TEvent>;\n  transitions: Array<TransitionDefinition<TContext, TEvent>>;\n  // TODO: establish what a definition really is\n  entry: UnknownAction[];\n  exit: UnknownAction[];\n  meta: any;\n  order: number;\n  output?: StateNodeConfig<\n    TContext,\n    TEvent,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    string,\n    unknown\n  >['output'];\n  invoke: Array<InvokeDefinition<TContext, TEvent, TODO, TODO, TODO, TODO>>;\n  description?: string;\n  tags: string[];\n}\n\nexport interface StateMachineDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeDefinition<TContext, TEvent> {}\n\nexport type AnyStateNode = StateNode<any, any>;\n\nexport type AnyStateNodeDefinition = StateNodeDefinition<any, any>;\n\nexport type AnyState = State<\n  any, // context\n  any, // event\n  any, // actor\n  any, // tags\n  any // typegen\n>;\n\nexport type AnyStateMachine = StateMachine<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any, // delays\n  any // tags\n>;\n\nexport type AnyStateConfig = StateConfig<any, AnyEventObject>;\n\nexport interface AtomicStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends StateNodeConfig<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO,\n    TODO\n  > {\n  initial?: undefined;\n  parallel?: false | undefined;\n  states?: undefined;\n  onDone?: undefined;\n}\n\nexport interface HistoryStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends AtomicStateNodeConfig<TContext, TEvent> {\n  history: 'shallow' | 'deep' | true;\n  target: string | undefined;\n}\n\nexport type SimpleOrStateNodeConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> =\n  | AtomicStateNodeConfig<TContext, TEvent>\n  | StateNodeConfig<TContext, TEvent, TODO, TODO, TODO, TODO, TODO, TODO>;\n\nexport type ActionFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string\n> = {\n  [K in TAction['type']]?: ActionFunction<\n    TContext,\n    TEvent,\n    TEvent,\n    TAction extends { type: K } ? TAction : never,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay\n  >;\n};\n\ntype GuardMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TGuard extends ParameterizedObject\n> = {\n  [K in TGuard['type']]?: GuardPredicate<\n    TContext,\n    TEvent,\n    TGuard extends { type: K } ? TGuard : never,\n    TGuard\n  >;\n};\n\nexport type DelayFunctionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TAction extends ParameterizedObject\n> = Record<string, DelayConfig<TContext, TEvent, TAction, TEvent>>;\n\nexport type DelayConfig<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = number | DelayExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\nexport interface MachineImplementationsSimplified<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject\n> {\n  guards: GuardMap<TContext, TEvent, TGuard>;\n  actions: ActionFunctionMap<TContext, TEvent, TActor, TAction>;\n  actors: Record<\n    string,\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input: Mapper<TContext, TEvent, unknown, TEvent> | NonReducibleUnknown;\n      }\n  >;\n  delays: DelayFunctionMap<TContext, TEvent, TAction>;\n}\n\ntype MaybeNarrowedEvent<TIndexedEvents, TCausingLookup, K> = Cast<\n  Prop<\n    TIndexedEvents,\n    K extends keyof TCausingLookup\n      ? TCausingLookup[K]\n      : TIndexedEvents[keyof TIndexedEvents]\n  >,\n  EventObject\n>;\n\ntype MachineImplementationsActions<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingActions'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedActors = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedActors'>,\n  TIndexedActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'indexedActions'\n  >,\n  TIndexedGuards = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedGuards'>,\n  TIndexedDelays = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedDelays'>\n> = {\n  [K in keyof TIndexedActions]?: ActionFunction<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingActions, K>,\n    Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>,\n    Cast<TIndexedActions[K], ParameterizedObject>,\n    Cast<Prop<TIndexedActors, keyof TIndexedActors>, ProvidedActor>,\n    Cast<Prop<TIndexedActions, keyof TIndexedActions>, ParameterizedObject>,\n    Cast<Prop<TIndexedGuards, keyof TIndexedGuards>, ParameterizedObject>,\n    Cast<\n      Prop<TIndexedDelays, keyof TIndexedDelays>,\n      ParameterizedObject\n    >['type']\n  >;\n};\n\ntype MachineImplementationsActors<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingActors = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingActors'\n  >,\n  TIndexedActors = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedActors'>,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  _TInvokeSrcNameMap = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'invokeSrcNameMap'\n  >\n> = {\n  // TODO: this should require `{ src, input }` for required inputs\n  [K in keyof TIndexedActors]?:\n    | Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>\n    | {\n        src: Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>;\n        input:\n          | Mapper<\n              TContext,\n              MaybeNarrowedEvent<TIndexedEvents, TEventsCausingActors, K>,\n              InputFrom<Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>>,\n              Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>\n            >\n          | InputFrom<Cast<Prop<TIndexedActors[K], 'logic'>, AnyActorLogic>>;\n      };\n};\n\ntype MachineImplementationsDelays<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingDelays = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingDelays'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedActions = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'indexedActions'\n  >,\n  TIndexedDelays = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedDelays'>\n> = {\n  [K in keyof TIndexedDelays]?: DelayConfig<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingDelays, K>,\n    // delays in referenced send actions might use specific `TAction`\n    // delays executed by auto-generated send actions related to after transitions won't have that\n    // since they are effectively implicit inline actions\n    | Cast<Prop<TIndexedActions, keyof TIndexedActions>, ParameterizedObject>\n    | undefined,\n    Cast<Prop<TIndexedEvents, keyof TIndexedEvents>, EventObject>\n  >;\n};\n\ntype MachineImplementationsGuards<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TEventsCausingGuards = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'eventsCausingGuards'\n  >,\n  TIndexedEvents = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedEvents'>,\n  TIndexedGuards = Prop<Prop<TResolvedTypesMeta, 'resolved'>, 'indexedGuards'>\n> = {\n  [K in keyof TIndexedGuards]?: Guard<\n    TContext,\n    MaybeNarrowedEvent<TIndexedEvents, TEventsCausingGuards, K>,\n    Cast<TIndexedGuards[K], ParameterizedObject>,\n    Cast<Prop<TIndexedGuards, keyof TIndexedGuards>, ParameterizedObject>\n  >;\n};\n\ntype MakeKeysRequired<T extends string> = { [K in T]: unknown };\n\ntype MaybeMakeMissingImplementationsRequired<\n  TImplementationType,\n  TMissingImplementationsForType,\n  TRequireMissingImplementations\n> = TRequireMissingImplementations extends true\n  ? IsNever<TMissingImplementationsForType> extends true\n    ? {}\n    : {\n        [K in Cast<TImplementationType, string>]: MakeKeysRequired<\n          Cast<TMissingImplementationsForType, string>\n        >;\n      }\n  : {};\n\ntype GenerateActionsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'actions',\n    Prop<TMissingImplementations, 'actions'>,\n    TRequireMissingImplementations\n  > & {\n    actions?: MachineImplementationsActions<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateActorsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'actors',\n    Prop<TMissingImplementations, 'actors'>,\n    TRequireMissingImplementations\n  > & {\n    actors?: MachineImplementationsActors<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateDelaysImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'delays',\n    Prop<TMissingImplementations, 'delays'>,\n    TRequireMissingImplementations\n  > & {\n    delays?: MachineImplementationsDelays<TContext, TResolvedTypesMeta>;\n  }\n>;\n\ntype GenerateGuardsImplementationsPart<\n  TContext extends MachineContext,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations,\n  TMissingImplementations\n> = Compute<\n  MaybeMakeMissingImplementationsRequired<\n    'guards',\n    Prop<TMissingImplementations, 'guards'>,\n    TRequireMissingImplementations\n  > & {\n    guards?: MachineImplementationsGuards<TContext, TResolvedTypesMeta>;\n  }\n>;\n\nexport type InternalMachineImplementations<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TDelay extends string,\n  TResolvedTypesMeta,\n  TRequireMissingImplementations extends boolean = false,\n  TMissingImplementations = Prop<\n    Prop<TResolvedTypesMeta, 'resolved'>,\n    'missingImplementations'\n  >\n> =\n  // TODO: remove per-Generate* Computes\n  Compute<\n    GenerateActionsImplementationsPart<\n      TContext,\n      TResolvedTypesMeta,\n      TRequireMissingImplementations,\n      TMissingImplementations\n    > &\n      GenerateActorsImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      > &\n      GenerateDelaysImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      > &\n      GenerateGuardsImplementationsPart<\n        TContext,\n        TResolvedTypesMeta,\n        TRequireMissingImplementations,\n        TMissingImplementations\n      >\n  >;\n\nexport type MachineImplementations<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TTag extends string = string,\n  TTypesMeta extends TypegenConstraint = TypegenDisabled\n> = InternalMachineImplementations<\n  TContext,\n  TEvent,\n  TActor,\n  TAction,\n  TDelay,\n  ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag>\n>;\n\ntype InitialContext<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput\n> = TContext | ContextFactory<TContext, TActor, TInput>;\n\nexport type ContextFactory<\n  TContext extends MachineContext,\n  TActor extends ProvidedActor,\n  TInput\n> = ({ spawn, input }: { spawn: Spawner<TActor>; input: TInput }) => TContext;\n\nexport type MachineConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor = ProvidedActor,\n  TAction extends ParameterizedObject = ParameterizedObject,\n  TGuard extends ParameterizedObject = ParameterizedObject,\n  TDelay extends string = string,\n  TTag extends string = string,\n  TInput = any,\n  TOutput = unknown,\n  TTypesMeta = TypegenDisabled\n> = (Omit<\n  StateNodeConfig<\n    NoInfer<TContext>,\n    NoInfer<TEvent>,\n    NoInfer<TActor>,\n    NoInfer<TAction>,\n    NoInfer<TGuard>,\n    NoInfer<TDelay>,\n    NoInfer<TTag>,\n    NoInfer<TOutput>\n  >,\n  'output'\n> & {\n  /**\n   * The initial context (extended state)\n   */\n  /**\n   * The machine's own version.\n   */\n  version?: string;\n  types?: MachineTypes<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    TTypesMeta\n  >;\n  // TODO: make it conditionally required\n  output?: Mapper<TContext, DoneStateEvent, TOutput, TEvent> | TOutput;\n}) &\n  (MachineContext extends TContext\n    ? { context?: InitialContext<LowInfer<TContext>, TActor, TInput> }\n    : { context: InitialContext<LowInfer<TContext>, TActor, TInput> });\n\nexport interface ProvidedActor {\n  src: string;\n  logic: AnyActorLogic;\n  id?: string;\n}\n\nexport interface MachineTypes<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TTypesMeta = TypegenDisabled\n> {\n  context?: TContext;\n  events?: TEvent;\n  actors?: TActor;\n  actions?: TAction;\n  guards?: TGuard;\n  delays?: TDelay;\n  tags?: TTag;\n  input?: TInput;\n  output?: TOutput;\n  typegen?: TTypesMeta;\n}\n\nexport interface HistoryStateNode<TContext extends MachineContext>\n  extends StateNode<TContext> {\n  history: 'shallow' | 'deep';\n  target: string | undefined;\n}\n\nexport type HistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Record<string, Array<StateNode<TContext, TEvent>>>;\n\nexport type AnyHistoryValue = HistoryValue<any, any>;\n\nexport type StateFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> = T extends AnyStateMachine\n  ? ReturnType<T['transition']>\n  : T extends (...args: any[]) => AnyStateMachine\n  ? ReturnType<ReturnType<T>['transition']>\n  : never;\n\nexport type Transitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = Array<TransitionDefinition<TContext, TEvent>>;\n\nexport interface DoneActorEvent<TOutput = unknown> {\n  type: `xstate.done.actor.${string}`;\n  output: TOutput;\n}\n\nexport interface ErrorActorEvent<TErrorData = unknown> extends EventObject {\n  type: `xstate.error.actor.${string}`;\n  data: TErrorData;\n}\n\nexport interface SnapshotEvent<\n  TSnapshot extends Snapshot<unknown> = Snapshot<unknown>\n> extends EventObject {\n  type: `xstate.snapshot.${string}`;\n  snapshot: TSnapshot;\n}\n\nexport interface DoneStateEvent<TOutput = unknown> extends EventObject {\n  type: `xstate.done.state.${string}`;\n  output: TOutput;\n}\n\nexport type DelayExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => number;\n\nexport type LogExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => unknown;\n\nexport type SendExpr<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject\n> = (\n  args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n) => TSentEvent;\n\nexport enum SpecialTargets {\n  Parent = '#_parent',\n  Internal = '#_internal'\n}\n\nexport interface SendToActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {}\n\nexport interface RaiseActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  id?: string;\n  delay?:\n    | Delay<TDelay>\n    | DelayExpr<TContext, TExpressionEvent, TExpressionAction, TEvent>;\n}\n\nexport interface RaiseActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {\n  event:\n    | TEvent\n    | SendExpr<TContext, TExpressionEvent, TExpressionAction, TEvent, TEvent>;\n}\n\nexport interface SendToActionParams<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject,\n  TEvent extends EventObject,\n  TDelay extends string\n> extends SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  > {\n  event:\n    | TSentEvent\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TSentEvent,\n        TEvent\n      >;\n}\n\nexport type Assigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = (\n  args: AssignArgs<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TActor\n  >\n) => Partial<TContext>;\n\nexport type PartialAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TKey extends keyof TContext\n> = (\n  args: AssignArgs<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TActor\n  >\n) => TContext[TKey];\n\nexport type PropertyAssigner<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> = {\n  [K in keyof TContext]?:\n    | PartialAssigner<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TEvent,\n        TActor,\n        K\n      >\n    | TContext[K];\n};\n\nexport type Mapper<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TResult,\n  TEvent extends EventObject\n> = (args: {\n  context: TContext;\n  event: TExpressionEvent;\n  self: ActorRef<\n    TEvent,\n    MachineSnapshot<TContext, TEvent, ProvidedActor, string, unknown>\n  >;\n}) => TResult;\n\nexport interface TransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends Omit<\n    TransitionConfig<TContext, TEvent, TEvent, TODO, TODO, TODO, TODO>,\n    | 'target'\n    // `guard` is correctly rejected by `extends` here and `actions` should be too\n    // however, `any` passed to `TransitionConfig` as `TAction` collapses its `.actions` to `any` and it's accidentally allowed here\n    // it doesn't exactly have to be incorrect, we are overriding this here anyway but it looks like a lucky accident rather than smth done on purpose\n    | 'guard'\n  > {\n  target: ReadonlyArray<StateNode<TContext, TEvent>> | undefined;\n  source: StateNode<TContext, TEvent>;\n  actions: readonly UnknownAction[];\n  reenter: boolean;\n  guard?: UnknownGuard;\n  eventType: EventDescriptor<TEvent>;\n  toJSON: () => {\n    target: string[] | undefined;\n    source: string;\n    actions: readonly UnknownAction[];\n    guard?: UnknownGuard;\n    eventType: EventDescriptor<TEvent>;\n    meta?: Record<string, any>;\n  };\n}\n\nexport type AnyTransitionDefinition = TransitionDefinition<any, any>;\n\nexport interface InitialTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  target: ReadonlyArray<StateNode<TContext, TEvent>>;\n  guard?: never;\n}\n\nexport type TransitionDefinitionMap<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> = {\n  [K in EventDescriptor<TEvent>]: Array<\n    TransitionDefinition<TContext, ExtractEvent<TEvent, K>>\n  >;\n};\n\nexport interface DelayedTransitionDefinition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> extends TransitionDefinition<TContext, TEvent> {\n  delay: number | string | DelayExpr<TContext, TEvent, undefined, TEvent>;\n}\n\nexport interface StateLike<TContext extends MachineContext> {\n  value: StateValue;\n  context: TContext;\n  event: EventObject;\n}\n\nexport interface StateConfig<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  value: StateValue;\n  context: TContext;\n  historyValue?: HistoryValue<TContext, TEvent>;\n  meta?: any;\n  configuration?: Array<StateNode<TContext, TEvent>>;\n  children: Record<string, ActorRef<any, any>>;\n  status: 'active' | 'done' | 'error' | 'stopped';\n  output?: any;\n  error?: unknown;\n  tags?: Set<string>;\n  machine?: StateMachine<TContext, TEvent, any, any, any, any, any, any, any>;\n  _internalQueue?: Array<TEvent>;\n}\n\nexport interface ActorOptions<TLogic extends AnyActorLogic> {\n  /**\n   * Whether state actions should be executed immediately upon transition. Defaults to `true`.\n   */\n  execute?: boolean;\n  clock?: Clock;\n  logger?: (...args: any[]) => void;\n  parent?: ActorRef<any, any>;\n  /**\n   * The custom `id` for referencing this service.\n   */\n  id?: string;\n  /**\n   * If `true`, states and events will be logged to Redux DevTools.\n   *\n   * Default: `false`\n   */\n  devTools?: boolean | DevToolsAdapter; // TODO: add enhancer options\n\n  sync?: boolean;\n\n  /**\n   * The system ID to register this actor under\n   */\n  systemId?: string;\n  /**\n   * The input data to pass to the actor.\n   */\n  input?: InputFrom<TLogic>;\n\n  // state?:\n  //   | PersistedStateFrom<TActorLogic>\n  //   | InternalStateFrom<TActorLogic>;\n  state?: any;\n\n  /**\n   * The source definition.\n   */\n  src?: string;\n\n  inspect?:\n    | Observer<InspectionEvent>\n    | ((inspectionEvent: InspectionEvent) => void);\n}\n\nexport type AnyActor = Actor<any>;\n\n/**\n * @deprecated Use `AnyActor` instead.\n */\nexport type AnyInterpreter = AnyActor;\n\n// Based on RxJS types\nexport type Observer<T> = {\n  next?: (value: T) => void;\n  error?: (err: unknown) => void;\n  complete?: () => void;\n};\n\nexport interface Subscription {\n  unsubscribe(): void;\n}\n\nexport interface InteropObservable<T> {\n  [Symbol.observable]: () => InteropSubscribable<T>;\n}\n\nexport interface InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n}\n\nexport interface Subscribable<T> extends InteropSubscribable<T> {\n  subscribe(observer: Observer<T>): Subscription;\n  subscribe(\n    next: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription;\n}\n\nexport type ExtractEvent<\n  TEvent extends EventObject,\n  TDescriptor extends EventDescriptor<TEvent>\n> = string extends TEvent['type']\n  ? TEvent\n  : NormalizeDescriptor<TDescriptor> extends infer TNormalizedDescriptor\n  ? TEvent extends any\n    ? TEvent['type'] extends TNormalizedDescriptor\n      ? TEvent\n      : never\n    : never\n  : never;\n\nexport interface BaseActorRef<TEvent extends EventObject> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorLike<TCurrent, TEvent extends EventObject>\n  extends Subscribable<TCurrent> {\n  send: (event: TEvent) => void;\n}\n\nexport interface ActorRef<\n  TEvent extends EventObject,\n  TSnapshot extends Snapshot<unknown>\n> extends Subscribable<TSnapshot>,\n    InteropObservable<TSnapshot> {\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  id: string;\n  sessionId: string;\n  /** @internal */\n  _send: (event: TEvent) => void;\n  send: (event: TEvent) => void;\n  // TODO: should this be optional?\n  start?: () => void;\n  getSnapshot: () => TSnapshot;\n  // TODO: this should return some sort of TPersistedState, not any\n  getPersistedState?: () => any;\n  stop: () => void;\n  toJSON?: () => any;\n  // TODO: figure out how to hide this externally as `sendTo(ctx => ctx.actorRef._parent._parent._parent._parent)` shouldn't be allowed\n  _parent?: ActorRef<any, any>;\n  system?: ActorSystem<any>;\n  status: ActorStatus;\n  src?: string;\n}\n\nexport type AnyActorRef = ActorRef<any, any>;\n\nexport type ActorLogicFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<any, any, any, any, any, any, any, any, any>\n    ? R\n    : R extends Promise<infer U>\n    ? PromiseActorLogic<U>\n    : never\n  : never;\n\nexport type ActorRefFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer TContext,\n      infer TEvent,\n      infer TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer TTag,\n      infer _TInput,\n      infer TOutput,\n      infer TResolvedTypesMeta\n    >\n    ? ActorRef<\n        TEvent,\n        MachineSnapshot<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          AreAllImplementationsAssumedToBeProvided<TResolvedTypesMeta> extends false\n            ? MarkAllImplementationsAsProvided<TResolvedTypesMeta>\n            : TResolvedTypesMeta\n        >\n      >\n    : R extends Promise<infer U>\n    ? ActorRefFrom<PromiseActorLogic<U>>\n    : R extends ActorLogic<\n        infer TSnapshot,\n        infer TEvent,\n        infer _TInput,\n        infer _TPersisted,\n        infer _TSystem\n      >\n    ? ActorRef<TEvent, TSnapshot>\n    : never\n  : never;\n\nexport type DevToolsAdapter = (service: AnyActor) => void;\n\n/**\n * @deprecated Use `Actor<T>` instead.\n */\nexport type InterpreterFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine)\n> = ReturnTypeOrValue<T> extends StateMachine<\n  infer TContext,\n  infer TEvent,\n  infer TActor,\n  infer _TAction,\n  infer _TGuard,\n  infer _TDelay,\n  infer TTag,\n  infer TInput,\n  infer TOutput,\n  infer TResolvedTypesMeta\n>\n  ? Actor<\n      ActorLogic<\n        MachineSnapshot<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          TResolvedTypesMeta\n        >,\n        TEvent,\n        TInput,\n        PersistedMachineState<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          TResolvedTypesMeta\n        >,\n        ActorSystem<any>\n      >\n    >\n  : never;\n\nexport type MachineImplementationsFrom<\n  T extends AnyStateMachine | ((...args: any[]) => AnyStateMachine),\n  TRequireMissingImplementations extends boolean = false\n> = ReturnTypeOrValue<T> extends StateMachine<\n  infer TContext,\n  infer TEvent,\n  infer TActor,\n  infer TAction,\n  infer _TGuard,\n  infer TDelay,\n  infer _TTag,\n  infer _TInput,\n  infer _TOutput,\n  infer TResolvedTypesMeta\n>\n  ? InternalMachineImplementations<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TDelay,\n      TResolvedTypesMeta,\n      TRequireMissingImplementations\n    >\n  : never;\n\n// only meant to be used internally for debugging purposes\nexport type __ResolvedTypesMetaFrom<T> = T extends StateMachine<\n  any, // context\n  any, // event\n  any, // actor\n  any, // action\n  any, // guard\n  any, // delay\n  any, // tag\n  any, // input\n  any, // output\n  infer TResolvedTypesMeta\n>\n  ? TResolvedTypesMeta\n  : never;\n\nexport interface ActorContext<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n> {\n  self: ActorRef<TEvent, TSnapshot>;\n  id: string;\n  sessionId: string;\n  logger: (...args: any[]) => void;\n  defer: (fn: () => void) => void;\n  system: TSystem;\n  stopChild: (child: AnyActorRef) => void;\n}\n\nexport type AnyActorContext = ActorContext<any, any, AnyActorSystem>;\n\nexport type Snapshot<TOutput> =\n  | {\n      status: 'active';\n      output: undefined;\n      error: undefined;\n    }\n  | {\n      status: 'done';\n      output: TOutput;\n      error: undefined;\n    }\n  | {\n      status: 'error';\n      output: undefined;\n      error: unknown;\n    }\n  | {\n      status: 'stopped';\n      output: undefined;\n      error: undefined;\n    };\n\nexport interface ActorLogic<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput = unknown,\n  /**\n   * Serialized internal state used for persistence & restoration\n   */\n  TPersisted = TSnapshot,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n> {\n  config?: unknown;\n  transition: (\n    state: TSnapshot,\n    message: TEvent,\n    ctx: ActorContext<TSnapshot, TEvent, TSystem>\n  ) => TSnapshot;\n  getInitialState: (\n    actorCtx: ActorContext<TSnapshot, TEvent, TSystem>,\n    input: TInput\n  ) => TSnapshot;\n  restoreState?: (\n    persistedState: TPersisted,\n    actorCtx: ActorContext<TSnapshot, TEvent>\n  ) => TSnapshot;\n  start?: (state: TSnapshot, actorCtx: ActorContext<TSnapshot, TEvent>) => void;\n  /**\n   * @returns Persisted state\n   */\n  getPersistedState?: (state: TSnapshot) => TPersisted;\n}\n\nexport type AnyActorLogic = ActorLogic<\n  any, // snapshot\n  any, // event\n  any, // input\n  any, // persisted state\n  any // system\n>;\n\nexport type SnapshotFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends ActorRef<infer _, infer TSnapshot>\n    ? TSnapshot\n    : R extends Actor<infer TLogic>\n    ? SnapshotFrom<TLogic>\n    : R extends StateMachine<\n        infer _TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? StateFrom<R>\n    : R extends ActorLogic<any, any, any, any, any>\n    ? ReturnType<R['transition']>\n    : R extends ActorContext<infer TSnapshot, infer _, infer __>\n    ? TSnapshot\n    : never\n  : never;\n\nexport type EventFromLogic<TLogic extends ActorLogic<any, any, any, any, any>> =\n  TLogic extends ActorLogic<\n    infer _,\n    infer TEvent,\n    infer __,\n    infer _____,\n    infer ______\n  >\n    ? TEvent\n    : never;\n\nexport type PersistedStateFrom<\n  TLogic extends ActorLogic<any, any, any, any, any>\n> = TLogic extends ActorLogic<\n  infer _TSnapshot,\n  infer _TEvent,\n  infer _TInput,\n  infer TPersisted,\n  infer _TSystem\n>\n  ? TPersisted\n  : never;\n\ntype ResolveEventType<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer _TContext,\n      infer TEvent,\n      infer _TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer _TTag,\n      infer _TInput,\n      infer _TOutput,\n      infer _TResolvedTypesMeta\n    >\n    ? TEvent\n    : R extends State<\n        infer _TContext,\n        infer TEvent,\n        infer _TActor,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? TEvent\n    : R extends ActorRef<infer TEvent, infer _>\n    ? TEvent\n    : never\n  : never;\n\nexport type EventFrom<\n  T,\n  K extends Prop<TEvent, 'type'> = never,\n  TEvent extends EventObject = ResolveEventType<T>\n> = IsNever<K> extends true ? TEvent : ExtractEvent<TEvent, K>;\n\nexport type ContextFrom<T> = ReturnTypeOrValue<T> extends infer R\n  ? R extends StateMachine<\n      infer TContext,\n      infer _TEvent,\n      infer _TActor,\n      infer _TAction,\n      infer _TGuard,\n      infer _TDelay,\n      infer _TTag,\n      infer _TInput,\n      infer _TOutput,\n      infer _TTypesMeta\n    >\n    ? TContext\n    : R extends State<\n        infer TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TOutput,\n        infer _TResolvedTypesMeta\n      >\n    ? TContext\n    : R extends Actor<infer TActorLogic>\n    ? TActorLogic extends StateMachine<\n        infer TContext,\n        infer _TEvent,\n        infer _TActor,\n        infer _TAction,\n        infer _TGuard,\n        infer _TDelay,\n        infer _TTag,\n        infer _TInput,\n        infer _TOutput,\n        infer _TTypesMeta\n      >\n      ? TContext\n      : never\n    : never\n  : never;\n\nexport type InferEvent<E extends EventObject> = {\n  [T in E['type']]: { type: T } & Extract<E, { type: T }>;\n}[E['type']];\n\nexport type TODO = any;\n\nexport type StateValueFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['matches']\n>[0];\n\nexport type TagsFrom<TMachine extends AnyStateMachine> = Parameters<\n  StateFrom<TMachine>['hasTag']\n>[0];\n\nexport interface ActorSystemInfo {\n  actors: Record<string, AnyActorRef>;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /**\n   * @internal\n   */\n  _bookId: () => string;\n  /**\n   * @internal\n   */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /**\n   * @internal\n   */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /**\n   * @internal\n   */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  inspect: (observer: Observer<InspectionEvent>) => void;\n  /**\n   * @internal\n   */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /**\n   * @internal\n   */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nexport type PersistedMachineState<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TOutput,\n  TResolvedTypesMeta = TypegenDisabled\n> = HomomorphicPick<\n  MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>,\n  'value' | 'output' | 'error' | 'context' | 'status' | 'historyValue'\n> & {\n  children: {\n    [K in keyof MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >['children']]: {\n      state: any; // TODO: fix (should be state from actorref)\n      src?: string;\n    };\n  };\n};\n","import isDevelopment from '#is-development';\nimport { createErrorActorEvent } from '../eventUtils.ts';\nimport {\n  ActionArgs,\n  ActorRef,\n  AnyActorContext,\n  AnyActorRef,\n  AnyEventObject,\n  AnyActor,\n  AnyState,\n  Cast,\n  DelayExpr,\n  EventFrom,\n  EventObject,\n  InferEvent,\n  MachineContext,\n  SendExpr,\n  SendToActionOptions,\n  SendToActionParams,\n  SpecialTargets,\n  UnifiedArg,\n  ParameterizedObject,\n  NoInfer\n} from '../types.ts';\nimport { XSTATE_ERROR } from '../constants.ts';\n\nfunction resolveSendTo(\n  actorContext: AnyActorContext,\n  state: AnyState,\n  args: ActionArgs<any, any, any, any>,\n  {\n    to,\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    to:\n      | AnyActorRef\n      | string\n      | ((\n          args: UnifiedArg<MachineContext, EventObject, EventObject>\n        ) => AnyActorRef | string);\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >\n      | undefined;\n  }\n) {\n  const delaysMap = state.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function' ? eventOrExpr(args) : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function' ? configDelay(args) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args) : delay;\n  }\n\n  const resolvedTarget = typeof to === 'function' ? to(args) : to;\n  let targetActorRef: AnyActorRef | undefined;\n\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorContext?.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorContext?.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = state.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = state.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(\n        `Unable to send event to actor '${resolvedTarget}' from machine '${state.machine.id}'.`\n      );\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorContext?.self;\n  }\n\n  return [\n    state,\n    { to: targetActorRef, event: resolvedEvent, id, delay: resolvedDelay }\n  ];\n}\nfunction executeSendTo(\n  actorContext: AnyActorContext,\n  params: {\n    to: AnyActorRef;\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  if (typeof params.delay === 'number') {\n    (actorContext.self as AnyActor).delaySend(\n      params as typeof params & { delay: number }\n    );\n    return;\n  }\n\n  const { to, event } = params;\n\n  actorContext.defer(() => {\n    actorContext?.system._relay(\n      actorContext.self,\n      to,\n      event.type === XSTATE_ERROR\n        ? createErrorActorEvent(actorContext.self.id, (event as any).data)\n        : event\n    );\n  });\n}\n\nexport interface SendToAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (_: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>): void;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event to send\n * @param options Send action options\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n */\nexport function sendTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TTargetActor extends AnyActorRef,\n  TEvent extends EventObject,\n  TDelay extends string\n>(\n  to:\n    | TTargetActor\n    | string\n    | ((\n        args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n      ) => TTargetActor | string),\n  eventOrExpr:\n    | EventFrom<TTargetActor>\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        InferEvent<Cast<EventFrom<TTargetActor>, EventObject>>,\n        TEvent\n      >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    NoInfer<TEvent>,\n    NoInfer<TDelay>\n  >\n): SendToAction<TContext, TExpressionEvent, TExpressionAction, TEvent, TDelay> {\n  function sendTo(\n    _: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  sendTo.type = 'xstate.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n\n  sendTo.resolve = resolveSendTo;\n  sendTo.execute = executeSendTo;\n\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nexport function sendParent<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TSentEvent extends EventObject = AnyEventObject,\n  TEvent extends EventObject = AnyEventObject,\n  TDelay extends string = string\n>(\n  event:\n    | TSentEvent\n    | SendExpr<\n        TContext,\n        TExpressionEvent,\n        TExpressionAction,\n        TSentEvent,\n        TEvent\n      >,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  >\n) {\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    AnyActorRef,\n    TEvent,\n    TDelay\n  >(SpecialTargets.Parent, event, options as any);\n}\n\ntype Target<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ActorRef<any, any>\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TExpressionAction, TEvent>\n    ) => string | ActorRef<any, any>);\n\n/**\n * Forwards (sends) an event to a specified service.\n *\n * @param target The target service to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nexport function forwardTo<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n>(\n  target: Target<TContext, TExpressionEvent, TExpressionAction, TEvent>,\n  options?: SendToActionOptions<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    TEvent,\n    TDelay\n  >\n) {\n  if (isDevelopment && (!target || typeof target === 'function')) {\n    const originalTarget = target;\n    target = (...args) => {\n      const resolvedTarget =\n        typeof originalTarget === 'function'\n          ? originalTarget(...args)\n          : originalTarget;\n      if (!resolvedTarget) {\n        throw new Error(\n          `Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`\n        );\n      }\n      return resolvedTarget;\n    };\n  }\n  return sendTo<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    AnyActorRef,\n    TEvent,\n    TDelay\n  >(target, ({ event }: any) => event, options);\n}\n\n/**\n * Escalates an error by sending it as an event to this machine's parent.\n *\n * @param errorData The error data to send, or the expression function that\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\n * @param options Options to pass into the send action creator.\n */\nexport function escalate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionAction extends ParameterizedObject | undefined,\n  TErrorData = any,\n  TEvent extends EventObject = AnyEventObject\n>(\n  errorData:\n    | TErrorData\n    | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TErrorData),\n  options?: SendToActionParams<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    EventObject,\n    TEvent,\n    string\n  >\n) {\n  return sendParent<\n    TContext,\n    TExpressionEvent,\n    TExpressionAction,\n    EventObject,\n    TEvent\n  >((arg) => {\n    return {\n      type: XSTATE_ERROR,\n      data:\n        typeof errorData === 'function' ? (errorData as any)(arg) : errorData\n    };\n  }, options);\n}\n","import {\n  ActorLogic,\n  ActorContext,\n  ActorSystem,\n  EventObject,\n  ActorRefFrom,\n  AnyActorSystem,\n  Snapshot\n} from '../types';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  TransitionSnapshot<TContext>,\n  AnyActorSystem\n>;\n\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFrom<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic from a transition function and its initial state.\n *\n * A transition function is a function that takes the current state and an event and returns the next state.\n *\n * @param transition The transition function that returns the next state given the current state and event.\n * @param initialContext The initial state of the transition function.\n * @returns Actor logic\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends ActorSystem<any>,\n  TInput\n>(\n  transition: (\n    state: TContext,\n    event: TEvent,\n    actorContext: ActorContext<TransitionSnapshot<TContext>, TEvent, TSystem>\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput> {\n  return {\n    config: transition,\n    transition: (state, event, actorContext) => {\n      return {\n        ...state,\n        context: transition(state.context, event as TEvent, actorContext as any)\n      };\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedState: (state) => state,\n    restoreState: (state) => state\n  };\n}\n","import {\n  ActorLogic,\n  ActorRefFrom,\n  ActorSystem,\n  AnyActorSystem,\n  Snapshot\n} from '../types';\nimport { XSTATE_STOP } from '../constants';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst resolveEventType = '$$xstate.resolve';\nconst rejectEventType = '$$xstate.reject';\n\nexport type PromiseActorEvents<T> =\n  | {\n      type: typeof resolveEventType;\n      data: T;\n    }\n  | {\n      type: typeof rejectEventType;\n      data: any;\n    }\n  | {\n      type: typeof XSTATE_STOP;\n    };\n\nexport type PromiseActorLogic<TOutput, TInput = unknown> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  PromiseSnapshot<TOutput, TInput>, // persisted state\n  ActorSystem<any>\n>;\n\nexport type PromiseActorRef<TOutput> = ActorRefFrom<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\nexport function fromPromise<TOutput, TInput = unknown>(\n  // TODO: add types\n  promiseCreator: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: PromiseActorRef<TOutput>;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput> {\n  // TODO: add event types\n  const logic: PromiseActorLogic<TOutput, TInput> = {\n    config: promiseCreator,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case resolveEventType: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case rejectEventType:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({ input: state.input!, system, self })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, { type: resolveEventType, data: response });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, { type: rejectEventType, data: errorData });\n        }\n      );\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedState: (state) => state,\n    restoreState: (state) => state\n  };\n\n  return logic;\n}\n","import { createActor } from '../interpreter.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport { fromCallback, type CallbackActorLogic } from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic\n} from './observable.ts';\nexport { fromPromise, type PromiseActorLogic } from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  AnyEventObject,\n  Snapshot<undefined>\n> {\n  return createActor(emptyLogic);\n}\n","import type { State } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { NULL_EVENT, STATE_DELIMITER } from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { memo } from './memo.ts';\nimport {\n  formatInitialTransition,\n  formatTransition,\n  formatTransitions,\n  getCandidates,\n  getDelayedTransitions\n} from './stateUtils.ts';\nimport type {\n  DelayedTransitionDefinition,\n  EventObject,\n  InitialTransitionDefinition,\n  InvokeDefinition,\n  MachineContext,\n  Mapper,\n  StateNodeConfig,\n  StateNodeDefinition,\n  StateNodesConfig,\n  StatesDefinition,\n  TransitionDefinition,\n  TransitionDefinitionMap,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyStateMachine,\n  AnyStateNodeConfig,\n  ProvidedActor,\n  NonReducibleUnknown\n} from './types.ts';\nimport {\n  createInvokeId,\n  mapValues,\n  toArray,\n  toTransitionConfigArray\n} from './utils.ts';\n\nconst EMPTY_OBJECT = {};\n\nconst toSerializableAction = (action: UnknownAction) => {\n  if (typeof action === 'string') {\n    return { type: action };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return { type: (action as any).type };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\n\ninterface StateNodeOptions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  _key: string;\n  _parent?: StateNode<TContext, TEvent>;\n  _machine: AnyStateMachine;\n}\n\nexport class StateNode<\n  TContext extends MachineContext = MachineContext,\n  TEvent extends EventObject = EventObject\n> {\n  /**\n   * The relative key of the state node, which represents its location in the overall state value.\n   */\n  public key: string;\n  /**\n   * The unique ID of the state node.\n   */\n  public id: string;\n  /**\n   * The type of this state node:\n   *\n   *  - `'atomic'` - no child state nodes\n   *  - `'compound'` - nested child state nodes (XOR)\n   *  - `'parallel'` - orthogonal nested child state nodes (AND)\n   *  - `'history'` - history state node\n   *  - `'final'` - final state node\n   */\n  public type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /**\n   * The string path from the root machine node to this node.\n   */\n  public path: string[];\n  /**\n   * The child state nodes.\n   */\n  public states: StateNodesConfig<TContext, TEvent>;\n  /**\n   * The type of history on this state node. Can be:\n   *\n   *  - `'shallow'` - recalls only top-level historical state value\n   *  - `'deep'` - recalls historical state value at all levels\n   */\n  public history: false | 'shallow' | 'deep';\n  /**\n   * The action(s) to be executed upon entering the state node.\n   */\n  public entry: UnknownAction[];\n  /**\n   * The action(s) to be executed upon exiting the state node.\n   */\n  public exit: UnknownAction[];\n  /**\n   * The parent state node.\n   */\n  public parent?: StateNode<TContext, TEvent>;\n  /**\n   * The root machine node.\n   */\n  public machine: StateMachine<\n    TContext,\n    TEvent,\n    any, // actors\n    any, // input\n    TODO, // output\n    TODO, // guards\n    TODO, // delays\n    TODO, // tags\n    TODO // types meta\n  >;\n  /**\n   * The meta data associated with this state node, which will be returned in State instances.\n   */\n  public meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n   */\n  public output?:\n    | Mapper<MachineContext, EventObject, unknown, EventObject>\n    | NonReducibleUnknown;\n\n  /**\n   * The order this state node appears. Corresponds to the implicit document order.\n   */\n  public order: number = -1;\n\n  public description?: string;\n\n  public tags: string[] = [];\n  public transitions!: Map<string, TransitionDefinition<TContext, TEvent>[]>;\n  public always?: Array<TransitionDefinition<TContext, TEvent>>;\n\n  constructor(\n    /**\n     * The raw config used to create the machine.\n     */\n    public config: StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO, // actions\n      TODO, // actors\n      TODO, // output\n      TODO, // guards\n      TODO, // delays\n      TODO // tags\n    >,\n    options: StateNodeOptions<TContext, TEvent>\n  ) {\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id =\n      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type =\n      this.config.type ||\n      (this.config.states && Object.keys(this.config.states).length\n        ? 'compound'\n        : this.config.history\n        ? 'history'\n        : 'atomic');\n    this.description = this.config.description;\n\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n\n    this.states = (\n      this.config.states\n        ? mapValues(\n            this.config.states,\n            (stateConfig: AnyStateNodeConfig, key) => {\n              const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key as string,\n                _machine: this.machine\n              });\n              return stateNode;\n            }\n          )\n        : EMPTY_OBJECT\n    ) as StateNodesConfig<TContext, TEvent>;\n\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\n        `No initial state specified for compound state node \"#${\n          this.id\n        }\". Try adding { initial: \"${\n          Object.keys(this.states)[0]\n        }\" } to the state config.`\n      );\n    }\n\n    // History config\n    this.history =\n      this.config.history === true ? 'shallow' : this.config.history || false;\n\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n\n    this.meta = this.config.meta;\n    this.output =\n      this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  public _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map((t) =>\n        formatTransition(this, NULL_EVENT, t)\n      );\n    }\n\n    Object.keys(this.states).forEach((key) => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /**\n   * The well-structured state node definition.\n   */\n  public get definition(): StateNodeDefinition<TContext, TEvent> {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial\n        ? {\n            target: this.initial.target,\n            source: this,\n            actions: this.initial.actions.map(toSerializableAction),\n            eventType: null as any,\n            reenter: false,\n            toJSON: () => ({\n              target: this.initial!.target!.map((t) => `#${t.id}`),\n              source: `#${this.id}`,\n              actions: this.initial!.actions.map(toSerializableAction),\n              eventType: null as any\n            })\n          }\n        : undefined,\n      history: this.history,\n      states: mapValues(this.states, (state: StateNode<TContext, TEvent>) => {\n        return state.definition;\n      }) as StatesDefinition<TContext, TEvent>,\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map((t) => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  /**\n   * The logic invoked as actors by this state node.\n   */\n  public get invoke(): Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string\n    >\n  > {\n    return memo(this, 'invoke', () =>\n      toArray(this.config.invoke).map((invokeConfig, i) => {\n        const { src, systemId } = invokeConfig;\n\n        const resolvedId = invokeConfig.id || createInvokeId(this.id, i);\n        // TODO: resolving should not happen here\n        const resolvedSrc =\n          typeof src === 'string' ? src : !('type' in src) ? resolvedId : src;\n\n        if (\n          !this.machine.implementations.actors[resolvedId] &&\n          typeof src !== 'string' &&\n          !('type' in src)\n        ) {\n          this.machine.implementations.actors = {\n            ...this.machine.implementations.actors,\n            // TODO: this should accept `src` as-is\n            [resolvedId]: src\n          };\n        }\n\n        return {\n          ...invokeConfig,\n          src: resolvedSrc,\n          id: resolvedId,\n          systemId: systemId,\n          toJSON() {\n            const { onDone, onError, ...invokeDefValues } = invokeConfig;\n            return {\n              ...invokeDefValues,\n              type: 'xstate.invoke',\n              src: resolvedSrc,\n              id: resolvedId\n            };\n          }\n        } as InvokeDefinition<\n          TContext,\n          TEvent,\n          ProvidedActor,\n          ParameterizedObject,\n          ParameterizedObject,\n          string\n        >;\n      })\n    );\n  }\n\n  /**\n   * The mapping of events to transitions.\n   */\n  public get on(): TransitionDefinitionMap<TContext, TEvent> {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n\n      return [...transitions]\n        .flatMap(([descriptor, t]) => t.map((t) => [descriptor, t] as const))\n        .reduce((map: any, [descriptor, transition]) => {\n          map[descriptor] = map[descriptor] || [];\n          map[descriptor].push(transition);\n          return map;\n        }, {} as TransitionDefinitionMap<TContext, TEvent>);\n    });\n  }\n\n  public get after(): Array<DelayedTransitionDefinition<TContext, TEvent>> {\n    return memo(\n      this,\n      'delayedTransitions',\n      () => getDelayedTransitions(this) as any\n    );\n  }\n\n  public get initial(): InitialTransitionDefinition<TContext, TEvent> {\n    return memo(this, 'initial', () =>\n      formatInitialTransition(this, this.config.initial || [])\n    );\n  }\n\n  public next(\n    state: State<TContext, TEvent, TODO, TODO, TODO>,\n    event: TEvent\n  ): TransitionDefinition<TContext, TEvent>[] | undefined {\n    const eventType = event.type;\n    const actions: UnknownAction[] = [];\n\n    let selectedTransition: TransitionDefinition<TContext, TEvent> | undefined;\n\n    const candidates: Array<TransitionDefinition<TContext, TEvent>> = memo(\n      this,\n      `candidates-${eventType}`,\n      () => getCandidates(this, eventType)\n    );\n\n    for (const candidate of candidates) {\n      const { guard } = candidate;\n      const resolvedContext = state.context;\n\n      let guardPassed = false;\n\n      try {\n        guardPassed =\n          !guard ||\n          evaluateGuard<TContext, TEvent>(guard, resolvedContext, event, state);\n      } catch (err: any) {\n        const guardType =\n          typeof guard === 'string'\n            ? guard\n            : typeof guard === 'object'\n            ? guard.type\n            : undefined;\n        throw new Error(\n          `Unable to evaluate guard ${\n            guardType ? `'${guardType}' ` : ''\n          }in transition for event '${eventType}' in state node '${\n            this.id\n          }':\\n${err.message}`\n        );\n      }\n\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /**\n   * All the event types accepted by this state node and its descendants.\n   */\n  public get events(): Array<TEvent['type']> {\n    return memo(this, 'events', () => {\n      const { states } = this;\n      const events = new Set(this.ownEvents);\n\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  public get ownEvents(): Array<TEvent['type']> {\n    const events = new Set(\n      [...this.transitions.keys()].filter((descriptor) => {\n        return this.transitions\n          .get(descriptor)!\n          .some(\n            (transition) =>\n              !(\n                !transition.target &&\n                !transition.actions.length &&\n                !transition.reenter\n              )\n          );\n      })\n    );\n\n    return Array.from(events);\n  }\n}\n","import { assign } from './actions.ts';\nimport { createInitEvent } from './eventUtils.ts';\nimport { STATE_DELIMITER } from './constants.ts';\nimport { cloneState, getPersistedState, State } from './State.ts';\nimport { StateNode } from './StateNode.ts';\nimport {\n  getConfiguration,\n  getStateNodeByPath,\n  getInitialConfiguration,\n  getStateNodes,\n  isInFinalState,\n  isStateId,\n  macrostep,\n  microstep,\n  resolveActionsAndContext,\n  resolveStateValue,\n  transitionNode,\n  isAtomicStateNode\n} from './stateUtils.ts';\nimport type {\n  AreAllImplementationsAssumedToBeProvided,\n  MarkAllImplementationsAsProvided,\n  ResolveTypegenMeta,\n  TypegenDisabled\n} from './typegenTypes.ts';\nimport type {\n  ActorContext,\n  ActorLogic,\n  EventObject,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineImplementationsSimplified,\n  MachineTypes,\n  NoInfer,\n  StateConfig,\n  StateMachineDefinition,\n  StateValue,\n  TransitionDefinition,\n  PersistedMachineState,\n  ParameterizedObject,\n  AnyActorContext,\n  AnyEventObject,\n  ProvidedActor,\n  AnyActorRef,\n  Equals,\n  TODO,\n  SnapshotFrom\n} from './types.ts';\nimport { isErrorActorEvent, resolveReferencedActor } from './utils.ts';\nimport { createActor } from './interpreter.ts';\nimport isDevelopment from '#is-development';\n\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\n\nexport type MachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TTag extends string,\n  TOutput,\n  TResolvedTypesMeta = TypegenDisabled\n> =\n  | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {\n      status: 'active';\n      output: undefined;\n      error: undefined;\n    })\n  | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {\n      status: 'done';\n      output: TOutput;\n      error: undefined;\n    })\n  | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {\n      status: 'error';\n      output: undefined;\n      error: unknown;\n    })\n  | (State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta> & {\n      status: 'stopped';\n      output: undefined;\n      error: undefined;\n    });\n\nexport class StateMachine<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TResolvedTypesMeta = ResolveTypegenMeta<\n    TypegenDisabled,\n    NoInfer<TEvent>,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag\n  >\n> implements\n    ActorLogic<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TActor,\n        TTag,\n        TOutput,\n        TResolvedTypesMeta\n      >,\n      TEvent,\n      TInput,\n      PersistedMachineState<\n        TContext,\n        TEvent,\n        TActor,\n        TTag,\n        TOutput,\n        TResolvedTypesMeta\n      >,\n      TODO\n    >\n{\n  /**\n   * The machine's own version.\n   */\n  public version?: string;\n\n  public implementations: MachineImplementationsSimplified<TContext, TEvent>;\n\n  public types: MachineTypes<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    TResolvedTypesMeta\n  >;\n\n  public __xstatenode: true = true;\n\n  public idMap: Map<string, StateNode<TContext, TEvent>> = new Map();\n\n  public root: StateNode<TContext, TEvent>;\n\n  public id: string;\n\n  public states: StateNode<TContext, TEvent>['states'];\n  public events: Array<TEvent['type']>;\n\n  constructor(\n    /**\n     * The raw config used to create the machine.\n     */\n    public config: MachineConfig<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      TOutput,\n      any\n    >,\n    implementations?: MachineImplementationsSimplified<TContext, TEvent>\n  ) {\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.types = this.config.types ?? ({} as any as this['types']);\n\n    this.transition = this.transition.bind(this);\n    this.getInitialState = this.getInitialState.bind(this);\n    this.restoreState = this.restoreState.bind(this);\n    this.start = this.start.bind(this);\n    this.getPersistedState = this.getPersistedState.bind(this);\n\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this as any\n    });\n\n    this.root._initialize();\n\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n\n    if (\n      isDevelopment &&\n      !this.root.output &&\n      Object.values(this.states).some(\n        (state) => state.type === 'final' && !!state.output\n      )\n    ) {\n      console.warn(\n        'Missing `machine.output` declaration (top-level final state with output detected)'\n      );\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations\n   * and merges the `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)\n   *  to recursively merge with the existing options.\n   *\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  public provide(\n    implementations: InternalMachineImplementations<\n      TContext,\n      TEvent,\n      TActor,\n      TAction,\n      TDelay,\n      TResolvedTypesMeta,\n      true\n    >\n  ): StateMachine<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    AreAllImplementationsAssumedToBeProvided<TResolvedTypesMeta> extends false\n      ? MarkAllImplementationsAsProvided<TResolvedTypesMeta>\n      : TResolvedTypesMeta\n  > {\n    const { actions, guards, actors, delays } = this.implementations;\n\n    return new StateMachine(this.config, {\n      actions: { ...actions, ...implementations.actions },\n      guards: { ...guards, ...implementations.guards },\n      actors: { ...actors, ...implementations.actors },\n      delays: { ...delays, ...implementations.delays }\n    });\n  }\n\n  /**\n   * Resolves the given `state` to a new `State` instance relative to this machine.\n   *\n   * This ensures that `.nextEvents` represent the correct values.\n   *\n   * @param state The state to resolve\n   */\n  public resolveState(\n    state: State<TContext, TEvent, TActor, TTag, TResolvedTypesMeta>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    const configurationSet = getConfiguration(\n      getStateNodes(this.root, state.value)\n    );\n    const configuration = Array.from(configurationSet);\n    return this.createState({\n      ...(state as any),\n      value: resolveStateValue(this.root, state.value),\n      configuration,\n      status: isInFinalState(configuration) ? 'done' : state.status\n    });\n  }\n\n  public resolveStateValue(\n    stateValue: StateValue,\n    ...[context]: Equals<TContext, MachineContext> extends true\n      ? []\n      : [TContext]\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    const resolvedStateValue = resolveStateValue(this.root, stateValue);\n\n    return this.resolveState(\n      State.from(resolvedStateValue, context, this) as any\n    );\n  }\n\n  /**\n   * Determines the next state given the current `state` and received `event`.\n   * Calculates a full macrostep from all microsteps.\n   *\n   * @param state The current State instance or state value\n   * @param event The received event\n   */\n  public transition(\n    state: MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >,\n    event: TEvent,\n    actorCtx: ActorContext<typeof state, TEvent>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    // TODO: handle error events in a better way\n    if (\n      isErrorActorEvent(event) &&\n      !state.nextEvents.some((nextEvent) => nextEvent === event.type)\n    ) {\n      return cloneState(state, {\n        status: 'error',\n        error: event.data\n      });\n    }\n\n    const { state: nextState } = macrostep(state, event, actorCtx);\n\n    return nextState as typeof state;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`.\n   * Calculates a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  public microstep(\n    state: MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >,\n    event: TEvent,\n    actorCtx: AnyActorContext\n  ): Array<\n    MachineSnapshot<TContext, TEvent, TActor, TTag, TOutput, TResolvedTypesMeta>\n  > {\n    return macrostep(state, event, actorCtx).microstates as (typeof state)[];\n  }\n\n  public getTransitionData(\n    state: MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >,\n    event: TEvent\n  ): Array<TransitionDefinition<TContext, TEvent>> {\n    return transitionNode(this.root, state.value, state, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps.\n   * This \"pre-initial\" state is provided to initial actions executed in the initial state.\n   */\n  private getPreInitialState(\n    actorCtx: AnyActorContext,\n    initEvent: any\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    const { context } = this.config;\n\n    const preInitial = this.resolveState(\n      this.createState({\n        value: {}, // TODO: this is computed in state constructor\n        context:\n          typeof context !== 'function' && context ? context : ({} as TContext),\n        meta: undefined,\n        configuration: getInitialConfiguration(this.root),\n        children: {},\n        status: 'active'\n      })\n    );\n\n    if (typeof context === 'function') {\n      const assignment = ({ spawn, event }: any) =>\n        context({ spawn, input: event.input });\n      return resolveActionsAndContext(\n        [assign(assignment)],\n        initEvent as TEvent,\n        preInitial,\n        actorCtx\n      ) as SnapshotFrom<this>;\n    }\n\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.\n   */\n  public getInitialState(\n    actorCtx: ActorContext<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TActor,\n        TTag,\n        TOutput,\n        TResolvedTypesMeta\n      >,\n      TEvent\n    >,\n    input?: TInput\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    const initEvent = createInitEvent(input) as unknown as TEvent; // TODO: fix;\n\n    const preInitialState = this.getPreInitialState(actorCtx, initEvent);\n    const nextState = microstep(\n      [\n        {\n          target: [...preInitialState.configuration].filter(isAtomicStateNode),\n          source: this.root,\n          reenter: true,\n          actions: [],\n          eventType: null as any,\n          toJSON: null as any // TODO: fix\n        }\n      ],\n      preInitialState,\n      actorCtx,\n      initEvent,\n      true\n    );\n\n    const { state: macroState } = macrostep(\n      nextState,\n      initEvent as AnyEventObject,\n      actorCtx\n    );\n\n    return macroState as SnapshotFrom<this>;\n  }\n\n  public start(\n    state: MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >\n  ): void {\n    Object.values(state.children).forEach((child: any) => {\n      if (child.status === 0) {\n        child.start?.();\n      }\n    });\n  }\n\n  public getStateNodeById(stateId: string): StateNode<TContext, TEvent> {\n    const fullPath = stateId.split(STATE_DELIMITER);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0])\n      ? fullPath[0].slice(STATE_IDENTIFIER.length)\n      : fullPath[0];\n\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\n        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`\n      );\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n\n  public get definition(): StateMachineDefinition<TContext, TEvent> {\n    return this.root.definition;\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  public getPersistedState(\n    state: MachineSnapshot<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >\n  ): PersistedMachineState<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    return getPersistedState(state);\n  }\n\n  public createState(\n    stateConfig:\n      | MachineSnapshot<\n          TContext,\n          TEvent,\n          TActor,\n          TTag,\n          TOutput,\n          TResolvedTypesMeta\n        >\n      | StateConfig<TContext, TEvent>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    return stateConfig instanceof State\n      ? (stateConfig as any)\n      : new State(stateConfig, this);\n  }\n\n  public restoreState(\n    snapshot: PersistedMachineState<\n      TContext,\n      TEvent,\n      TActor,\n      TTag,\n      TOutput,\n      TResolvedTypesMeta\n    >,\n    _actorCtx: ActorContext<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TActor,\n        TTag,\n        TOutput,\n        TResolvedTypesMeta\n      >,\n      TEvent\n    >\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TActor,\n    TTag,\n    TOutput,\n    TResolvedTypesMeta\n  > {\n    const children: Record<string, AnyActorRef> = {};\n\n    Object.keys(snapshot.children).forEach((actorId) => {\n      const actorData =\n        snapshot.children[actorId as keyof typeof snapshot.children];\n      const childState = actorData.state;\n      const src = actorData.src;\n\n      const logic = src\n        ? resolveReferencedActor(this.implementations.actors[src])?.src\n        : undefined;\n\n      if (!logic) {\n        return;\n      }\n\n      const actorState = logic.restoreState?.(childState, _actorCtx);\n\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorCtx?.self,\n        state: actorState\n      });\n\n      children[actorId] = actorRef;\n    });\n\n    return this.createState(new State({ ...snapshot, children }, this) as any);\n  }\n\n  /**@deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TContext!: TContext;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TEvent!: TEvent;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TActor!: TActor;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TAction!: TAction;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TGuard!: TGuard;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TDelay!: TDelay;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TTag!: TTag;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TInput!: TInput;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TOutput!: TOutput;\n  /** @deprecated an internal property acting as a \"phantom\" type, not meant to be used at runtime */\n  __TResolvedTypesMeta!: TResolvedTypesMeta;\n}\n","import isDevelopment from '#is-development';\nimport { ActorRef, SnapshotFrom, Subscription } from './types.ts';\n\ninterface WaitForOptions {\n  /**\n   * How long to wait before rejecting, if no emitted\n   * state satisfies the predicate.\n   *\n   * @default 10_000 (10 seconds)\n   */\n  timeout: number;\n}\n\nconst defaultWaitForOptions: WaitForOptions = {\n  timeout: 10_000 // 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy\n * a predicate, and then resolves with that value.\n * Will throw if the desired state is not reached after a timeout\n * (defaults to 10 seconds).\n *\n * @example\n * ```js\n * const state = await waitFor(someService, state => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value\n * that matches the condition\n */\nexport function waitFor<TActorRef extends ActorRef<any, any>>(\n  actorRef: TActorRef,\n  predicate: (emitted: SnapshotFrom<TActorRef>) => boolean,\n  options?: Partial<WaitForOptions>\n): Promise<SnapshotFrom<TActorRef>> {\n  const resolvedOptions: WaitForOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    let done = false;\n    if (isDevelopment && resolvedOptions.timeout < 0) {\n      console.error(\n        '`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.'\n      );\n    }\n    const handle =\n      resolvedOptions.timeout === Infinity\n        ? undefined\n        : setTimeout(() => {\n            sub!.unsubscribe();\n            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n          }, resolvedOptions.timeout);\n\n    const dispose = () => {\n      clearTimeout(handle!);\n      done = true;\n      sub?.unsubscribe();\n    };\n\n    function checkEmitted(emitted: SnapshotFrom<TActorRef>) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    let sub: Subscription | undefined; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: (err) => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n","import { Clock } from './interpreter.ts';\n\nexport interface SimulatedClock extends Clock {\n  start(speed: number): void;\n  increment(ms: number): void;\n  set(ms: number): void;\n}\n\ninterface SimulatedTimeout {\n  start: number;\n  timeout: number;\n  fn: (...args: any[]) => void;\n}\nexport class SimulatedClock implements SimulatedClock {\n  private timeouts: Map<number, SimulatedTimeout> = new Map();\n  private _now: number = 0;\n  private _id: number = 0;\n  public now() {\n    return this._now;\n  }\n  private getId() {\n    return this._id++;\n  }\n  public setTimeout(fn: (...args: any[]) => void, timeout: number) {\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  public clearTimeout(id: number) {\n    this.timeouts.delete(id);\n  }\n  public set(time: number) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n\n    this._now = time;\n    this.flushTimeouts();\n  }\n  private flushTimeouts() {\n    [...this.timeouts]\n      .sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n        const endA = timeoutA.start + timeoutA.timeout;\n        const endB = timeoutB.start + timeoutB.timeout;\n        return endB > endA ? -1 : 1;\n      })\n      .forEach(([id, timeout]) => {\n        if (this.now() - timeout.start >= timeout.timeout) {\n          this.timeouts.delete(id);\n          timeout.fn.call(null);\n        }\n      });\n  }\n  public increment(ms: number): void {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n","import {\n  MachineConfig,\n  MachineContext,\n  InternalMachineImplementations,\n  ParameterizedObject,\n  ProvidedActor,\n  NonReducibleUnknown,\n  Prop,\n  AnyEventObject\n} from './types.ts';\nimport {\n  TypegenConstraint,\n  ResolveTypegenMeta,\n  TypegenDisabled\n} from './typegenTypes.ts';\nimport { StateMachine } from './StateMachine.ts';\n\nexport function createMachine<\n  TContext extends MachineContext,\n  TEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TTag extends string,\n  TInput,\n  TOutput extends NonReducibleUnknown,\n  // it's important to have at least one default type parameter here\n  // it allows us to benefit from contextual type instantiation as it makes us to pass the hasInferenceCandidatesOrDefault check in the compiler\n  // we should be able to remove this when we start inferring TConfig, with it we'll always have an inference candidate\n  TTypesMeta extends TypegenConstraint = TypegenDisabled\n>(\n  config: MachineConfig<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TTag,\n    TInput,\n    TOutput,\n    TTypesMeta\n  >,\n  implementations?: InternalMachineImplementations<\n    TContext,\n    TEvent,\n    TActor,\n    TAction,\n    TDelay,\n    ResolveTypegenMeta<\n      TTypesMeta,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TTag\n    >\n  >\n): StateMachine<\n  TContext,\n  TEvent,\n  TActor,\n  TAction,\n  TGuard,\n  TDelay,\n  Prop<\n    ResolveTypegenMeta<\n      TTypesMeta,\n      TEvent,\n      TActor,\n      TAction,\n      TGuard,\n      TDelay,\n      TTag\n    >['resolved'],\n    'tags'\n  > &\n    string,\n  TInput,\n  TOutput,\n  ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag>\n> {\n  return new StateMachine<any, any, any, any, any, any, any, any, any, any>(\n    config as any,\n    implementations as any\n  );\n}\n","import {\n  ActorLogic,\n  EventObject,\n  AnyActorSystem,\n  AnyEventObject,\n  ActorSystem,\n  ActorRefFrom,\n  TODO,\n  Snapshot,\n  HomomorphicOmit\n} from '../types';\nimport { XSTATE_INIT, XSTATE_STOP } from '../constants.ts';\n\ntype CallbackSnapshot<TInput, TEvent> = Snapshot<undefined> & {\n  input: TInput;\n  _receivers: Set<(e: TEvent) => void>;\n  _dispose: (() => void) | void;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = unknown\n> = ActorLogic<\n  CallbackSnapshot<TInput, TEvent>,\n  TEvent,\n  TInput,\n  HomomorphicOmit<CallbackSnapshot<TInput, TEvent>, '_receivers' | '_dispose'>,\n  ActorSystem<any>\n>;\n\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = unknown\n> = ActorRefFrom<CallbackActorLogic<TEvent, TInput>>;\n\nexport type Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type InvokeCallback<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = unknown\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive\n}: {\n  input: TInput;\n  system: AnyActorSystem;\n  self: CallbackActorRef<TEvent>;\n  sendBack: (event: TSentEvent) => void;\n  receive: Receiver<TEvent>;\n}) => (() => void) | void;\n\nexport function fromCallback<TEvent extends EventObject, TInput = unknown>(\n  invokeCallback: InvokeCallback<TEvent, AnyEventObject, TInput>\n): CallbackActorLogic<TEvent, TInput> {\n  const logic: CallbackActorLogic<TEvent, TInput> = {\n    config: invokeCallback,\n    start: (_state, { self, system }) => {\n      system._relay(self, self, { type: XSTATE_INIT });\n    },\n    transition: (state, event, { self, system }) => {\n      if (event.type === XSTATE_INIT) {\n        const sendBack = (eventForParent: AnyEventObject) => {\n          if (state.status === 'stopped') {\n            return;\n          }\n\n          if (self._parent) {\n            system._relay(self, self._parent, eventForParent);\n          }\n        };\n\n        const receive: Receiver<TEvent> = (newListener) => {\n          state._receivers.add(newListener);\n        };\n\n        state._dispose = invokeCallback({\n          input: state.input,\n          system,\n          self: self as TODO,\n          sendBack,\n          receive\n        });\n\n        return state;\n      }\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        if (typeof state._dispose === 'function') {\n          state._dispose();\n        }\n        return state;\n      }\n\n      state._receivers.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input,\n        _receivers: new Set(),\n        _dispose: undefined\n      };\n    },\n    getPersistedState: ({ _dispose, _receivers, ...rest }) => rest,\n    restoreState: (state) => ({\n      _receivers: new Set(),\n      _dispose: undefined,\n      ...state\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport {\n  Subscribable,\n  ActorLogic,\n  EventObject,\n  Subscription,\n  AnyActorSystem,\n  ActorRefFrom,\n  Snapshot,\n  HomomorphicOmit\n} from '../types';\n\nexport type ObservableSnapshot<TContext, TInput> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservablePersistedState<TContext, TInput> = HomomorphicOmit<\n  ObservableSnapshot<TContext, TInput>,\n  '_subscription'\n>;\n\nexport type ObservableActorLogic<TContext, TInput> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  ObservablePersistedState<TContext, TInput>,\n  AnyActorSystem\n>;\n\nexport type ObservableActorRef<TContext> = ActorRefFrom<\n  ObservableActorLogic<TContext, any>\n>;\n\nexport function fromObservable<TContext, TInput>(\n  observableCreator: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput> {\n  const nextEventType = '$$xstate.next';\n  const errorEventType = '$$xstate.error';\n  const completeEventType = '$$xstate.complete';\n\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput> = {\n    config: observableCreator,\n    transition: (snapshot, event, { self, id, defer, system }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case nextEventType: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case errorEventType:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case completeEventType:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, { type: nextEventType, data: value });\n        },\n        error: (err) => {\n          system._relay(self, self, { type: errorEventType, data: err });\n        },\n        complete: () => {\n          system._relay(self, self, { type: completeEventType });\n        }\n      });\n    },\n    getPersistedState: ({ _subscription, ...state }) => state,\n    restoreState: (state) => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable\n * that delivers event objects.\n *\n *\n * @param lazyObservable A function that creates an observable\n * @returns Event observable logic\n */\n\nexport function fromEventObservable<T extends EventObject, TInput>(\n  lazyObservable: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<T>;\n  }) => Subscribable<T>\n): ObservableActorLogic<T, TInput> {\n  const errorEventType = '$$xstate.error';\n  const completeEventType = '$$xstate.complete';\n\n  // TODO: event types\n  const logic: ObservableActorLogic<T, TInput> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case errorEventType:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case completeEventType:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, { type: errorEventType, data: err });\n        },\n        complete: () => {\n          system._relay(self, self, { type: completeEventType });\n        }\n      });\n    },\n    getPersistedState: ({ _subscription, ...state }) => state,\n    restoreState: (state) => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n","import { matchesState } from './utils.ts';\n\nexport function mapState(\n  stateMap: { [stateId: string]: any },\n  stateId: string\n) {\n  let foundStateId: string | undefined;\n\n  for (const mappedStateId of Object.keys(stateMap)) {\n    if (\n      matchesState(mappedStateId, stateId) &&\n      (!foundStateId || stateId.length > foundStateId.length)\n    ) {\n      foundStateId = mappedStateId;\n    }\n  }\n\n  return stateMap[foundStateId!];\n}\n"],"names":["STATE_DELIMITER","TARGETLESS_KEY","NULL_EVENT","XSTATE_INIT","XSTATE_ERROR","XSTATE_STOP","cache","WeakMap","memo","object","key","fn","memoizedData","get","set","createDoneStateEvent","id","output","type","createErrorActorEvent","data","createInitEvent","input","resolveCancel","_","state","actionArgs","sendId","executeCancel","actorContext","resolvedSendId","self","cancel","resolve","execute","Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","prepend","event","value","enqueue","enqueued","consumed","getDevTools","w","globalThis","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","idCounter","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","toStatePath","stateId","isArray","toString","split","e","Error","stateValue","pathToStateValue","statePath","length","marker","i","previous","mapValues","collection","iteratee","result","collectionKeys","flatten","array","concat","toArrayStrict","toArray","undefined","resolveOutput","mapper","context","Array","toTransitionConfigArray","configLike","map","transitionLike","target","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","error","complete","resolveReferencedActor","referenced","src","ActorStatus","InterpreterStatus","defaultOptions","clock","ms","clearTimeout","logger","console","log","Actor","logic","options","_state","mailbox","delayedEventsMap","observers","Set","status","NotStarted","_parent","ref","_actorContext","_systemId","sessionId","system","_doneEvent","_deferred","resolvedOptions","parent","systemId","inspect","rootActor","children","Map","keyedActors","reverseKeyedActors","_bookId","_register","actorRef","_unregister","delete","_set","existing","observer","add","_sendInspectionEvent","resolvedInspectionEvent","rootId","forEach","_relay","source","sourceRef","targetRef","_send","createSystem","defer","push","stopChild","child","_stop","send","_initState","restoreState","getInitialState","update","snapshot","deferredFn","shift","_stopProcedure","_complete","invokeId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","unsubscribe","Running","initEvent","attachDevTools","nextState","caughtError","transition","stop","size","reportError","err2","delaySend","delay","to","timerId","toJSON","getPersistedState","getSnapshot","createActor","interpret","resolveInvoke","syncSnapshot","machine","implementations","actors","configuredInput","cloneState","executeInvoke","invoke","onSnapshot","resolveStop","args","actorRefOrString","resolvedActorRef","executeStop","checkStateIn","isStateId","configuration","some","sn","slice","matches","checkNot","guards","evaluateGuard","checkAnd","guard","checkOr","isInline","resolved","guardArgs","params","check","isAtomicStateNode","stateNode","getChildren","values","states","filter","getProperAncestors","toStateNode","ancestors","m","getConfiguration","stateNodes","configurationSet","adjList","getAdjList","s","has","initialStateNode","getInitialStateNodes","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isInFinalState","root","includes","str","formatTransition","descriptor","transitionConfig","normalizedTarget","reenter","resolveTarget","actions","eventType","t","targets","getStateNodeById","isInternalTarget","getStateNodeByPath","resolvedTarget","message","resolveHistoryTarget","config","initial","isHistoryNode","iter","descStateNode","targetStateNode","a","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","State","childStateKeys","subStateKey","Boolean","reduce","allSubStateNodes","subStateNode","subStateNodes","transitionNode","transitionAtomicNode","subStateKeys","transitionCompoundNode","allInnerTransitions","subStateValue","innerTransitions","transitionParallelNode","getHistoryNodes","isDescendant","parentStateNode","getPathFromRootToNode","path","unshift","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","from","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","head","current","candidates","findLCCA","transitions","statesToExit","domain","microstep","currentState","actorCtx","isInitial","mutConfiguration","microstate","internalQueue","_internalQueue","sort","b","order","exitStateNode","historyNode","predicate","history","exit","def","exitStates","flatMap","statesToEnter","statesForDefaultEntry","computeEntrySet","stateNodeToEnter","invokeDef","entry","initialActions","grandparent","parentNode","enterStates","nextConfiguration","done","finalActions","resolveActionsAndContext","finalChildStateNode","find","doneStateEvent","getOutput","microstepProcedure","addDescendantStatesToEnter","ancestor","addAncestorStatesToEnter","historyStateNodes","stateForDefaultEntry","initialStates","initialState","properAncestors","anc","intermediateState","action","resolvedAction","builtinAction","macrostep","stopStep","microstates","nextEvent","selectTransitions","selectEventlessTransitions","getTransitionData","enabledTransitionSet","atomicStates","loop","always","resolveStateValue","getInitialConfiguration","initialTransition","static","meta","tags","toStrings","valueKeys","jsonValues","hasTag","tag","can","transitionData","nextEvents","ownEvents","acc","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","assign","resolveChoose","branches","matchedActions","condition","resolveLog","label","executeLog","resolvePure","resolveRaise","eventOrExpr","delaysMap","delays","resolvedEvent","resolvedDelay","configDelay","executeRaise","raise","SpecialTargets","resolveSendTo","targetActorRef","Parent","Internal","startsWith","executeSendTo","sendTo","sendParent","fromTransition","initialContext","resolveEventType","rejectEventType","emptyLogic","EMPTY_OBJECT","toSerializableAction","name","StateNode","description","_key","_machine","join","idMap","stateConfig","_initialize","on","transitionsConfig","onDone","onError","delayedTransition","after","formatTransitions","definition","version","flat","invokeConfig","resolvedId","resolvedSrc","invokeDefValues","afterConfig","mutateEntryExit","afterEvent","delayRef","configTransition","resolvedTransition","isNaN","getDelayedTransitions","_target","formatInitialTransition","selectedTransition","getCandidates","receivedEventType","endsWith","partialEventTokens","eventTokens","tokenIndex","partialEventToken","eventToken","candidate","resolvedContext","guardPassed","guardType","events","StateMachine","types","__xstatenode","__TContext","__TEvent","__TActor","__TAction","__TGuard","__TDelay","__TTag","__TInput","__TOutput","__TResolvedTypesMeta","provide","resolveState","createState","resolvedStateValue","isErrorActorEvent","getPreInitialState","preInitial","preInitialState","macroState","fullPath","relativePath","resolvedStateId","STATE_IDENTIFIER","childrenJson","_actorCtx","actorId","actorData","childState","actorState","defaultWaitForOptions","timeout","timeouts","_now","_id","now","getId","time","flushTimeouts","_idA","timeoutA","_idB","timeoutB","endA","call","increment","and","choose","errorData","arg","invokeCallback","sendBack","eventForParent","receive","newListener","_receivers","_dispose","receiver","rest","lazyObservable","errorEventType","completeEventType","_subscription","observableCreator","nextEventType","promiseCreator","resolvedValue","Promise","then","response","stateMap","foundStateId","mappedStateId","not","or","getActions","pure","stateIn","res","rej","handle","Infinity","sub","dispose","checkEmitted","emitted"],"mappings":"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"}