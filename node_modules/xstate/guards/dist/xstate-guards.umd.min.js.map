{"version":3,"file":"xstate-guards.umd.min.js","sources":["../../src/constants.ts","../../src/stateUtils.ts","../../src/guards.ts"],"sourcesContent":["export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { State, cloneState } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { invoke } from './actions/invoke.ts';\nimport { stop } from './actions/stop.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { ActorStatus } from './interpreter.ts';\nimport {\n  ActionArgs,\n  AnyActorContext,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyState,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayExpr,\n  DelayedTransitionDefinition,\n  EventObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  SingleOrArray,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  AnyActorRef,\n  UnknownAction,\n  ParameterizedObject,\n  ActionFunction,\n  AnyTransitionConfig,\n  ProvidedActor\n} from './types.ts';\nimport {\n  isArray,\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toStateValue,\n  toTransitionConfigArray\n} from './utils.ts';\n\ntype Configuration<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyConfiguration = Configuration<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nfunction getOutput<TContext extends MachineContext, TEvent extends EventObject>(\n  configuration: StateNode<TContext, TEvent>[],\n  context: TContext,\n  event: TEvent,\n  self: AnyActorRef\n) {\n  const { machine } = configuration[0];\n  const { root } = machine;\n\n  if (!root.output) {\n    return undefined;\n  }\n\n  const finalChildStateNode = configuration.find(\n    (stateNode) =>\n      stateNode.type === 'final' && stateNode.parent === machine.root\n  )!;\n\n  const doneStateEvent = createDoneStateEvent(\n    finalChildStateNode.id,\n    finalChildStateNode.output\n      ? resolveOutput(finalChildStateNode.output, context, event, self)\n      : undefined\n  );\n\n  return resolveOutput(root.output, context, doneStateEvent, self);\n}\n\nexport const isAtomicStateNode = (stateNode: StateNode<any, any>) =>\n  stateNode.type === 'atomic' || stateNode.type === 'final';\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nfunction getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getConfiguration(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const configuration = new Set(stateNodes);\n  const configurationSet = new Set(stateNodes);\n\n  const adjList = getAdjList(configurationSet);\n\n  // add descendants\n  for (const s of configuration) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodes(s).forEach((sn) => configurationSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!configurationSet.has(child)) {\n            for (const initialStateNode of getInitialStateNodes(child)) {\n              configurationSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of configurationSet) {\n    let m = s.parent;\n\n    while (m) {\n      configurationSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return configurationSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nexport function getAdjList<\n  TContext extends MachineContext,\n  TE extends EventObject\n>(configuration: Configuration<TContext, TE>): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of configuration) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  configuration: AnyConfiguration\n): StateValue {\n  const config = getConfiguration(configuration);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  configuration: Array<AnyStateNode>,\n  stateNode: AnyStateNode = configuration[0].machine.root\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && configuration.includes(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(configuration, sn)\n    );\n  }\n\n  return false;\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((descriptor) => {\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (descriptor === WILDCARD) {\n          return true;\n        }\n\n        if (!descriptor.endsWith('.*')) {\n          return false;\n        }\n\n        if (isDevelopment && /.*\\*.+/.test(descriptor)) {\n          console.warn(\n            `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`\n          );\n        }\n\n        const partialEventTokens = descriptor.split('.');\n        const eventTokens = receivedEventType.split('.');\n\n        for (\n          let tokenIndex = 0;\n          tokenIndex < partialEventTokens.length;\n          tokenIndex++\n        ) {\n          const partialEventToken = partialEventTokens[tokenIndex];\n          const eventToken = eventTokens[tokenIndex];\n\n          if (partialEventToken === '*') {\n            const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n            if (isDevelopment && !isLastToken) {\n              console.warn(\n                `Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`\n              );\n            }\n\n            return isLastToken;\n          }\n\n          if (partialEventToken !== eventToken) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/**\n * All delayed transitions from the config.\n */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject | undefined,\n          EventObject\n        >,\n    i: number\n  ) => {\n    const delayRef =\n      typeof delay === 'function' ? `${stateNode.id}:delay[${i}]` : delay;\n    const afterEvent = createAfterEvent(delayRef, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, { id: eventType, delay }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = isArray(afterConfig)\n    ? afterConfig.map((transition, i) => {\n        const eventType = mutateEntryExit(transition.delay, i);\n        return { ...transition, event: eventType };\n      })\n    : Object.keys(afterConfig).flatMap((delay, i) => {\n        const configTransition = afterConfig[delay];\n        const resolvedTransition =\n          typeof configTransition === 'string'\n            ? { target: configTransition }\n            : configTransition;\n        const resolvedDelay = !isNaN(+delay) ? +delay : delay;\n        const eventType = mutateEntryExit(resolvedDelay, i);\n        return toArray(resolvedTransition).map((transition) => ({\n          ...transition,\n          event: eventType,\n          delay: resolvedDelay\n        }));\n      });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | SingleOrArray<string>\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  if (typeof _target === 'string' || isArray(_target)) {\n    const targets = toArray(_target).map((t) => {\n      // Resolve state string keys (which represent children)\n      // to their state node\n      const descStateNode =\n        typeof t === 'string'\n          ? isStateId(t)\n            ? stateNode.machine.getStateNodeById(t)\n            : stateNode.states[t]\n          : t;\n\n      if (!descStateNode) {\n        throw new Error(\n          `Initial state node \"${t}\" not found on parent state node #${stateNode.id}`\n        );\n      }\n\n      if (!isDescendant(descStateNode, stateNode)) {\n        throw new Error(\n          `Invalid initial target: state node #${descStateNode.id} is not a descendant of #${stateNode.id}`\n        );\n      }\n\n      return descStateNode;\n    });\n    const resolvedTarget = resolveTarget(stateNode, targets);\n\n    const transition = {\n      source: stateNode,\n      actions: [],\n      eventType: null as any,\n      reenter: false,\n      target: resolvedTarget!,\n      toJSON: () => ({\n        ...transition,\n        source: `#${stateNode.id}`,\n        target: resolvedTarget\n          ? resolvedTarget.map((t) => `#${t.id}`)\n          : undefined\n      })\n    };\n\n    return transition;\n  }\n\n  return formatTransition(stateNode, '__INITIAL__', {\n    target: toArray(_target.target).map((t) => {\n      if (typeof t === 'string') {\n        return isStateId(t) ? t : `${STATE_DELIMITER}${t}`;\n      }\n\n      return t;\n    }),\n    actions: _target.actions\n  }) as InitialTransitionDefinition<TContext, TEvent>;\n}\n\nexport function resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }): ReadonlyArray<AnyStateNode> {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial.target;\n  }\n  return normalizedTarget.map((t) =>\n    typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n  );\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nexport function getInitialStateNodes(\n  stateNode: AnyStateNode\n): Array<AnyStateNode> {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      for (const targetStateNode of descStateNode.initial.target) {\n        for (const a of getProperAncestors(targetStateNode, stateNode)) {\n          set.add(a);\n        }\n\n        iter(targetStateNode);\n      }\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return [...set];\n}\n/**\n * Returns the child state node from its relative `stateKey`, or throws.\n */\nexport function getStateNode(\n  stateNode: AnyStateNode,\n  stateKey: string\n): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch (e) {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param state The state value or State instance\n */\nexport function getStateNodes<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  state: StateValue | State<TContext, TEvent, TODO, TODO, TODO>\n): Array<AnyStateNode> {\n  const stateValue = state instanceof State ? state.value : toStateValue(state);\n\n  if (typeof stateValue === 'string') {\n    return [stateNode, stateNode.states[stateValue]];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nexport function transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(state, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]],\n    state,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(state, event);\n  }\n\n  return next;\n}\n\nexport function transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  state: State<TContext, TEvent, TODO, TODO, TODO>,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      state,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(state, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  state: State<\n    TContext,\n    TEvent,\n    TODO,\n    TODO,\n    TODO // tags\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, state, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, state, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, state, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction getPathFromRootToNode(stateNode: AnyStateNode): Array<AnyStateNode> {\n  const path: Array<AnyStateNode> = [];\n  let marker = stateNode.parent;\n\n  while (marker) {\n    path.unshift(marker);\n    marker = marker.parent;\n  }\n\n  return path;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], configuration, historyValue),\n          computeExitSet([t2], configuration, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLCCA(stateNodes: Array<AnyStateNode>): AnyStateNode {\n  const [head] = stateNodes;\n\n  let current = getPathFromRootToNode(head);\n  let candidates: Array<AnyStateNode> = [];\n\n  for (const stateNode of stateNodes) {\n    const path = getPathFromRootToNode(stateNode);\n\n    candidates = current.filter((sn) => path.includes(sn));\n    current = candidates;\n    candidates = [];\n  }\n\n  return current[current.length - 1];\n}\n\nfunction getEffectiveTargetStates(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          {\n            target: resolveHistoryTarget(targetNode)\n          } as AnyTransitionDefinition,\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | null {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return null;\n  }\n\n  if (\n    !transition.reenter &&\n    transition.source.type !== 'parallel' &&\n    targetStates.every((targetStateNode) =>\n      isDescendant(targetStateNode, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lcca = findLCCA(targetStates.concat(transition.source));\n\n  return lcca;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  configuration: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      for (const stateNode of configuration) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\n/**\n * https://www.w3.org/TR/scxml/#microstepProcedure\n *\n * @private\n * @param transitions\n * @param currentState\n * @param mutConfiguration\n */\n\nexport function microstep<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  transitions: Array<TransitionDefinition<TContext, TEvent>>,\n  currentState: AnyState,\n  actorCtx: AnyActorContext,\n  event: TEvent,\n  isInitial: boolean\n): AnyState {\n  const mutConfiguration = new Set(currentState.configuration);\n\n  if (!transitions.length) {\n    return currentState;\n  }\n\n  const microstate = microstepProcedure(\n    transitions,\n    currentState,\n    mutConfiguration,\n    event,\n    actorCtx,\n    isInitial\n  );\n\n  return cloneState(microstate, {\n    value: {} // TODO: make optional\n  });\n}\n\nfunction microstepProcedure(\n  transitions: Array<AnyTransitionDefinition>,\n  currentState: AnyState,\n  mutConfiguration: Set<AnyStateNode>,\n  event: AnyEventObject,\n  actorCtx: AnyActorContext,\n  isInitial: boolean\n): typeof currentState {\n  const actions: UnknownAction[] = [];\n  const historyValue = {\n    ...currentState.historyValue\n  };\n\n  const filteredTransitions = removeConflictingTransitions(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  const internalQueue = [...currentState._internalQueue];\n\n  // Exit states\n  if (!isInitial) {\n    exitStates(filteredTransitions, mutConfiguration, historyValue, actions);\n  }\n\n  // Execute transition content\n  actions.push(...filteredTransitions.flatMap((t) => t.actions));\n\n  // Enter states\n  enterStates(\n    event,\n    filteredTransitions,\n    mutConfiguration,\n    actions,\n    internalQueue,\n    currentState,\n    historyValue,\n    isInitial,\n    actorCtx\n  );\n\n  const nextConfiguration = [...mutConfiguration];\n\n  const done = isInFinalState(nextConfiguration);\n\n  if (done) {\n    const finalActions = nextConfiguration\n      .sort((a, b) => b.order - a.order)\n      .flatMap((state) => state.exit);\n    actions.push(...finalActions);\n  }\n\n  try {\n    const nextState = resolveActionsAndContext(\n      actions,\n      event,\n      currentState,\n      actorCtx\n    );\n\n    const output = done\n      ? getOutput(nextConfiguration, nextState.context, event, actorCtx.self)\n      : undefined;\n\n    internalQueue.push(...nextState._internalQueue);\n\n    return cloneState(currentState, {\n      configuration: nextConfiguration,\n      historyValue,\n      _internalQueue: internalQueue,\n      context: nextState.context,\n      status: done ? 'done' : currentState.status,\n      output,\n      children: nextState.children\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\n\nfunction enterStates(\n  event: AnyEventObject,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  currentState: AnyState,\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean,\n  actorContext: AnyActorContext\n): void {\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentState.machine.root);\n  }\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutConfiguration.add(stateNodeToEnter);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(invoke(invokeDef));\n    }\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      for (const stateNode of statesForDefaultEntry) {\n        const initialActions = stateNode.initial!.actions;\n        actions.push(...initialActions);\n      }\n    }\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent!;\n\n      if (!parent.parent) {\n        continue;\n      }\n\n      internalQueue.push(\n        createDoneStateEvent(\n          parent!.id,\n          stateNodeToEnter.output\n            ? resolveOutput(\n                stateNodeToEnter.output,\n                currentState.context,\n                event,\n                actorContext.self\n              )\n            : undefined\n        )\n      );\n\n      if (parent.parent) {\n        const grandparent = parent.parent;\n\n        if (grandparent.type === 'parallel') {\n          if (\n            getChildren(grandparent).every((parentNode) =>\n              isInFinalState([...mutConfiguration], parentNode)\n            )\n          ) {\n            internalQueue.push(createDoneStateEvent(grandparent.id));\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    for (const s of t.target || []) {\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const ancestor = getTransitionDomain(t, historyValue);\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      addAncestorStatesToEnter(\n        s,\n        ancestor,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode.parent!,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    } else {\n      const targets = resolveHistoryTarget<TContext, TEvent>(stateNode);\n      for (const s of targets) {\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of targets) {\n        addAncestorStatesToEnter(\n          s,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n        for (const stateForDefaultEntry of statesForDefaultEntry) {\n          statesForDefaultEntry.add(stateForDefaultEntry);\n        }\n      }\n    }\n  } else {\n    statesToEnter.add(stateNode);\n    if (stateNode.type === 'compound') {\n      statesForDefaultEntry.add(stateNode);\n      const initialStates = stateNode.initial.target;\n\n      for (const initialState of initialStates) {\n        addDescendantStatesToEnter(\n          initialState,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const initialState of initialStates) {\n        addAncestorStatesToEnter(\n          initialState,\n          stateNode,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | null,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  const properAncestors = getProperAncestors(stateNode, toStateNode);\n  for (const anc of properAncestors) {\n    statesToEnter.add(anc);\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction exitStates(\n  transitions: AnyTransitionDefinition[],\n  mutConfiguration: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  actions: UnknownAction[]\n) {\n  const statesToExit = computeExitSet(\n    transitions,\n    mutConfiguration,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      historyValue[historyNode.id] =\n        Array.from(mutConfiguration).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    actions.push(...s.exit, ...s.invoke.map((def) => stop(def.id)));\n    mutConfiguration.delete(s);\n  }\n}\n\ninterface BuiltinAction {\n  (): void;\n  resolve: (\n    actorContext: AnyActorContext,\n    state: AnyState,\n    actionArgs: ActionArgs<any, any, any, any>,\n    action: unknown\n  ) => [newState: AnyState, params: unknown, actions?: UnknownAction[]];\n  execute: (actorContext: AnyActorContext, params: unknown) => void;\n}\n\nexport function resolveActionsAndContext<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  actions: UnknownAction[],\n  event: TExpressionEvent,\n  currentState: AnyState,\n  actorCtx: AnyActorContext\n): AnyState {\n  const { machine } = currentState;\n  // TODO: this `cloneState` is really just a hack to prevent infinite loops\n  // we need to take another look at how internal queue is managed\n  let intermediateState = cloneState(currentState, {\n    _internalQueue: []\n  });\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        (\n          machine.implementations.actions as Record<\n            string,\n            ActionFunction<\n              MachineContext,\n              EventObject,\n              EventObject,\n              ParameterizedObject | undefined,\n              ProvidedActor,\n              ParameterizedObject,\n              ParameterizedObject,\n              string\n            >\n          >\n        )[typeof action === 'string' ? action : action.type];\n\n    if (!resolvedAction) {\n      continue;\n    }\n\n    const actionArgs = {\n      context: intermediateState.context,\n      event,\n      self: actorCtx?.self,\n      system: actorCtx?.system,\n      action: isInline\n        ? undefined\n        : typeof action === 'string'\n        ? { type: action }\n        : typeof action.params === 'function'\n        ? {\n            type: action.type,\n            params: action.params({ context: intermediateState.context, event })\n          }\n        : // TS isn't able to narrow it down here\n          (action as { type: string })\n    };\n\n    if (!('resolve' in resolvedAction)) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        resolvedAction(actionArgs);\n      } else {\n        actorCtx?.defer(() => {\n          resolvedAction(actionArgs);\n        });\n      }\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorCtx,\n      intermediateState,\n      actionArgs,\n      resolvedAction // this holds all params\n    );\n    intermediateState = nextState;\n\n    if ('execute' in resolvedAction) {\n      if (actorCtx?.self.status === ActorStatus.Running) {\n        builtinAction.execute(actorCtx!, params);\n      } else {\n        actorCtx?.defer(builtinAction.execute.bind(null, actorCtx!, params));\n      }\n    }\n\n    if (actions) {\n      intermediateState = resolveActionsAndContext(\n        actions,\n        event,\n        intermediateState,\n        actorCtx\n      );\n    }\n  }\n\n  return intermediateState;\n}\n\nexport function macrostep(\n  state: AnyState,\n  event: EventObject,\n  actorCtx: AnyActorContext\n): {\n  state: typeof state;\n  microstates: Array<typeof state>;\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextState = state;\n  const states: AnyState[] = [];\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextState = stopStep(event, nextState, actorCtx);\n    states.push(nextState);\n\n    return {\n      state: nextState,\n      microstates: states\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const transitions = selectTransitions(nextEvent, nextState);\n    nextState = microstep(transitions, state, actorCtx, nextEvent, false);\n    states.push(nextState);\n  }\n\n  while (nextState.status === 'active') {\n    let enabledTransitions = selectEventlessTransitions(nextState, nextEvent);\n\n    if (!enabledTransitions.length) {\n      if (!nextState._internalQueue.length) {\n        break;\n      } else {\n        nextEvent = nextState._internalQueue[0];\n        const transitions = selectTransitions(nextEvent, nextState);\n        nextState = microstep(\n          transitions,\n          nextState,\n          actorCtx,\n          nextEvent,\n          false\n        );\n        nextState._internalQueue.shift();\n\n        states.push(nextState);\n      }\n    } else {\n      nextState = microstep(\n        enabledTransitions,\n        nextState,\n        actorCtx,\n        nextEvent,\n        false\n      );\n\n      states.push(nextState);\n    }\n  }\n\n  if (nextState.status !== 'active') {\n    // Perform the stop step to ensure that child actors are stopped\n    stopStep(nextEvent, nextState, actorCtx);\n  }\n\n  return {\n    state: nextState,\n    microstates: states\n  };\n}\n\nfunction stopStep(\n  event: AnyEventObject,\n  nextState: AnyState,\n  actorCtx: AnyActorContext\n) {\n  const actions: UnknownAction[] = [];\n\n  for (const stateNode of nextState.configuration.sort(\n    (a, b) => b.order - a.order\n  )) {\n    actions.push(...stateNode.exit);\n  }\n\n  for (const child of Object.values(nextState.children)) {\n    actions.push(stop(child));\n  }\n\n  return resolveActionsAndContext(actions, event, nextState, actorCtx);\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyState\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyState,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState.configuration.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, null)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState.configuration),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const configuration = getConfiguration(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...configuration]);\n}\n\nexport function stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a as StateValueMap);\n  const bKeys = Object.keys(b as StateValueMap);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nexport function getInitialConfiguration(\n  rootNode: AnyStateNode\n): AnyStateNode[] {\n  const configuration: AnyStateNode[] = [];\n  const initialTransition = rootNode.initial;\n\n  const statesToEnter = new Set<AnyStateNode>();\n  const statesForDefaultEntry = new Set<AnyStateNode>([rootNode]);\n\n  computeEntrySet(\n    [initialTransition],\n    {},\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    configuration.push(stateNodeToEnter);\n  }\n\n  return configuration;\n}\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyState,\n  NoRequiredParams,\n  NoInfer,\n  WithDynamicParams\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n> {\n  context: TContext;\n  event: TExpressionEvent;\n  guard: TExpressionGuard;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TExpressionGuard, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject,\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    state: AnyState,\n    guardArgs: GuardArgs<any, any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  state: AnyState,\n  _: GuardArgs<any, any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    return state.configuration.some((sn) => sn.id === stateValue.slice(1));\n  }\n\n  return state.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined\n>(stateValue: StateValue) {\n  function stateIn(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    any // TODO: recheck if we could replace this with something better here\n  >;\n}\n\nfunction checkNot(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, state);\n}\n\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(guard: Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>) {\n  function not(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkAnd(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function and(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\nfunction checkOr(\n  state: AnyState,\n  { context, event }: GuardArgs<any, any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, state));\n}\n\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TExpressionGuard extends ParameterizedObject | undefined,\n  TGuard extends ParameterizedObject\n>(\n  guards: ReadonlyArray<\n    Guard<TContext, TExpressionEvent, TExpressionGuard, NoInfer<TGuard>>\n  >\n) {\n  function or(_: GuardArgs<TContext, TExpressionEvent, TExpressionGuard>) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or as GuardPredicate<\n    TContext,\n    TExpressionEvent,\n    TExpressionGuard,\n    TGuard\n  >;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  state: AnyState\n): boolean {\n  const { machine } = state;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, state);\n  }\n\n  const guardArgs = {\n    context,\n    event,\n    guard: isInline\n      ? undefined\n      : typeof guard === 'string'\n      ? { type: guard }\n      : typeof guard.params === 'function'\n      ? {\n          type: guard.type,\n          params: guard.params({ context, event })\n        }\n      : guard\n  };\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    state,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n"],"names":["isStateId","str","checkStateIn","state","_","stateValue","configuration","some","sn","id","slice","matches","checkNot","context","event","guards","evaluateGuard","checkAnd","every","guard","checkOr","machine","isInline","resolved","implementations","type","Error","guardArgs","undefined","params","check","and","not","or","stateIn"],"mappings":"oPAGO,MCuOMA,EAAaC,GDvOM,MCuOUA,EAAI,GCtK9C,SAASC,EACPC,EACAC,GACAC,WAAEA,IAEF,MAA0B,iBAAfA,GAA2BL,EAAUK,GACvCF,EAAMG,cAAcC,MAAMC,GAAOA,EAAGC,KAAOJ,EAAWK,MAAM,KAG9DP,EAAMQ,QAAQN,EACvB,CAyBA,SAASO,EACPT,GACAU,QAAEA,EAAOC,MAAEA,IACXC,OAAEA,IAEF,OAAQC,EAAcD,EAAO,GAAIF,EAASC,EAAOX,EACnD,CA0BA,SAASc,EACPd,GACAU,QAAEA,EAAOC,MAAEA,IACXC,OAAEA,IAEF,OAAOA,EAAOG,OAAOC,GAAUH,EAAcG,EAAON,EAASC,EAAOX,IACtE,CA8BA,SAASiB,EACPjB,GACAU,QAAEA,EAAOC,MAAEA,IACXC,OAAEA,IAEF,OAAOA,EAAOR,MAAMY,GAAUH,EAAcG,EAAON,EAASC,EAAOX,IACrE,CA+BO,SAASa,EAIdG,EACAN,EACAC,EACAX,GAEA,MAAMkB,QAAEA,GAAYlB,EACdmB,EAA4B,mBAAVH,EAElBI,EAAWD,EACbH,EACAE,EAAQG,gBAAgBT,OACL,iBAAVI,EAAqBA,EAAQA,EAAMM,MAGhD,IAAKH,IAAaC,EAChB,MAAM,IAAIG,MACP,UACkB,iBAAVP,EAAqBA,EAAQA,EAAMM,+BAKhD,GAAwB,mBAAbF,EACT,OAAOP,EAAcO,EAAWV,EAASC,EAAOX,GAGlD,MAAMwB,EAAY,CAChBd,UACAC,QACAK,MAAOG,OACHM,EACiB,iBAAVT,EACP,CAAEM,KAAMN,GACgB,mBAAjBA,EAAMU,OACb,CACEJ,KAAMN,EAAMM,KACZI,OAAQV,EAAMU,OAAO,CAAEhB,UAASC,WAElCK,GAGN,KAAM,UAAWI,GAIf,OAAOA,EAASI,GAKlB,OAFqBJ,EAEDO,MAClB3B,EACAwB,EACAJ,EAEJ,OA5HO,SAMLR,GAIA,SAASgB,EAAI3B,GAIX,OAAO,CACT,CAKA,OAHA2B,EAAID,MAAQb,EACZc,EAAIhB,OAASA,EAENgB,CAMT,0BA1DO,SAKLZ,GACA,SAASa,EAAI5B,GAIX,OAAO,CACT,CAKA,OAHA4B,EAAIF,MAAQlB,EACZoB,EAAIjB,OAAS,CAACI,GAEPa,CAMT,OA8CO,SAMLjB,GAIA,SAASkB,EAAG7B,GAIV,OAAO,CACT,CAKA,OAHA6B,EAAGH,MAAQV,EACXa,EAAGlB,OAASA,EAELkB,CAMT,YA7HO,SAIL5B,GACA,SAAS6B,EAAQ9B,GAIf,OAAO,CACT,CAKA,OAHA8B,EAAQJ,MAAQ5B,EAChBgC,EAAQ7B,WAAaA,EAEd6B,CAMT"}