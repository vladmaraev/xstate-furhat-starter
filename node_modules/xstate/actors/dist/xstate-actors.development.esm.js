import { X as XSTATE_INIT, j as XSTATE_STOP, d as createActor } from '../../dist/interpreter-825f3d6e.development.esm.js';
import '../../dev/dist/xstate-dev.development.esm.js';

/**
 * Returns actor logic from a transition function and its initial state.
 *
 * A transition function is a function that takes the current state and an event and returns the next state.
 *
 * @param transition The transition function that returns the next state given the current state and event.
 * @param initialContext The initial state of the transition function.
 * @returns Actor logic
 */
function fromTransition(transition, initialContext) {
  return {
    config: transition,
    transition: (state, event, actorContext) => {
      return {
        ...state,
        context: transition(state.context, event, actorContext)
      };
    },
    getInitialState: (_, input) => {
      return {
        status: 'active',
        output: undefined,
        error: undefined,
        context: typeof initialContext === 'function' ? initialContext({
          input
        }) : initialContext
      };
    },
    getPersistedState: state => state,
    restoreState: state => state
  };
}

function fromCallback(invokeCallback) {
  const logic = {
    config: invokeCallback,
    start: (_state, {
      self,
      system
    }) => {
      system._relay(self, self, {
        type: XSTATE_INIT
      });
    },
    transition: (state, event, {
      self,
      system
    }) => {
      if (event.type === XSTATE_INIT) {
        const sendBack = eventForParent => {
          if (state.status === 'stopped') {
            return;
          }
          if (self._parent) {
            system._relay(self, self._parent, eventForParent);
          }
        };
        const receive = newListener => {
          state._receivers.add(newListener);
        };
        state._dispose = invokeCallback({
          input: state.input,
          system,
          self: self,
          sendBack,
          receive
        });
        return state;
      }
      if (event.type === XSTATE_STOP) {
        state = {
          ...state,
          status: 'stopped',
          error: undefined
        };
        if (typeof state._dispose === 'function') {
          state._dispose();
        }
        return state;
      }
      state._receivers.forEach(receiver => receiver(event));
      return state;
    },
    getInitialState: (_, input) => {
      return {
        status: 'active',
        output: undefined,
        error: undefined,
        input,
        _receivers: new Set(),
        _dispose: undefined
      };
    },
    getPersistedState: ({
      _dispose,
      _receivers,
      ...rest
    }) => rest,
    restoreState: state => ({
      _receivers: new Set(),
      _dispose: undefined,
      ...state
    })
  };
  return logic;
}

function fromObservable(observableCreator) {
  const nextEventType = '$$xstate.next';
  const errorEventType = '$$xstate.error';
  const completeEventType = '$$xstate.complete';

  // TODO: add event types
  const logic = {
    config: observableCreator,
    transition: (snapshot, event, {
      self,
      id,
      defer,
      system
    }) => {
      if (snapshot.status !== 'active') {
        return snapshot;
      }
      switch (event.type) {
        case nextEventType:
          {
            const newSnapshot = {
              ...snapshot,
              context: event.data
            };
            return newSnapshot;
          }
        case errorEventType:
          return {
            ...snapshot,
            status: 'error',
            error: event.data,
            input: undefined,
            _subscription: undefined
          };
        case completeEventType:
          return {
            ...snapshot,
            status: 'done',
            input: undefined,
            _subscription: undefined
          };
        case XSTATE_STOP:
          snapshot._subscription.unsubscribe();
          return {
            ...snapshot,
            status: 'stopped',
            input: undefined,
            _subscription: undefined
          };
        default:
          return snapshot;
      }
    },
    getInitialState: (_, input) => {
      return {
        status: 'active',
        output: undefined,
        error: undefined,
        context: undefined,
        input,
        _subscription: undefined
      };
    },
    start: (state, {
      self,
      system
    }) => {
      if (state.status === 'done') {
        // Do not restart a completed observable
        return;
      }
      state._subscription = observableCreator({
        input: state.input,
        system,
        self
      }).subscribe({
        next: value => {
          system._relay(self, self, {
            type: nextEventType,
            data: value
          });
        },
        error: err => {
          system._relay(self, self, {
            type: errorEventType,
            data: err
          });
        },
        complete: () => {
          system._relay(self, self, {
            type: completeEventType
          });
        }
      });
    },
    getPersistedState: ({
      _subscription,
      ...state
    }) => state,
    restoreState: state => ({
      ...state,
      _subscription: undefined
    })
  };
  return logic;
}

/**
 * Creates event observable logic that listens to an observable
 * that delivers event objects.
 *
 *
 * @param lazyObservable A function that creates an observable
 * @returns Event observable logic
 */

function fromEventObservable(lazyObservable) {
  const errorEventType = '$$xstate.error';
  const completeEventType = '$$xstate.complete';

  // TODO: event types
  const logic = {
    config: lazyObservable,
    transition: (state, event) => {
      if (state.status !== 'active') {
        return state;
      }
      switch (event.type) {
        case errorEventType:
          return {
            ...state,
            status: 'error',
            error: event.data,
            input: undefined,
            _subscription: undefined
          };
        case completeEventType:
          return {
            ...state,
            status: 'done',
            input: undefined,
            _subscription: undefined
          };
        case XSTATE_STOP:
          state._subscription.unsubscribe();
          return {
            ...state,
            status: 'stopped',
            input: undefined,
            _subscription: undefined
          };
        default:
          return state;
      }
    },
    getInitialState: (_, input) => {
      return {
        status: 'active',
        output: undefined,
        error: undefined,
        context: undefined,
        input,
        _subscription: undefined
      };
    },
    start: (state, {
      self,
      system
    }) => {
      if (state.status === 'done') {
        // Do not restart a completed observable
        return;
      }
      state._subscription = lazyObservable({
        input: state.input,
        system,
        self
      }).subscribe({
        next: value => {
          if (self._parent) {
            system._relay(self, self._parent, value);
          }
        },
        error: err => {
          system._relay(self, self, {
            type: errorEventType,
            data: err
          });
        },
        complete: () => {
          system._relay(self, self, {
            type: completeEventType
          });
        }
      });
    },
    getPersistedState: ({
      _subscription,
      ...state
    }) => state,
    restoreState: state => ({
      ...state,
      _subscription: undefined
    })
  };
  return logic;
}

const resolveEventType = '$$xstate.resolve';
const rejectEventType = '$$xstate.reject';
function fromPromise(
// TODO: add types
promiseCreator) {
  // TODO: add event types
  const logic = {
    config: promiseCreator,
    transition: (state, event) => {
      if (state.status !== 'active') {
        return state;
      }
      switch (event.type) {
        case resolveEventType:
          {
            const resolvedValue = event.data;
            return {
              ...state,
              status: 'done',
              output: resolvedValue,
              input: undefined
            };
          }
        case rejectEventType:
          return {
            ...state,
            status: 'error',
            error: event.data,
            input: undefined
          };
        case XSTATE_STOP:
          return {
            ...state,
            status: 'stopped',
            input: undefined
          };
        default:
          return state;
      }
    },
    start: (state, {
      self,
      system
    }) => {
      // TODO: determine how to allow customizing this so that promises
      // can be restarted if necessary
      if (state.status !== 'active') {
        return;
      }
      const resolvedPromise = Promise.resolve(promiseCreator({
        input: state.input,
        system,
        self
      }));
      resolvedPromise.then(response => {
        if (self.getSnapshot().status !== 'active') {
          return;
        }
        system._relay(self, self, {
          type: resolveEventType,
          data: response
        });
      }, errorData => {
        if (self.getSnapshot().status !== 'active') {
          return;
        }
        system._relay(self, self, {
          type: rejectEventType,
          data: errorData
        });
      });
    },
    getInitialState: (_, input) => {
      return {
        status: 'active',
        output: undefined,
        error: undefined,
        input
      };
    },
    getPersistedState: state => state,
    restoreState: state => state
  };
  return logic;
}

const emptyLogic = fromTransition(_ => undefined, undefined);
function createEmptyActor() {
  return createActor(emptyLogic);
}

export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };
