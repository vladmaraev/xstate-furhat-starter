{"version":3,"file":"xstate-actors.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/eventUtils.ts","../../src/dev/index.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/system.ts","../../src/utils.ts","../../src/interpreter.ts","../../src/actors/transition.ts","../../src/actors/promise.ts","../../src/actors/index.ts","../../src/actors/callback.ts","../../src/actors/observable.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  // TODO: rethink this design\n  public prepend(event: T): void {\n    if (!this._current) {\n      this.enqueue(event);\n      return;\n    }\n\n    // we know that something is already queued up\n    // so the mailbox is already flushing or it's inactive\n    // therefore the only thing that we need to do is to reassign `this._current`\n    this._current = {\n      value: event,\n      next: this._current\n    };\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      // something could have been prepended in the meantime\n      // so we need to be defensive here to avoid skipping over a prepended item\n      if (consumed === this._current) {\n        this._current = this._current.next;\n      }\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id?: string) {\n  const idSuffix = id ? `#${id}` : '';\n  return { type: `xstate.after(${delayRef})${idSuffix}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  data?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, data };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if (!!(w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate macrotask.\n * It allows those errors to be detected by global error handlers and reported to bug tracking services\n * without interrupting our own stack of execution.\n *\n * @param err error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import {\n  AnyEventObject,\n  ActorSystem,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  Snapshot\n} from './types.ts';\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const observers = new Set<Observer<InspectionEvent>>();\n\n  const system: ActorSystem<T> = {\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observer) => {\n      observers.add(observer);\n    },\n    _sendInspectionEvent: (event) => {\n      const resolvedInspectionEvent: InspectionEvent = {\n        ...event,\n        rootId: rootActor.sessionId\n      };\n      observers.forEach((observer) => observer.next?.(resolvedInspectionEvent));\n    },\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        targetRef: target,\n        event\n      });\n\n      target._send(event);\n    }\n  };\n\n  return system;\n}\nexport interface BaseInspectionEventProperties {\n  rootId: string; // the session ID of the root\n}\n\nexport interface InspectedSnapshotEvent extends BaseInspectionEventProperties {\n  type: '@xstate.snapshot';\n  actorRef: AnyActorRef; // Only available locally\n  event: AnyEventObject; // { type: string, ... }\n  snapshot: Snapshot<unknown>;\n}\n\nexport interface InspectedEventEvent extends BaseInspectionEventProperties {\n  type: '@xstate.event';\n  // The source might not exist, e.g. when:\n  // - root init events\n  // - events sent from external (non-actor) sources\n  sourceRef: AnyActorRef | undefined;\n  targetRef: AnyActorRef; // Session ID, required\n  event: AnyEventObject; // { type: string, ... }\n}\n\nexport interface InspectedActorEvent extends BaseInspectionEventProperties {\n  type: '@xstate.actor';\n  actorRef: AnyActorRef;\n}\n\nexport type InspectionEvent =\n  | InspectedSnapshotEvent\n  | InspectedEventEvent\n  | InspectedActorEvent;\n","import isDevelopment from '#is-development';\nimport { AnyActorLogic, AnyState } from './index.ts';\nimport { STATE_DELIMITER, TARGETLESS_KEY } from './constants.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type {\n  ActorLogic,\n  AnyEventObject,\n  EventObject,\n  MachineContext,\n  Mapper,\n  Observer,\n  ErrorActorEvent,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  Subscribable,\n  TransitionConfigTarget,\n  AnyActorRef,\n  AnyTransitionConfig,\n  NonReducibleUnknown\n} from './types.ts';\n\nexport function keys<T extends object>(value: T): Array<keyof T & string> {\n  return Object.keys(value) as Array<keyof T & string>;\n}\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  try {\n    if (isArray(stateId)) {\n      return stateId;\n    }\n\n    return stateId.toString().split(STATE_DELIMITER);\n  } catch (e) {\n    throw new Error(`'${stateId}' is not a valid state path.`);\n  }\n}\n\nexport function isStateLike(state: any): state is AnyState {\n  return (\n    typeof state === 'object' &&\n    'value' in state &&\n    'context' in state &&\n    'event' in state\n  );\n}\n\nexport function toStateValue(\n  stateValue: StateLike<any> | StateValue | string[]\n): StateValue {\n  if (isStateLike(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (isArray(stateValue)) {\n    return pathToStateValue(stateValue);\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue as string);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nexport function mapFilterValues<T, P>(\n  collection: { [key: string]: T },\n  iteratee: (item: T, key: string, collection: { [key: string]: T }) => P,\n  predicate: (item: T) => boolean\n): { [key: string]: P } {\n  const result: { [key: string]: P } = {};\n\n  for (const key of Object.keys(collection)) {\n    const item = collection[key];\n\n    if (!predicate(item)) {\n      continue;\n    }\n\n    result[key] = iteratee(item, key, collection);\n  }\n\n  return result;\n}\n\n/**\n * Retrieves a value at the given path.\n * @param props The deep path to the prop of the desired value\n */\nexport function path<T extends Record<string, any>>(props: string[]): any {\n  return (object: T): any => {\n    let result: T = object;\n\n    for (const prop of props) {\n      result = result[prop as keyof typeof result];\n    }\n\n    return result;\n  };\n}\n\nexport function toStatePaths(stateValue: StateValue | undefined): string[][] {\n  if (!stateValue) {\n    return [[]];\n  }\n\n  if (typeof stateValue === 'string') {\n    return [[stateValue]];\n  }\n\n  const result = flatten(\n    Object.keys(stateValue).map((key) => {\n      const subStateValue = stateValue[key];\n\n      if (\n        typeof subStateValue !== 'string' &&\n        (!subStateValue || !Object.keys(subStateValue).length)\n      ) {\n        return [[key]];\n      }\n\n      return toStatePaths(stateValue[key]).map((subPath) => {\n        return [key].concat(subPath);\n      });\n    })\n  );\n\n  return result;\n}\n\nexport function flatten<T>(array: Array<T | T[]>): T[] {\n  return ([] as T[]).concat(...array);\n}\n\nexport function toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([key, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nexport function isBuiltInEvent(eventType: string): boolean {\n  return /^(done|error)\\./.test(eventType);\n}\n\nexport function isPromiseLike(value: any): value is PromiseLike<any> {\n  if (value instanceof Promise) {\n    return true;\n  }\n  // Check if shape matches the Promise/A+ specification for a \"thenable\".\n  if (\n    value !== null &&\n    (typeof value === 'function' || typeof value === 'object') &&\n    typeof value.then === 'function'\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isActorLogic(value: any): value is ActorLogic<any, any> {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'transition' in value &&\n    typeof value.transition === 'function'\n  );\n}\n\nexport function partition<T, A extends T, B extends T>(\n  items: T[],\n  predicate: (item: T) => item is A\n): [A[], B[]] {\n  const [truthy, falsy] = [[], []] as [A[], B[]];\n\n  for (const item of items) {\n    if (predicate(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item as B);\n    }\n  }\n\n  return [truthy, falsy];\n}\n\nexport function isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isObservable<T>(value: any): value is Subscribable<T> {\n  return (\n    !!value && 'subscribe' in value && typeof value.subscribe === 'function'\n  );\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function reportUnhandledExceptionOnInvocation(\n  originalError: any,\n  currentError: any,\n  id: string\n) {\n  if (isDevelopment) {\n    const originalStackTrace = originalError.stack\n      ? ` Stacktrace was '${originalError.stack}'`\n      : '';\n    if (originalError === currentError) {\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler for invocation '${id}', error was '${originalError}'.${originalStackTrace}`\n      );\n    } else {\n      const stackTrace = currentError.stack\n        ? ` Stacktrace was '${currentError.stack}'`\n        : '';\n      // tslint:disable-next-line:no-console\n      console.error(\n        `Missing onError handler and/or unhandled exception/promise rejection for invocation '${id}'. ` +\n          `Original error: '${originalError}'. ${originalStackTrace} Current error is '${currentError}'.${stackTrace}`\n      );\n    }\n  }\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${stateNodeId}:invocation[${index}]`;\n}\n\nexport function resolveReferencedActor(\n  referenced:\n    | AnyActorLogic\n    | {\n        src: AnyActorLogic;\n        input:\n          | Mapper<MachineContext, EventObject, unknown, EventObject>\n          | NonReducibleUnknown;\n      }\n    | undefined\n) {\n  return referenced\n    ? 'transition' in referenced\n      ? { src: referenced, input: undefined }\n      : referenced\n    : undefined;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { createSystem } from './system.ts';\nimport {\n  AreAllImplementationsAssumedToBeProvided,\n  MissingImplementationsError\n} from './typegenTypes.ts';\nimport type {\n  ActorLogic,\n  ActorContext,\n  ActorSystem,\n  AnyActorLogic,\n  AnyStateMachine,\n  EventFromLogic,\n  PersistedStateFrom,\n  SnapshotFrom,\n  AnyActorRef,\n  OutputFrom,\n  DoneActorEvent\n} from './types.ts';\nimport {\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  ActorOptions,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport type SnapshotListener<TLogic extends AnyActorLogic> = (\n  state: SnapshotFrom<TLogic>\n) => void;\n\nexport type EventListener<TEvent extends EventObject = EventObject> = (\n  event: TEvent\n) => void;\n\nexport type Listener = () => void;\nexport type ErrorListener = (error: any) => void;\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\nexport enum ActorStatus {\n  NotStarted,\n  Running,\n  Stopped\n}\n\n/**\n * @deprecated Use `ActorStatus` instead.\n */\nexport const InterpreterStatus = ActorStatus;\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\nexport class Actor<TLogic extends AnyActorLogic>\n  implements ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>\n{\n  /**\n   * The current internal state of the actor.\n   */\n  private _state!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private delayedEventsMap: Record<string, unknown> = {};\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private logger: (...args: any[]) => void;\n  /**\n   * Whether the service is started.\n   */\n  public status: ActorStatus = ActorStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: ActorRef<any, any>;\n  public ref: ActorRef<EventFromLogic<TLogic>, SnapshotFrom<TLogic>>;\n  // TODO: add typings for system\n  private _actorContext: ActorContext<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    any\n  >;\n\n  private _systemId: string | undefined;\n\n  /**\n   * The globally unique process ID for this invocation.\n   */\n  public sessionId: string;\n\n  public system: ActorSystem<any>;\n  private _doneEvent?: DoneActorEvent;\n\n  public src?: string;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options, if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(public logic: TLogic, options?: ActorOptions<TLogic>) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    } as ActorOptions<TLogic> & typeof defaultOptions;\n\n    const { clock, logger, parent, id, systemId, inspect } = resolvedOptions;\n\n    this.system = parent?.system ?? createSystem(this);\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = logger;\n    this.clock = clock;\n    this._parent = parent;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src;\n    this.ref = this;\n    this._actorContext = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    this._initState();\n  }\n\n  private _initState() {\n    this._state = this.options.state\n      ? this.logic.restoreState\n        ? this.logic.restoreState(this.options.state, this._actorContext)\n        : this.options.state\n      : this.logic.getInitialState(this._actorContext, this.options?.input);\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._state = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      deferredFn();\n    }\n\n    for (const observer of this.observers) {\n      // TODO: should observers be notified in case of the error?\n      try {\n        observer.next?.(snapshot);\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    switch ((this._state as any).status) {\n      case 'done':\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._state as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._stopProcedure();\n        this._error((this._state as any).error);\n        if (this._parent) {\n          this.system._relay(\n            this,\n            this._parent,\n            createErrorActorEvent(this.id, (this._state as any).error)\n          );\n        }\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (state: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((state: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this.status !== ActorStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  /**\n   * Starts the Actor from the initial state\n   */\n  public start(): this {\n    if (this.status === ActorStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this.status = ActorStatus.Running;\n\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      targetRef: this,\n      event: initEvent\n    });\n\n    const status = (this._state as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon intialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._state,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n      // fallthrough\n      case 'error':\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._state, this._actorContext);\n      } catch (err) {\n        this._stopProcedure();\n        this._error(err);\n        this._parent?.send(createErrorActorEvent(this.id, err));\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._state, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    // TODO: reexamine what happens when an action (or a guard or smth) throws\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._state, event, this._actorContext);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._stopProcedure();\n      this._error(err);\n      this._parent?.send(createErrorActorEvent(this.id, err));\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this.status === ActorStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this.status === ActorStatus.NotStarted) {\n      this.status = ActorStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /**\n   * Stops the Actor and unsubscribe all listeners.\n   */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _error(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _stopProcedure(): this {\n    if (this.status !== ActorStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    for (const key of Object.keys(this.delayedEventsMap)) {\n      this.clock.clearTimeout(this.delayedEventsMap[key]);\n    }\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this.status = ActorStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this.status === ActorStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public delaySend({\n    event,\n    id,\n    delay,\n    to\n  }: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number;\n    to?: AnyActorRef;\n  }): void {\n    const timerId = this.clock.setTimeout(() => {\n      this.system._relay(this, to ?? this, event as EventFromLogic<TLogic>);\n    }, delay);\n\n    // TODO: consider the rehydration story here\n    if (id) {\n      this.delayedEventsMap[id] = timerId;\n    }\n  }\n\n  // TODO: make private (and figure out a way to do this within the machine)\n  public cancel(sendId: string | number): void {\n    this.clock.clearTimeout(this.delayedEventsMap[sendId]);\n    delete this.delayedEventsMap[sendId];\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      id: this.id\n    };\n  }\n\n  public getPersistedState(): PersistedStateFrom<TLogic> | undefined {\n    return this.logic.getPersistedState?.(this._state);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    return this._state;\n  }\n}\n\n/**\n * Creates a new `ActorRef` instance for the given machine with the provided options, if any.\n *\n * @param machine The machine to create an actor from\n * @param options `ActorRef` options\n */\nexport function createActor<TMachine extends AnyStateMachine>(\n  machine: AreAllImplementationsAssumedToBeProvided<\n    TMachine['__TResolvedTypesMeta']\n  > extends true\n    ? TMachine\n    : MissingImplementationsError<TMachine['__TResolvedTypesMeta']>,\n  options?: ActorOptions<TMachine>\n): Actor<TMachine>;\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: ActorOptions<TLogic>\n): Actor<TLogic>;\nexport function createActor(logic: any, options?: ActorOptions<any>): any {\n  const interpreter = new Actor(logic, options);\n\n  return interpreter;\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @deprecated Use `createActor` instead\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n */\nexport type Interpreter = typeof Actor;\n","import {\n  ActorLogic,\n  ActorContext,\n  ActorSystem,\n  EventObject,\n  ActorRefFrom,\n  AnyActorSystem,\n  Snapshot\n} from '../types';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  TransitionSnapshot<TContext>,\n  AnyActorSystem\n>;\n\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFrom<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic from a transition function and its initial state.\n *\n * A transition function is a function that takes the current state and an event and returns the next state.\n *\n * @param transition The transition function that returns the next state given the current state and event.\n * @param initialContext The initial state of the transition function.\n * @returns Actor logic\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends ActorSystem<any>,\n  TInput\n>(\n  transition: (\n    state: TContext,\n    event: TEvent,\n    actorContext: ActorContext<TransitionSnapshot<TContext>, TEvent, TSystem>\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput> {\n  return {\n    config: transition,\n    transition: (state, event, actorContext) => {\n      return {\n        ...state,\n        context: transition(state.context, event as TEvent, actorContext as any)\n      };\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedState: (state) => state,\n    restoreState: (state) => state\n  };\n}\n","import {\n  ActorLogic,\n  ActorRefFrom,\n  ActorSystem,\n  AnyActorSystem,\n  Snapshot\n} from '../types';\nimport { XSTATE_STOP } from '../constants';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst resolveEventType = '$$xstate.resolve';\nconst rejectEventType = '$$xstate.reject';\n\nexport type PromiseActorEvents<T> =\n  | {\n      type: typeof resolveEventType;\n      data: T;\n    }\n  | {\n      type: typeof rejectEventType;\n      data: any;\n    }\n  | {\n      type: typeof XSTATE_STOP;\n    };\n\nexport type PromiseActorLogic<TOutput, TInput = unknown> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  PromiseSnapshot<TOutput, TInput>, // persisted state\n  ActorSystem<any>\n>;\n\nexport type PromiseActorRef<TOutput> = ActorRefFrom<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\nexport function fromPromise<TOutput, TInput = unknown>(\n  // TODO: add types\n  promiseCreator: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: PromiseActorRef<TOutput>;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput> {\n  // TODO: add event types\n  const logic: PromiseActorLogic<TOutput, TInput> = {\n    config: promiseCreator,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case resolveEventType: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case rejectEventType:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({ input: state.input!, system, self })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, { type: resolveEventType, data: response });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, { type: rejectEventType, data: errorData });\n        }\n      );\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedState: (state) => state,\n    restoreState: (state) => state\n  };\n\n  return logic;\n}\n","import { createActor } from '../interpreter.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport { fromCallback, type CallbackActorLogic } from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic\n} from './observable.ts';\nexport { fromPromise, type PromiseActorLogic } from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  AnyEventObject,\n  Snapshot<undefined>\n> {\n  return createActor(emptyLogic);\n}\n","import {\n  ActorLogic,\n  EventObject,\n  AnyActorSystem,\n  AnyEventObject,\n  ActorSystem,\n  ActorRefFrom,\n  TODO,\n  Snapshot,\n  HomomorphicOmit\n} from '../types';\nimport { XSTATE_INIT, XSTATE_STOP } from '../constants.ts';\n\ntype CallbackSnapshot<TInput, TEvent> = Snapshot<undefined> & {\n  input: TInput;\n  _receivers: Set<(e: TEvent) => void>;\n  _dispose: (() => void) | void;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = unknown\n> = ActorLogic<\n  CallbackSnapshot<TInput, TEvent>,\n  TEvent,\n  TInput,\n  HomomorphicOmit<CallbackSnapshot<TInput, TEvent>, '_receivers' | '_dispose'>,\n  ActorSystem<any>\n>;\n\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = unknown\n> = ActorRefFrom<CallbackActorLogic<TEvent, TInput>>;\n\nexport type Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type InvokeCallback<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = unknown\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive\n}: {\n  input: TInput;\n  system: AnyActorSystem;\n  self: CallbackActorRef<TEvent>;\n  sendBack: (event: TSentEvent) => void;\n  receive: Receiver<TEvent>;\n}) => (() => void) | void;\n\nexport function fromCallback<TEvent extends EventObject, TInput = unknown>(\n  invokeCallback: InvokeCallback<TEvent, AnyEventObject, TInput>\n): CallbackActorLogic<TEvent, TInput> {\n  const logic: CallbackActorLogic<TEvent, TInput> = {\n    config: invokeCallback,\n    start: (_state, { self, system }) => {\n      system._relay(self, self, { type: XSTATE_INIT });\n    },\n    transition: (state, event, { self, system }) => {\n      if (event.type === XSTATE_INIT) {\n        const sendBack = (eventForParent: AnyEventObject) => {\n          if (state.status === 'stopped') {\n            return;\n          }\n\n          if (self._parent) {\n            system._relay(self, self._parent, eventForParent);\n          }\n        };\n\n        const receive: Receiver<TEvent> = (newListener) => {\n          state._receivers.add(newListener);\n        };\n\n        state._dispose = invokeCallback({\n          input: state.input,\n          system,\n          self: self as TODO,\n          sendBack,\n          receive\n        });\n\n        return state;\n      }\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        if (typeof state._dispose === 'function') {\n          state._dispose();\n        }\n        return state;\n      }\n\n      state._receivers.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input,\n        _receivers: new Set(),\n        _dispose: undefined\n      };\n    },\n    getPersistedState: ({ _dispose, _receivers, ...rest }) => rest,\n    restoreState: (state) => ({\n      _receivers: new Set(),\n      _dispose: undefined,\n      ...state\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport {\n  Subscribable,\n  ActorLogic,\n  EventObject,\n  Subscription,\n  AnyActorSystem,\n  ActorRefFrom,\n  Snapshot,\n  HomomorphicOmit\n} from '../types';\n\nexport type ObservableSnapshot<TContext, TInput> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservablePersistedState<TContext, TInput> = HomomorphicOmit<\n  ObservableSnapshot<TContext, TInput>,\n  '_subscription'\n>;\n\nexport type ObservableActorLogic<TContext, TInput> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  ObservablePersistedState<TContext, TInput>,\n  AnyActorSystem\n>;\n\nexport type ObservableActorRef<TContext> = ActorRefFrom<\n  ObservableActorLogic<TContext, any>\n>;\n\nexport function fromObservable<TContext, TInput>(\n  observableCreator: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput> {\n  const nextEventType = '$$xstate.next';\n  const errorEventType = '$$xstate.error';\n  const completeEventType = '$$xstate.complete';\n\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput> = {\n    config: observableCreator,\n    transition: (snapshot, event, { self, id, defer, system }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case nextEventType: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case errorEventType:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case completeEventType:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, { type: nextEventType, data: value });\n        },\n        error: (err) => {\n          system._relay(self, self, { type: errorEventType, data: err });\n        },\n        complete: () => {\n          system._relay(self, self, { type: completeEventType });\n        }\n      });\n    },\n    getPersistedState: ({ _subscription, ...state }) => state,\n    restoreState: (state) => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable\n * that delivers event objects.\n *\n *\n * @param lazyObservable A function that creates an observable\n * @returns Event observable logic\n */\n\nexport function fromEventObservable<T extends EventObject, TInput>(\n  lazyObservable: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<T>;\n  }) => Subscribable<T>\n): ObservableActorLogic<T, TInput> {\n  const errorEventType = '$$xstate.error';\n  const completeEventType = '$$xstate.complete';\n\n  // TODO: event types\n  const logic: ObservableActorLogic<T, TInput> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case errorEventType:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case completeEventType:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialState: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, { type: errorEventType, data: err });\n        },\n        complete: () => {\n          system._relay(self, self, { type: completeEventType });\n        }\n      });\n    },\n    getPersistedState: ({ _subscription, ...state }) => state,\n    restoreState: (state) => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","prepend","event","value","enqueue","enqueued","consumed","XSTATE_INIT","XSTATE_STOP","createErrorActorEvent","id","data","type","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","idCounter","toObserver","nextHandler","errorHandler","completionHandler","isObserver","undefined","bind","error","complete","ActorStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_state","mailbox","delayedEventsMap","observers","Set","status","NotStarted","_parent","ref","_actorContext","_systemId","sessionId","system","_doneEvent","src","_deferred","resolvedOptions","parent","systemId","inspect","rootActor","children","Map","keyedActors","reverseKeyedActors","WeakMap","_bookId","_register","actorRef","set","_unregister","delete","get","_set","existing","Error","observer","add","_sendInspectionEvent","resolvedInspectionEvent","rootId","forEach","_relay","source","target","sourceRef","targetRef","_send","createSystem","defer","push","stopChild","child","_stop","send","_initState","state","restoreState","getInitialState","input","update","snapshot","deferredFn","shift","_stopProcedure","_complete","invokeId","output","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","unsubscribe","Running","initEvent","attachDevTools","nextState","caughtError","transition","stop","size","reportError","err2","key","Object","keys","delaySend","delay","to","timerId","cancel","sendId","toJSON","getPersistedState","getSnapshot","fromTransition","initialContext","config","actorContext","context","_","resolveEventType","rejectEventType","emptyLogic","invokeCallback","sendBack","eventForParent","receive","newListener","_receivers","_dispose","receiver","rest","lazyObservable","errorEventType","completeEventType","_subscription","observableCreator","nextEventType","promiseCreator","resolvedValue","Promise","resolve","then","response","errorData"],"mappings":"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"}